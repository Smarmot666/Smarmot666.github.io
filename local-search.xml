<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="案例引入："><a href="#案例引入：" class="headerlink" title="案例引入："></a>案例引入：</h1><blockquote><p>有一个猜数字的游戏，即我讲选中1-100以内的某一个数，然后你来猜测，如果你猜的数比我选的数大，我会告诉你大了，反之亦然。</p></blockquote><p><strong>其实这个游戏就运用到了二分法&#x2F;折半查找的思路。即每次筛选都排除掉一半的错误。</strong></p><p>二分查找是一个非常厉害的算法，它的<strong>时间复杂度在对数阶</strong>。</p><hr><h1 id="例题一：找个数"><a href="#例题一：找个数" class="headerlink" title="例题一：找个数"></a>例题一：找个数</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><blockquote><p>运用二分法的思想，寻找一个有序数组中的一个数的下标。这个数必定存在，数组中不存在重复元素项。</p></blockquote><h2 id="输入："><a href="#输入：" class="headerlink" title="输入："></a><strong>输入</strong>：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span>&#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br></code></pre></td></tr></table></figure><h2 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出：</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h2><blockquote><p>定义一个左边界，定义一个右边界</p><p>然后每次比较区间中间的数和目标值</p><p>修改区间，就能删除一半的元素。</p></blockquote><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = size - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//二分查找的细节</span><br><span class="hljs-keyword">while</span> (left &lt;= right) <span class="hljs-comment">//这里是小于等于呢？还是小于？ 这里先采用小于等于的写法，本质是取左闭右闭区间，[left, right]</span><br>&#123;<br>        <br><span class="hljs-comment">//计算中间的那个元素的下标</span><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//如果要找的数小于中间的那个数</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br><span class="hljs-comment">//怎么修改边界与上面的终止条件有关</span><br>right = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果找到了就直接返回这个元素的下标</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br><br><span class="hljs-comment">//计算数组中元素个数</span><br><span class="hljs-type">int</span> size = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br><span class="hljs-type">int</span> index = BinarySearch(arr, target, size);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了，这个数在数组中的下标为：%d&quot;</span>, index);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="细节："><a href="#细节：" class="headerlink" title="细节："></a><strong>细节：</strong></h2><blockquote><p>如果自己去写，很有可能写错，因为根据你<strong>所选取的区间不同</strong>，就会有<strong>其他几种写法</strong>。</p><p>例如 : 假设选取[left, right)区间，即左闭右开区间(上面选取了左闭右闭区间)</p></blockquote><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a><strong>代码如下：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-type">int</span> right = size;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">while</span> (left &lt; right)<br>&#123;<br><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br>right = mid;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意："><a href="#注意：" class="headerlink" title="注意："></a><strong>注意：</strong></h2><blockquote><p>我们要<strong>始终满足我们选取二分区间的定义</strong>，即左边界能不能取得到？右边界能不能取得到？</p><p>如果能取得到，那么修改的时候就要注意了。</p><p>很多人由于不注意细节，加上测试的数据不够多，很容易误以为自己写对了二分查找。</p></blockquote><h1 id="例题二：搜索插入位置"><a href="#例题二：搜索插入位置" class="headerlink" title="例题二：搜索插入位置"></a>例题二：搜索插入位置</h1><h2 id="题目描述：-1"><a href="#题目描述：-1" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>提示:</p><p>1 &lt;&#x3D; nums.length &lt;&#x3D; 104<br>-104 &lt;&#x3D; nums[i] &lt;&#x3D; 104<br>nums 为 <strong>无重复元素</strong> 的 升序 排列数组<br>-104 &lt;&#x3D; target &lt;&#x3D; 104</p></blockquote><h2 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">2</span><br>    <br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">1</span><br>    <br>示例 <span class="hljs-number">3</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">7</span><br>输出: <span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><h2 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h2><blockquote><p>读题，满足了二分法的条件，即数组有序。还告诉了请务必使用复杂度为O(log n) 的算法。</p><p>下面考虑两种情况：</p><p>1、如果数组中有这个元素，那么直接返回这个元素的下标即可。</p><p>2、如果数组中没有这个元素呢？我们通过一个叫做”循环不变量的东西”(下面会讲),可以得出最后所求的位置一定在left&#x2F;right + 1上。</p></blockquote><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = target - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right -left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[mid])<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//或者right + 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="二分查找中的循环不变量："><a href="#二分查找中的循环不变量：" class="headerlink" title="二分查找中的循环不变量："></a>二分查找中的循环不变量：</h1><p><strong>所谓的循环不变量，其实就是二分的过程中会发现，left左边的数全部小于目标值，而right的右边全部大于目标值。</strong></p><h2 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h2><p><strong>假设现在要插入一个47，那么肯定得在下标为4的位置插入。</strong></p><table><thead><tr><th>left</th><th></th><th></th><th>mid</th><th></th><th></th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left</th><th>mid</th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left、right、mid</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th>right</th><th>left</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><p><strong>所以返回left 或者 right+1</strong>。<strong>因为left左边都是小于目标值的，那么就应该插入在比目标值小的序列的后面。因为right右边都是大于目标值的，那么就应该插入在比目标值大的序列的前面。</strong>（以上都是对于没有重复项的序列）</p><hr><h1 id="例题三：在排序数组中查找元素的第一个和最后一个位置"><a href="#例题三：在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="例题三：在排序数组中查找元素的第一个和最后一个位置"></a>例题三：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h1><h2 id="题目描述：-2"><a href="#题目描述：-2" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p>提示：</p><p>0 &lt;&#x3D; nums.length &lt;&#x3D; 105<br>-109 &lt;&#x3D; nums[i] &lt;&#x3D; 109<br>nums 是一个非递减数组<br>-109 &lt;&#x3D; target &lt;&#x3D; 109</p></blockquote><h2 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br>示例 3：<br>输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h2><blockquote><p>注意：</p><p>此题给的有序序列是有重复项的，因此当我们的中间值等于目标值了，我们先不急着返回，因此循环中只有两个选择了，等于的情况可以合并到别的情况中去。</p><p>现假设合并到中间值大于目标值。</p><p>由于循环不变量的原理，left左边的数一定是小于目标值，right右边的数一定是大于等于目标值，那么元素的第一个出现的位置一定是在left或者right + 1的位置。</p><p>那么元素最后一个出现的位置呢？只要我们查找比目标值大1的元素的位置然后减1就行了。</p></blockquote><h2 id="特殊情况的考虑："><a href="#特殊情况的考虑：" class="headerlink" title="特殊情况的考虑："></a>特殊情况的考虑：</h2><blockquote><p>如果没有出现过目标值呢？依旧会返回一个值，但是这个值是 目标值插入这个位置后依旧是有序的时候的位置。因此判断一下这个位置上的数是否为目标值，就可以知道有没有出现过了。</p><p>如果序列中所有值都小于目标值呢？二分会返回一个我们不可访问的地方。需要判断处理。</p></blockquote><hr><h2 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//用来寻找第一次出现的边界</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m_low_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        ans[<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-built_in">m_low_bound</span>(nums, target);<br>       <span class="hljs-comment">//需要注意的地方！</span><br>        <span class="hljs-keyword">if</span>(start &gt;= nums.<span class="hljs-built_in">size</span>() || target != nums[start])<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//记得减1</span><br>        <span class="hljs-type">int</span> end = <span class="hljs-built_in">m_low_bound</span>(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>        ans[<span class="hljs-number">0</span>] = start;<br>        ans[<span class="hljs-number">1</span>] = end;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷宫</title>
    <link href="/2023/03/27/%E8%BF%B7%E5%AE%AB/"/>
    <url>/2023/03/27/%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="一、迷宫问题"><a href="#一、迷宫问题" class="headerlink" title="一、迷宫问题"></a>一、迷宫问题</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc">https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc</a><br>来源：牛客网</p><p>定义一个二维数组 N*M ，如 5 × 5 数组下所示： </p><p>int maze[5][5]&#x3D; {<br>0, 1, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 1, 0,<br>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。</p><p>数据范围： 2 &lt;&#x3D; n,m &lt;&#x3D; 10,  输入的内容只包含 0 &lt;&#x3D; val &lt;&#x3D; 1</p></blockquote><h2 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a><strong>输入描述：</strong></h2><blockquote><p>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p></blockquote><h2 id="输出描述"><a href="#输出描述" class="headerlink" title="输出描述:"></a><strong>输出描述:</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">左上角到右下角的最短路径，格式如样例所示。<br></code></pre></td></tr></table></figure><p><strong>示例1</strong></p><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="求解："><a href="#求解：" class="headerlink" title="求解："></a>求解：</h2><p><strong>第一步：</strong></p><blockquote><p>首先我们先把简单的输入做好，然后再专心写怎么去找。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步：</strong></p><blockquote><p>因为深度优先搜索(DFS)非常适用于找是否有解的题，正巧题目说了有且仅有一条通路，所以非常契合。</p><p>那DFS怎么实现呢？用栈这种数据结构呢？还是用递归——函数调用创建栈帧？ 为了精简就用递归吧。</p><p><strong>递归三要素：</strong></p><p>1、确定递归函数的参数和返回值</p><p>2、确定终止条件</p><p>3、确定单层递归逻辑</p></blockquote><p><strong>1、确定递归函数的参数和返回值</strong></p><p>首先我们肯定要<strong>传入这个二维矩阵</strong>，其次我们还要<strong>传入迷宫起点坐标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">DFS</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br></code></pre></td></tr></table></figure><blockquote><p>那要不要传迷宫的长宽呢？因为我们用了vector容器，可以通过调用接口函数，直接得出，因此不用</p></blockquote><p>最后我们确定返回值，因为我们<strong>只要求是否有解</strong>，<strong>如果有的话直接返回true, 没有的话返回false不就行啦，所以返回值定位bool</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>2、确定终止条件</strong></p><p>显然<strong>走到出口就停止</strong>呗。即坐标(N - 1, M - 1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>3、确定单层递归逻辑</strong></p><p>首先我们在迷宫中不知道哪里能走，因此只能“摸黑走”，随便走，但<strong>总要规定一个顺序</strong>，我们这里<strong>假设就用上下左右</strong>的顺序去“走迷宫”。</p><p>但是，我们总不能是墙也走吧，或者走出迷宫边界，因此我们还要<strong>判定是否能向那一个方向走。</strong></p><p>写一个函数用来判断能不能走isPass</p><p><strong>首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳。</span><br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>    <br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>至此，我们整个递归的逻辑已经写完了。但是这道题需要让你输出从起点到终点的路径坐标。</p><p>如果我们走到一个死胡同，此时我们记录了这个死胡同的所有坐标，这不是我们想要的，因此我们要删除这些坐标。仔细思考，会发现，我们<strong>所需要删除的是所有后面来的坐标</strong>，这不就是<strong>后进先出</strong>嘛，所以我们就想到了用栈来记录。</p><p>因为<strong>坐标是两个整形的组合</strong>，类似一个结构体，我们可以<strong>用pair来记录坐标</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br></code></pre></td></tr></table></figure><p>至此，我们能记录出所有坐标辣，但是<strong>坐标顺序是反的</strong>。<strong>因此还要借助一个栈来辅助逆置</strong>。最后输出这个辅助栈就ok了</p><h2 id="最终代码："><a href="#最终代码：" class="headerlink" title="最终代码："></a>最终代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, y));<br><br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">//归的过程</span><br><span class="hljs-comment">//因为走不通，返回false，并且要输出错误路的坐标</span><br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>(maze, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; help_st;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>help_st.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">while</span> (!help_st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>help_st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二届程序设计大赛</title>
    <link href="/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"/>
    <url>/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="1-闰年"><a href="#1-闰年" class="headerlink" title="1.闰年"></a><strong>1.闰年</strong></h2><p>问题描述</p><p>给定一个年份，判断这一年是不是闰年。当以下情况之一满足时，这一年是闰年：</p><ol><li>年份是4的倍数而不是100的倍数；</li><li>年份是400的倍数。<br>其他的年份都不是闰年。</li></ol><p><strong>输入格式</strong><br>输入包含一个整数y，表示当前的年份。</p><p><strong>输出格式</strong><br>输出一行，如果给定的年份是闰年，则输出yes，否则输出no。</p><p>说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。</p><p><strong>思路：</strong></p><p>按照题目描述输出即可。**<u>四年一润且百年不润 或 四百年一润</u>**</p><p>因此可以得出这样的表达式：</p><p><strong>(year % 4 &#x3D;&#x3D; 0 &amp;&amp; year % 100 !&#x3D; 0) || (year % 400 &#x3D;&#x3D; 0)</strong></p><p>之后结合if语句判断即可~</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;year);<br>    <br>    <span class="hljs-comment">//如果表达式为真，则执行输出yes</span><br>    <span class="hljs-keyword">if</span>((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-找素数"><a href="#2-找素数" class="headerlink" title="2.找素数"></a><strong>2.找素数</strong></h2><p>输入一个正整数n，计算输出小于n的最大素数</p><p><strong>思路：</strong></p><p>抓住核心：<strong>小于n，最大，素数</strong></p><p><u><strong>1.分析素数：大于1，只能被1和自身整除</strong></u></p><p><u><strong>2.循环找出大于1，小于n的数</strong></u></p><p><u><strong>3.检查循环所枚举出来的数是否为素数</strong></u></p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//检查它是不是素数,如果是则返回1，不是返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br><span class="hljs-comment">//循环2 - num-1 之间的数，看是否能被num整除，能整除则说明不是</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= num - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (num % j == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br><span class="hljs-comment">//先得到小于n的数</span><br><br><span class="hljs-comment">//因为要最大，所以从后往前找</span><br><span class="hljs-comment">//但是因为要得到素数，而最小的素数是2，所以循环到2就行</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">2</span>; i--)<br>&#123;<br><span class="hljs-comment">//判断是否为素数</span><br><span class="hljs-keyword">if</span> (is_Prime(i) == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//如果当前数为素数，则一定是小于n的最大素数了</span><br>            <span class="hljs-comment">//中止循环即可~</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-爬楼梯"><a href="#6-爬楼梯" class="headerlink" title="6.爬楼梯"></a><strong>6.爬楼梯</strong></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><p>由于<strong>每次只能爬一个台阶或者两个台阶</strong>，因此<strong>第n阶台阶只能由第n-1阶台阶和n-2阶台阶到达</strong>。</p><p>所以我们<strong>只要知道</strong>了爬到n-1阶台阶有多少中走法和n-2阶台阶有多少种走法，<strong>就能得到</strong>爬到n阶台阶有多少种走法。</p><p>现用函数的形式表示n阶台阶的不同方法数：</p><p>f(n) &#x3D; f(n - 1) + f(n - 2)。</p><p>f(n - 1) &#x3D; f(n - 1 - 1) +f(n - 1 - 2)</p><p>f(n - 2) &#x3D; f(n - 2 - 1) + f(n - 2 - 2)</p><p>……</p><p>我们会发现，每次操作都差不多，因此我们可以用<strong>递归解决问题</strong>(循环当然也可以)。</p><p>但有<strong>两个特例</strong>：</p><p>f(1) &#x3D; 1</p><p>f(2) &#x3D; 2</p><p>因为用上面的公式不符合，哪有走0阶台阶的- - </p><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> fun(n - <span class="hljs-number">1</span>) + fun(n - <span class="hljs-number">2</span>);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, fun(n));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-逆序对"><a href="#7-逆序对" class="headerlink" title="7.逆序对"></a><strong>7.逆序对</strong></h2><p><code>逆序对</code></p><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。<br>如 <code>2 4 3 1 </code>中，<code> 2 1</code> ，<code>4 3</code> ，<code>4 1</code>，<code>3 1</code>是逆序，逆序数是 4 。给出一个整数序列，求该序列的逆序数。</p><p><strong>输入</strong></p><p>第 1 行： $N$ ， $N$为序列的长度（ $N≤10000$ ）<br>第 2∼N+1 行：序列中的元素（$ 1≤A[i]≤10000 $）</p><p><strong>输出</strong></p><p>输出逆序数</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>2<br>4<br>3<br>1<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>抓住最重要的，<strong>前面的数大于后面的数</strong>！</p><p>所以只要<strong>两个循环</strong>就可以解决了！</p><p><strong>外循环</strong>：固定当前等待比较的数</p><p><strong>内循环</strong>：去当前等待比较的数后面寻找有没有它还大的数</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <br>    <span class="hljs-comment">//创建数组存放这些数</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">100001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//读取这些数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">//用来计数</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//外循环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//内循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; Nl j++)<br>        &#123;<br>            <span class="hljs-comment">//开始判断,是否前面大于后面</span><br>            <span class="hljs-keyword">if</span>(arr[i] &gt; arr[j])<br>        count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-宫殿距离"><a href="#9-宫殿距离" class="headerlink" title="9.宫殿距离"></a>9.宫殿距离</h2><p><code>搜索</code></p><p>nxn的格子宫殿，包含一个起始点<code>#</code>，一个终止点<code>$</code>，其它点为<code>.</code></p><p><strong>输入</strong></p><p>第 1 行，一个数n，中间用空格隔开。 ($2≤n≤1000$)</p><p>第 2~n+1行，每行n个字符。</p><p><strong>输出</strong></p><p>输出起点到终点的最短距离，距离只能从一个方格通过上下左右的方式走到与之相邻的方格，每个方格代表的距离为1。</p><p>距离不包含起始位置，包含终止位置。</p><p><strong>输入样例</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5<br><span class="hljs-code">.....</span><br><span class="hljs-code">.#...</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">....$</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>别看这题在后面，其实装的，吓人的</p><p><strong>不就是计算两点之间的距离嘛，只是不能斜着走</strong></p><p>只要在读入迷宫的时候，记下#、$的位置就行了</p><p>C语言的难度对于本体在于如何读取这个迷宫，需要注意缓存区中的换行符。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//存放迷宫</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br><span class="hljs-comment">//用来记录#的位置</span><br><span class="hljs-type">int</span> s_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> s_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//用来记录$的位置</span><br><span class="hljs-type">int</span> e_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> e_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//读入迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;arr[i][j]);<br><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>&#123;<br>s_i = i;<br>s_j = j;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;$&#x27;</span>)<br>&#123;<br>e_i = i;<br>e_j = j;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br>&#125;<br><br><span class="hljs-comment">//abs函数是用来取绝对值的</span><br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">abs</span>(s_i - e_i) + <span class="hljs-built_in">abs</span>(s_j - e_j);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-数列求值"><a href="#4-数列求值" class="headerlink" title="4.数列求值"></a><strong>4.数列求值</strong></h2><p>给定数列1,1,1,3,5,9,17,…，从第4项开始，每项都是前3项的和。求第20190324项的最后4位数字。</p><h3 id="思路："><a href="#思路：" class="headerlink" title="思路："></a><strong>思路：</strong></h3><p>斐波那契数列的改版：因此依葫芦画瓢，使用递归来写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> Fib(n - <span class="hljs-number">1</span>) + Fib(n - <span class="hljs-number">2</span>) + Fib(n - <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是因为递归的太深，所以需要求解的时间很长，因此在比赛中肯定是不能过得，因此我们要考虑用空间换时间。</p><hr><p>利用一个数组存储前n项的和，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>arr[n] = arr[n - <span class="hljs-number">1</span>] + arr[n - <span class="hljs-number">2</span>] + arr[n - <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p><strong>但是</strong>！对于这道题依旧行不通，<u><strong>因为他要让你存储第20190324个数，需要巨大的空间</strong></u>，在main函数中创建这个数组，程序会崩溃。但你可以**<u>将这个数组写在main函数外，写成全局变量数组。</u>**</p><p><strong>但是！</strong>就算你开辟了这个很大的数组，你依旧过不了这题，因为当你傻乎乎的求解时，<em><strong>斐波那契数列的增长很快</strong></em>，不一会就会超出整形的范围，就会得到意想不到的数。不过这题给你了提示，<strong>让你求最后4位数，所以你每次只要关注当前数的后4位</strong>。</p><p><strong>补充：</strong>要得到一个数的后i位，就要对这个数取模% 10 ^ i </p><h3 id="最终代码如下："><a href="#最终代码如下：" class="headerlink" title="最终代码如下："></a>最终代码如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯模拟题</title>
    <link href="/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/"/>
    <url>/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><p><strong>问题描述</strong><br>　　请找到一个大于 2022 的最小数，这个数转换成十六进制之后，所有的数位（不含前导 0）都为字母（A 到 F）。<br>　　请将这个数的十进制形式作为答案提交。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><hr><p><strong>方法一：</strong></p><blockquote><p>2022 转十六进制 7E6</p><p>这是一道填空题，最笨的方法，拿着计算器一个一个数出来，看哪一个数最先为AAA。</p></blockquote><p><strong>方法二：</strong></p><blockquote><p>通过编程来找。</p><p><strong>思路</strong>：循环2022以后的数，看哪一个最先 转为十六进制后就全为字母</p><p>如何一个十进制数转为十六进制呢？</p><p>使用短除法~</p><p>如：2022 % 16 &#x3D; 6， 2022 &#x2F; 16 &#x3D;  126</p><p>​126 % 16 &#x3D; E(14),  126 &#x2F; 16 &#x3D; 7</p><p>​7 % 16 &#x3D; 7,  7 &#x2F; 16 &#x3D; 0</p><p>最后将取模的数从下当上写出来， 所以 2022转为十六进制就为7E6了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Full</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-comment">//如果满足每一位都是字母那就返回1，否则返回0</span><br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//检查每一位是否为字母，如果为数字直接结束</span><br><span class="hljs-type">int</span> tmp = n % <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; <span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>n /= <span class="hljs-number">16</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2023</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (is_Full(n))<br>&#123;<br><span class="hljs-comment">//一旦找到某一个满足全是字母的数，直接结束</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>n++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p><strong>问题描述</strong><br>　　在 Excel 中，列的名称使用英文字母的组合。前 26 列用一个字母，依次为 A 到 Z，接下来 26*26 列使用两个字母的组合，依次为 AA 到 ZZ。<br>　　请问第 2022 列的名称是什么？<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个由大写字母组成的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。</p><blockquote><p>介不就一道二十六进制的题。</p><p>满Z就进位A。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2022</span>;<br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//%c打印字符，即后面可以跟一个数字，然后会输出相应ASCII值的字符</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, n % <span class="hljs-number">26</span> + (<span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">1</span>));<br>n /= <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为TYB，需要将结果反过来即BYT，因为每次都是先得到个位再十位……</p><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p><strong>问题描述</strong><br>　　对于一个日期，我们可以计算出年份的各个数位上的数字之和，也可以分别计算月和日的各位数字之和。请问从 1900 年 1 月 1 日至 9999 年 12 月 31 日，总共有多少天，年份的数位数字之和等于月的数位数字之和加日的数位数字之和。<br>　　例如，2022年11月13日满足要求，因为 2+0+2+2&#x3D;(1+1)+(1+3) 。<br>　　请提交满足条件的日期的总数量。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>这题就老老实实的编程算了~不然得数到结束</p><p>技巧：我们可以创建一个月份数组，存入每个对应的天数</p><p>思路：枚举每个日期，看是否满足咯，记得要判断是否为闰年</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_LeapYear</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//得到每位之和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (year)<br>&#123;<br>ans += year % <span class="hljs-number">10</span>;<br>year /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> month[<span class="hljs-number">13</span>] = &#123; <span class="hljs-number">0</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<br><span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br><span class="hljs-comment">//用来计数，得到结果</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1900</span>; i &lt;= <span class="hljs-number">9999</span>; i++)<br>&#123;<br><span class="hljs-comment">//先判断这年是不是闰年</span><br>month[<span class="hljs-number">2</span>] = is_LeapYear(i) ? <span class="hljs-number">29</span> : <span class="hljs-number">28</span>;<br><br><span class="hljs-comment">//得到这年上的数字之和</span><br><span class="hljs-type">int</span> year = getSum(i);<br><br><span class="hljs-comment">//得到月和日的数字之和</span><br><span class="hljs-type">int</span> Mon_Day = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">12</span>; j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= month[j]; k++)<br>&#123;<br><span class="hljs-comment">//计算月份和日每位数字之和~</span><br><span class="hljs-type">int</span> tmp = getSum(j) + getSum(k);<br><span class="hljs-keyword">if</span> (tmp == year)<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h1><p>问题描述<br>小蓝有 30 个数，分别为：99, 22, 51, 63, 72, 61, 20, 88, 40, 21, 63, 30, 11, 18, 99, 12, 93, 16, 7, 53, 64, 9, 28, 84, 34, 96, 52, 82, 51, 77 。<br>小蓝可以在这些数中取出两个序号不同的数，共有 30*29&#x2F;2&#x3D;435 种取法。<br>请问这 435 种取法中，有多少种取法取出的两个数的乘积大于等于 2022 。</p><p>答案提交<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>水题哦。直接上代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">99</span>, <span class="hljs-number">22</span>, <span class="hljs-number">51</span>, <span class="hljs-number">63</span>, <span class="hljs-number">72</span>, <span class="hljs-number">61</span>, <span class="hljs-number">20</span>,<br>     <span class="hljs-number">88</span>, <span class="hljs-number">40</span>, <span class="hljs-number">21</span>, <span class="hljs-number">63</span>, <span class="hljs-number">30</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">99</span>, <span class="hljs-number">12</span>,<br>      <span class="hljs-number">93</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">9</span>, <span class="hljs-number">28</span>, <span class="hljs-number">84</span>, <span class="hljs-number">34</span>, <br>      <span class="hljs-number">96</span>, <span class="hljs-number">52</span>, <span class="hljs-number">82</span>, <span class="hljs-number">51</span>, <span class="hljs-number">77</span>&#125;;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">30</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]*a[j]&gt;=<span class="hljs-number">2022</span>)<br>            &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><hr><h1 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h1><p><strong>问题描述</strong><br>　　给定一天是一周中的哪天，请问 n 天后是一周中的哪天？<br><strong>输入格式</strong><br>　　输入第一行包含一个整数 w，表示给定的天是一周中的哪天，w 为 1 到 6 分别表示周一到周六，w 为 7 表示周日。<br>　　第二行包含一个整数 n。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示 n 天后是一周中的哪天，1 到 6 分别表示周一到周六，7 表示周日。<br><strong>样例输入</strong><br>6<br>10<br><strong>样例输出</strong><br>2<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;&#x3D; n &lt;&#x3D; 1000000。</p><blockquote><p>思路：给定一个整数w表明是周几，那不就是第几天嘛。让你算n天之后，只需要(w + n) % 7</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;w, &amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (w + n) % <span class="hljs-number">7</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="第七题"><a href="#第七题" class="headerlink" title="第七题"></a>第七题</h1><p><strong>问题描述</strong><br>　　小蓝负责一块区域的信号塔安装，整块区域是一个长方形区域，建立坐标轴后，西南角坐标为 (0, 0)， 东南角坐标为 (W, 0)， 西北角坐标为 (0, H)， 东北角坐标为 (W, H)。其中 W, H 都是整数。<br>　　他在 n 个位置设置了信号塔，每个信号塔可以覆盖以自己为圆心，半径为 R 的圆形（包括边缘）。<br>　　为了对信号覆盖的情况进行检查，小蓝打算在区域内的所有横纵坐标为整数的点进行测试，检查信号状态。其中横坐标范围为 0 到 W，纵坐标范围为 0 到 H，总共测试 (W+1) * (H+1) 个点。<br>　　给定信号塔的位置，请问这 (W+1)*(H+1) 个点中有多少个点被信号覆盖。<br><strong>输入格式</strong><br>　　输入第一行包含四个整数 W, H, n, R，相邻整数之间使用一个空格分隔。<br>　　接下来 n 行，每行包含两个整数 x, y，表示一个信号塔的坐标。信号塔可能重合，表示两个信号发射器装在了同一个位置。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示答案。<br><strong>样例输入</strong><br>10 10 2 5<br>0 0<br>7 0<br><strong>样例输出</strong><br>57<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;&#x3D; W, H &lt;&#x3D; 100，1 &lt;&#x3D; n &lt;&#x3D; 100, 1 &lt;&#x3D; R &lt;&#x3D; 100, 0 &lt;&#x3D; x &lt;&#x3D; W, 0 &lt;&#x3D; y &lt;&#x3D; H。</p><blockquote><p>题目挺长的，但是细读会发现也就那样。</p><p>思路：</p><p>创建一个二维数组全部初始化为0，然后对每一个信号塔进行预处理，将这个点到信号塔的距离算出来(x - a)^2 + (y - b)^2.如果在信号塔的范围内</p><p>就将其对应二维数组的值改为1。最后再统计1的个数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> W, H, n, R;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;W, &amp;H, &amp;n, &amp;R);<br><span class="hljs-comment">//创建一个二维数组</span><br><span class="hljs-comment">//因为不知道支不支持边长数组，就将数组开到最大</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//对于每个信号塔进行预处理</span><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br><br><span class="hljs-comment">//这里是&lt;=哦~</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= H; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= W; j++)<br>&#123;<br><span class="hljs-comment">//两点距离公式</span><br><span class="hljs-comment">//一个点的坐标:(j,i)</span><br><span class="hljs-comment">//信号塔坐标:  (y,x)</span><br><span class="hljs-keyword">if</span> ((x - i) * (x - i) + (y - j) * (y - j) &lt;= (R * R))<br>&#123;<br><span class="hljs-comment">//懒得再遍历一遍数组了，直接记录下有多少个1不就完事了~</span><br><span class="hljs-comment">//注意！如果被两个信号塔覆盖，应该只能算1次</span><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-number">0</span>)<br>count++;<br><br>arr[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h1><p><strong>问题描述</strong><br>　　小蓝有一个 n * m 大小的矩形水域，小蓝将这个水域划分为 n 行 m 列，行数从 1 到 n 标号，列数从 1 到 m 标号。每行和每列的宽度都是单位 1 。<br>　　现在，这个水域长满了水草，小蓝要清理水草。<br>　　每次，小蓝可以清理一块矩形的区域，从第 r1 行（含）到第 r2 行（含）的第 c1 列（含）到 c2 列（含）。<br>　　经过一段时间清理后，请问还有多少地方没有被清理过。<br><strong>输入格式</strong><br>　　输入第一行包含两个整数 n, m，用一个空格分隔。<br>　　第二行包含一个整数 t ，表示清理的次数。<br>　　接下来 t 行，每行四个整数 r1, c1, r2, c2，相邻整数之间用一个空格分隔，表示一次清理。请注意输入的顺序。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示没有被清理过的面积。<br><strong>样例输入</strong><br>2 3<br>2<br>1 1 1 3<br>1 2 2 2<br><strong>样例输出</strong><br>2<br><strong>样例输入</strong><br>30 20<br>2<br>5 5 10 15<br>6 7 15 9<br><strong>样例输出</strong><br>519<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;&#x3D; r1 &lt;&#x3D; r2 &lt;&#x3D; n &lt;&#x3D; 100, 1 &lt;&#x3D; c1 &lt;&#x3D; c2 &lt;&#x3D; m &lt;&#x3D; 100, 0 &lt;&#x3D; t &lt;&#x3D; 100。</p><blockquote><p>感觉水题一样的，跟上题差不多思路，依旧是创建一个二维数组，去找里面有多少个0——代表没被清理过的地方。</p><p>搞懂上题这题打个哈哈就过~</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n, m, t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;t);<br>    <span class="hljs-type">int</span> r1, c1, r2, c2;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);<br>        <span class="hljs-keyword">for</span> (i = r1; i &lt;= r2; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (j = c1; j &lt;= c2; j++)<br>            &#123;<br>                a[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
