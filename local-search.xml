<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>消息队列</title>
    <link href="/2024/03/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    <url>/2024/03/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>项目简介</h1><p>本项目参照RabbitMQ简单模拟实现了一个消息队列。该消息队列提供了虚拟主机、交换机、队列、消息等核心概念，并实现了交换机转发消息的三种模式，旨在实现跨主机/服务器的生产者消费者模型。</p><p>知识点：网络编程、网络通信、RPC通信、IO流、序列化、并发编程、SpringBoot、SQLite</p><h1>消息队列</h1><p>消息队列本质上就是一个队列，只是在队列这种数据结构的基础上提供了更加丰富的功能，为的是实现生产者消费者模型。</p><p>生产者消费者模型的好处：</p><p><strong>1.解耦合</strong></p><p>当模块A与模块B进行通信的时候，势必要在模块A中添加与模块B通信的代码，当继续添加一个模块C通信的话，那又要在模块A中添加一段代码，此时模块A和模块B、模块C的耦合度很高，如果后续要修改，那么这些模块都需要进行改动代码，并且如果模块A挂了，其他模块立刻就能感知到。</p><p>考虑使用生产者消费者模型。此处模块A为生产者，负责生产数据，模块B、模块C为消费者，负责消费模块A产生的数据。引入一个消息队列，即生产者生产的数据先发送到消息队列，其他消费者直接从消息队列中取数据消费即可。如果再添加一个消费者的时候，生产者模块A不需要进行改动，直接让新的消费者添加订阅消息队列即可。这样就实现了解耦合，而且当模块A挂了，其他消费者也不会立马感知到，最多认为此时消费者还没生产数据。</p><img src="/2024/03/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20240319113617868.png" class title="image-20240319113617868"><img src="/2024/03/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20240319113936122.png" class title="image-20240319113936122"><p><strong>2.削峰</strong></p><p>在某一时刻，模块A接收到大量的请求，交给模块B去处理，如果两个模块都是比较轻量的程序可以还可以正常运行，但如果A是入口程序，B是数据库业务(数据库比较脆弱)，此时大量的请求就会讲给数据库处理，就很有可能导致数据库崩了。</p><p>假设引入消息队列，虽然有很多请求，但是模块A会先将请求放到消息队列中，模块B可以根据自己的节奏来从队列中取消息，这样就削弱请求的峰值(对模块B)，保证程序的正常运行。</p><img src="/2024/03/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20240319144648580.png" class title="image-20240319144648580"><h1>需求分析</h1><h2 id="核心概念">核心概念</h2><p>**虚拟主机：**类似数据库中database，用来隔离交换机、队列、消息。</p><p>**交换机：**实现消息的转发。</p><p>**队列：**用来存储消息。</p><p>**绑定：**用来表示交换机和队列之间的关系。一个交换机可以关联多个队列，一个队列也可以关联多个交换机。</p><p>**消息：**用户自己发送的业务数据。</p><img src="/2024/03/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20240319145825675.png" class title="image-20240319145825675"><h2 id="消息队列服务器">消息队列服务器</h2><p>消息队列服务器要做的事就是根据用户的请求来创建交换机、队列、绑定，发送消息，返回消息。</p><p><strong>消息服务器的核心API：</strong></p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>exchangeDeclare</td><td>在服务器上创建交换机，如果存在就不创建</td></tr><tr><td>exchangeDelete</td><td>销毁服务器上的交换机</td></tr><tr><td>queueDeclare</td><td>在服务器上创建队列，如果存在就不创建</td></tr><tr><td>queueDelete</td><td>销毁服务器上的队列</td></tr><tr><td>queueBind</td><td>在服务器上创建绑定关系</td></tr><tr><td>queueUnbind</td><td>销毁服务器上的绑定关系</td></tr><tr><td>basicPublish</td><td>发布消息</td></tr><tr><td>basicConsume</td><td>订阅消息</td></tr><tr><td>basicAck</td><td>确认消息.当消费者从服务器上消费完了消息可以显示的告诉服务器，以此保证可靠性</td></tr></tbody></table><p>消费一个消息有两种方式：pull(拉)，push(推).如果需要支持pull的方式，需要再提供一个API，用来手动的获取消息。但是在RabbitMQ</p><p>中只支持push推的方式，即消费者订阅了某个队列，服务器会自动的将消息推送给消费者。</p><h2 id="消息队列客户端">消息队列客户端</h2><p>在客户端中也要提供上述的API，虽然名字一样，但代码时完全不同的。当用户调用创建队列的API，此时用户这边就会发起一个网络请求，服务器接收到了这个请求并解析，计算响应，最后将响应返回给客户端，此处所创建的交换机存在于服务器的内存中，而客户端只是完成了一个发送请求，没有真实的创建交换机。而这种交互方式也称作是RPC(远程过程调用协议)。</p><p>除了上述这些API，在客户端这边还有一组特别的API。</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>创建connection</td><td>与服务器进行TCP连接</td></tr><tr><td>关闭connection</td><td>关闭服务器的连接</td></tr><tr><td>创建channel</td><td>创建一个信道channel，即与服务器创建逻辑连接</td></tr><tr><td>关闭channel</td><td>关闭信道channel，即与服务器断开逻辑上的连接</td></tr></tbody></table><p>在客户端与服务器交互的过程中，客户端是通过channel与服务器进行逻辑上的连接/断开。创建一个connection，本质上就是与服务器进行TCP通信，而创建一个channel就是复用这个connection，进行逻辑上的通信，即虽然使用channel中的API发送请求，但本质上还是通过connection中的socket发送请求到服务器中。而服务器也无法区分channel，将返回的响应交给connection，再根据某种规则，将响应返回给对应的channel。</p><p>复用TCP连接，是为了提高通信的效率。</p><h2 id="公共模块">公共模块</h2><p>公共模块所要进行的规定一些网络通信中的参数，对数据进行序列化，以便数据的传输。一个对象实例要想在网络中传输，需要将这个对象进行转换，如转成json格式进行传输或者通过二进制传输；将一个对象存储在硬盘中，也要对对象进行转换。</p><h2 id="持久化模块">持久化模块</h2><p>为了防止服务器重启，依旧能恢复到上次的操作，需要对数据进行持久化，服务器可以根据用户指定的参数，是否进行持久化的操作。</p><p>对数据进行持久化可以存储到两个位置：1.文件上   2.数据库</p><p>由于虚拟主机、交换机、队列、绑定这些数据会经常进行crud，因此我们可以将这些数据存储在数据库中。</p><p>对于消息，可能会比较大，而且也不会对消息进行频繁crud，我们可以存储在文件中。</p><img src="/2024/03/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20240319154910084.png" class title="image-20240319154910084"><h1>模拟实现</h1><h2 id="创建核心类">创建核心类</h2><p>首先创建如下包。</p><img src="/2024/03/16/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/image-20240319172959669.png" class title="image-20240319172959669"><p>由于交换机、队列、绑定、消息这些对象都是在服务器上操作的，客户端上都不会涉及到，因此就在mqserver中创exchange、queue、binding、message类。</p><p><strong>Exchange：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Exchange</span> &#123;<br>    <span class="hljs-comment">//标识交换机</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//交换机的类型</span><br>    <span class="hljs-comment">//默认为直接交换机</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ExchangeType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> ExchangeType.DIRECT;<br>    <span class="hljs-comment">//是否可持久化,即要不要存在硬盘上</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">durable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//是否自动删除</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">autoDelete</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//可选参数</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p>交换机的类型有好多种，在这我们只实现3种交换机：direct、fanout、topic。</p><p><strong>ExchangeType：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ExchangeType</span> &#123;<br>    DIRECT(<span class="hljs-number">0</span>),<br>    FANOUT(<span class="hljs-number">1</span>),<br>    TOPIC(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> type;<br><br>    ExchangeType(<span class="hljs-type">int</span> type) &#123;<br>        <span class="hljs-built_in">this</span>.type = type;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MSGQueue：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-comment">//为了与标准库中Queue区分，这里改叫MSGQueue</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MSGQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-comment">//是否独占(只能被一个消费者使用)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">exclusive</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//是否可持久化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">durable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//是否自动删除</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">autoDelete</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//可选参数</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; arguments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Binding：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Binding</span> &#123;<br>    <span class="hljs-keyword">private</span> String exchangeName;<br>    <span class="hljs-keyword">private</span> String queueName;<br>    <span class="hljs-comment">//用于Topic交换机,跟Message中routingKey进行匹配</span><br>    <span class="hljs-keyword">private</span> String bindingKey;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Message：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Message</span> &#123;<br>    <span class="hljs-comment">//消息的基本属性</span><br>    <span class="hljs-keyword">private</span> BasicProperties basicProperties;<br>    <span class="hljs-comment">//存储数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] body;<br>    <span class="hljs-comment">//位置偏移量,便于在文件中取出数据</span><br>    <span class="hljs-comment">//采用[offsetBeg, offsetEnd)区间</span><br>    <span class="hljs-comment">//这两个属性是帮助从文件中读取数据的,不需要进行序列化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> offsetBeg;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> offsetEnd;<br>    <span class="hljs-comment">//表示此消息在文件中是否有效(采用逻辑删除)</span><br>    <span class="hljs-comment">//0x00 表示无效， 0x01 表示有效</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span> <span class="hljs-variable">isValid</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x01</span>;<br><br>    <span class="hljs-comment">//通过一个&quot;工厂方法&quot;来创建message对象,随机生成Id</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Message <span class="hljs-title function_">createMessageWithId</span><span class="hljs-params">(BasicProperties basicProperties, String routingKey, <span class="hljs-type">byte</span>[] body)</span>&#123;<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>();<br>        <span class="hljs-keyword">if</span>(basicProperties != <span class="hljs-literal">null</span>)&#123;<br>            message.setBasicProperties(basicProperties);<br>        &#125;<br>        message.getBasicProperties().setMessageId(<span class="hljs-string">&quot;M_&quot;</span> + UUID.randomUUID().toString());<br>        message.getBasicProperties().setRoutingKey(routingKey);<br>        message.setBody(body);<br>        <span class="hljs-comment">//此处 offsetBeg,offsetEnd,isValid 作用在持久化操作</span><br>        <span class="hljs-comment">//当进行持久化时,才需要赋值</span><br>        <span class="hljs-keyword">return</span> message;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getMessageId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.basicProperties.getMessageId();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setMessageId</span><span class="hljs-params">(String messageId)</span> &#123;<br>        <span class="hljs-built_in">this</span>.basicProperties.setMessageId(messageId);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getRoutingKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.basicProperties.getRoutingKey();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRoutingKey</span><span class="hljs-params">(String routingKey)</span> &#123;<br>        <span class="hljs-built_in">this</span>.basicProperties.setRoutingKey(routingKey);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDurable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.basicProperties.isDurable();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDurable</span><span class="hljs-params">(<span class="hljs-type">boolean</span> durable)</span> &#123;<br>        <span class="hljs-built_in">this</span>.basicProperties.setDurable(durable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在传输消息的时候，都是通过二进制来传输，所以消息本质上就是一个byte[]，其他都是辅助字段。</strong></p><p><strong>offsetBeg、offsetEnd、isValid字段是用来描述这个消息在文件中是如何存储的，以及该消息是否已经被删除了。</strong></p><p><strong>由于在文件中使用类似数组中的删除元素的操作会大大增加我们程序的运行时间，在此我们选择采用逻辑删除的方式，即通过一个标记字段来表示是否删除。</strong></p><p><strong>BasicProperties：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicProperties</span> &#123;<br>    <span class="hljs-comment">//为防止重复，使用UUID生成</span><br>    <span class="hljs-keyword">private</span> String MessageId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">isDurable</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//口令</span><br>    <span class="hljs-keyword">private</span> String routingKey;<br>&#125;<br></code></pre></td></tr></table></figure><p>后续的操作都是围绕这几个核心概念来增删改查的。</p><h2 id="数据库管理">数据库管理</h2><p>由于MySQL数据库比较重量，在此就选择使用相对轻量的数据库SQLite. MySQL是客户端服务器结构的程序，而SQLite是一个本地的数据库，操作它相当于是直接操作本地文件。</p><p>在Java中使用SQLite，也不需要额外的安装，可以直接使用maven，将相关依赖引入，然后进行配置就可以正常使用了。</p><p><strong>SQLite的依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.xerial/sqlite-jdbc --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xerial<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>sqlite-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.42.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>application.yml：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:sqlite:./data/meta.db</span><br>    <span class="hljs-attr">username:</span><br>    <span class="hljs-attr">password:</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">org.sqlite.JDBC</span><br></code></pre></td></tr></table></figure><p>SQLite是把数据存储在当前硬盘的某个指定文件中，在这里就存储在了工作路径的data目录中的meta.db文件了。</p><p>SQLite也不需要指定用户名和密码，毕竟是自己一个人用的，只有本地主机才能使用。</p><p>接下来就是建库和建表。在MySQL中，需要自己手动进行创建database，但在SQLite中，则无需手动建库了，每一个数据库文件就是一个数据库，即当前的meta.db文件就相当于是MySQL中的database。</p><p>为了能够即用即创建表，在这考虑部署的时候就自动创建表，即通过mybatis的update注解来建表并添加一些基础的查询、增加、删除操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MetaMapper</span> &#123;<br>    <span class="hljs-comment">//建表操作</span><br>    <span class="hljs-meta">@Update(&quot;create table if not exists exchange(&quot; +</span><br><span class="hljs-meta">            &quot;name varchar(50) primary key,&quot; +</span><br><span class="hljs-meta">            &quot;type int,&quot; +</span><br><span class="hljs-meta">            &quot;durable boolean,&quot; +</span><br><span class="hljs-meta">            &quot;autoDelete boolean,&quot; +</span><br><span class="hljs-meta">            &quot;arguments varchar(1024))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createExchangeTable</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-meta">@Update(&quot;create table if not exists queue(&quot; +</span><br><span class="hljs-meta">            &quot;name varchar(50) primary key,&quot; +</span><br><span class="hljs-meta">            &quot;exclusive boolean,&quot; +</span><br><span class="hljs-meta">            &quot;durable boolean,&quot; +</span><br><span class="hljs-meta">            &quot;autoDelete boolean,&quot; +</span><br><span class="hljs-meta">            &quot;arguments varchar(1024))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createQueueTable</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-meta">@Update(&quot;create table if not exists binding(&quot; +</span><br><span class="hljs-meta">            &quot;exchangeName varchar(50),&quot; +</span><br><span class="hljs-meta">            &quot;queueName varchar(50),&quot; +</span><br><span class="hljs-meta">            &quot;bindingKey varchar(256))&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createBindingTable</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-comment">//基础添加、删除、查询操作</span><br>    <span class="hljs-meta">@Insert(&quot;insert into exchange values(#&#123;name&#125;, #&#123;type&#125;, #&#123;durable&#125;, #&#123;autoDelete&#125;, #&#123;arguments&#125;)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertExchange</span><span class="hljs-params">(Exchange exchange)</span>;<br><br>    <span class="hljs-meta">@Delete(&quot;delete from exchange where name = #&#123;exchangeName&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteExchange</span><span class="hljs-params">(String exchangeName)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from exchange&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Exchange&gt; <span class="hljs-title function_">selectAllExchanges</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Insert(&quot;insert into queue values(#&#123;name&#125;, #&#123;exclusive&#125;, #&#123;durable&#125;, #&#123;autoDelete&#125;, #&#123;arguments&#125;)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertQueue</span><span class="hljs-params">(MSGQueue msgQueue)</span>;<br><br>    <span class="hljs-meta">@Delete(&quot;delete from queue where name = #&#123;queueName&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteQueue</span><span class="hljs-params">(String queueName)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from queue&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;MSGQueue&gt; <span class="hljs-title function_">selectAllQueues</span><span class="hljs-params">()</span>;<br><br>    <span class="hljs-meta">@Insert(&quot;insert into binding values(#&#123;exchangeName&#125;, #&#123;queueName&#125;, #&#123;bindingKey&#125;)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBinding</span><span class="hljs-params">(Binding binding)</span>;<br><br>    <span class="hljs-meta">@Delete(&quot;delete from binding where exchangeName = #&#123;exchangeName&#125; and queueName = #&#123;queueName&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBinding</span><span class="hljs-params">(String exchangeName, String queueName)</span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from binding&quot;)</span><br>    <span class="hljs-keyword">public</span> List&lt;Binding&gt; <span class="hljs-title function_">selectAllBindings</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于SQLite中也不支持HashMap这种数据结构，因此使用String来存储。</p><p>Mybatis在写入数据的时候，会自动的调用对象的getter方法，而在读出数据的时候，会自动调用setter方法，因此为了能够将arguments这个HashMap类型的数据存入到数据库中，我们需要转成字符串。</p><p>在此使用jackson来处理，引入相关依赖即可。</p><p><strong>jackson依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><strong>getter和setter：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getArguments</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        objectMapper.writeValueAsString(arguments);<br>    &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;&#125;&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setArguments</span><span class="hljs-params">(String arguments)</span> &#123;<br>    <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.arguments = objectMapper.readValue(arguments, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeReference</span>&lt;Map&lt;String, Object&gt;&gt;() &#123;&#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为了使程序的结构更加清晰，程序员更方便的操作数据库，考虑创建一个DataBaseManager类来封装数据库的相关操作。</p><p><strong>DataBaseManager：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//封装数据库操作</span><br><span class="hljs-comment">//DataBaseManager不交给Spring管理,由程序员手动管理</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DataBaseManager</span> &#123;<br>    <span class="hljs-comment">//从Spring上下文中手动获取MetaMapper的Bean</span><br>    <span class="hljs-keyword">private</span> MetaMapper metaMapper;<br><br>    <span class="hljs-comment">//带有业务逻辑的初始化操作</span><br>    <span class="hljs-comment">//完成建库建表操作</span><br>    <span class="hljs-comment">//如果不存在表就进行创建，并添加默认初始数据</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span>&#123;<br>        metaMapper = MqBlogApplication.context.getBean(MetaMapper.class);<br>        <span class="hljs-keyword">if</span>(!checkDBExists())&#123;<br>            <span class="hljs-comment">//创建data目录</span><br>            <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./data&quot;</span>);<br>            file.mkdirs();<br>            <span class="hljs-comment">//建表并初始化数据</span><br>            createTable();<br>            createDefaultData();<br>            log.info(<span class="hljs-string">&quot;[DataBaseManager] 数据库初始化完成&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            log.info(<span class="hljs-string">&quot;[DataBaseManager] 数据库已经初始化&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//删除数据库目录</span><br>    <span class="hljs-comment">//删除目录前,需要保证目录是空的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteDB</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./data/meta.db&quot;</span>);<br>        <span class="hljs-comment">//删除目录里面的文件</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> file.delete();<br>        <span class="hljs-keyword">if</span>(isSuccess)&#123;<br>            log.info(<span class="hljs-string">&quot;[DataBaseManager] 删除数据库文件成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            log.info(<span class="hljs-string">&quot;[DataBaseManager] 删除数据库文件失败&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//删除目录</span><br>        file = <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./data&quot;</span>);<br>        isSuccess = file.delete();<br>        <span class="hljs-keyword">if</span>(isSuccess)&#123;<br>            log.info(<span class="hljs-string">&quot;[DataBaseManager] 删除数据库目录成功&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;[DataBaseManager] 删除数据库目录失败&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">//判断数据库(meta.db)是否存在</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkDBExists</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">DBFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;./data/meta.db&quot;</span>);<br>        <span class="hljs-keyword">return</span> DBFile.exists();<br>    &#125;<br><br>    <span class="hljs-comment">//对 Exchange,Queue,Binding 进行建表</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createTable</span><span class="hljs-params">()</span> &#123;<br>        metaMapper.createExchangeTable();<br>        metaMapper.createQueueTable();<br>        metaMapper.createBindingTable();<br>        log.info(<span class="hljs-string">&quot;[DataBaseManager] 创建表完成&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//RabbitMQ初始带有一个匿名交换机, 类型为 Direct</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createDefaultData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Exchange</span> <span class="hljs-variable">exchange</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchange</span>();<br>        exchange.setName(<span class="hljs-string">&quot;&quot;</span>);<br>        exchange.setType(ExchangeType.DIRECT);<br>        exchange.setDurable(<span class="hljs-literal">true</span>);<br>        exchange.setAutoDelete(<span class="hljs-literal">false</span>);<br>        metaMapper.insertExchange(exchange);<br>        log.info(<span class="hljs-string">&quot;[DataBaseManager] 初始数据构造完成&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//增删查操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertExchange</span><span class="hljs-params">(Exchange exchange)</span>&#123;<br>        metaMapper.insertExchange(exchange);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteExchange</span><span class="hljs-params">(String exchangeName)</span>&#123;<br>        metaMapper.deleteExchange(exchangeName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Exchange&gt; <span class="hljs-title function_">selectAllExchanges</span><span class="hljs-params">()</span>&#123;<br>        List&lt;Exchange&gt; exchanges = metaMapper.selectAllExchanges();<br>        <span class="hljs-keyword">return</span> exchanges;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertQueue</span><span class="hljs-params">(MSGQueue queue)</span>&#123;<br>        metaMapper.insertQueue(queue);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteQueue</span><span class="hljs-params">(String queueName)</span>&#123;<br>        metaMapper.deleteQueue(queueName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;MSGQueue&gt; <span class="hljs-title function_">selectAllQueues</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> metaMapper.selectAllQueues();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insertBinding</span><span class="hljs-params">(Binding binding)</span>&#123;<br>        metaMapper.insertBinding(binding);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteBinding</span><span class="hljs-params">(String exchangeName, String queueName)</span>&#123;<br>        metaMapper.deleteBinding(exchangeName, queueName);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Binding&gt; <span class="hljs-title function_">selectAllBindings</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> metaMapper.selectAllBindings();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="文件管理">文件管理</h2><h2 id="封装硬盘">封装硬盘</h2><h2 id="内存管理">内存管理</h2><h2 id="虚拟主机">虚拟主机</h2><h2 id="服务器">服务器</h2>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java对象比较</title>
    <link href="/2024/02/22/Java%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83/"/>
    <url>/2024/02/22/Java%E5%AF%B9%E8%B1%A1%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>博客系统</title>
    <link href="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>前言</h1><p>前面使用了Servlet搭建了博客系统，使用的都是非常原生的API，导致开发起来比较复杂，但整体上完成了博客系统的一些核心功能。</p><p>本文将使用SSM框架(SpringBoot, SpringMVC, Mybatis)来搭建博客系统，并在原来的基础上进行功能升级，搭建一个更加安全、稳定、简洁的博客网站。</p><h1>功能介绍</h1><ol><li>用户登录</li><li>用户注册</li><li>用户信息修改页</li><li>博客列表页</li><li>博客详情页</li><li>博客修改页</li><li>博客发布页</li></ol><p>用户通过登录页面进行登录，登录成功后，跳转到博客列表页，可以根据相应的博客查看信息，如果是当前博客作者可以进行修改和删除操作。用户可以自己发表博客和修改自身个人信息。</p><p><strong>功能预览</strong></p><p>登录页面</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240214150948075.png" class title="image-20240214150948075"><p>博客列表页</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240214151159467.png" class title="image-20240214151159467"><p>博客详情页</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240214152518539.png" class title="image-20240214152518539"><p>发布博客页</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240214152622713.png" class title="image-20240214152622713"><p>博客修改页</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240214152842606.png" class title="image-20240214152842606"><p>用户信息修改页</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240214152553858.png" class title="image-20240214152553858"><h1>数据库创建</h1><p>通过分析，发现是一对多的关系，因此只需要建两张表——用户表和博客表，并在博客表中添加一个用户id字段。</p><p>为了能更好的了解数据的创建与修改，于是通常会在设计表的时候添加上ID、创建时间、更新时间三个字段。因为数据比较珍贵，为了不允许随便删除，在这里使用逻辑删除的方式，即在表中添加一个字段，表示是否删除。</p><p>用户表：id，user_name，password，github_url，avatar_path，delete_flag，create_time，update_time.</p><p>博客表：id，title，content，delete_flag，create_time，update_time，user_id.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 建表</span><br><span class="hljs-keyword">create</span> database if <span class="hljs-keyword">not</span> <span class="hljs-keyword">exists</span> java_blog_spring charset utf8mb4;<br><br><span class="hljs-comment">-- 选中数据库</span><br>use java_blog_spring;<br><br><span class="hljs-comment">-- 用户表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> java_blog_spring.user;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> java_blog_spring.user(<br>                                      `id` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>                                      `user_name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">128</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>                                      `password` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">128</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>                                      `github_url` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">128</span> ) <span class="hljs-keyword">NULL</span>,<br>                                      `avatar_path` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">255</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;/head/avatar.png&#x27;</span>,<br>                                      `delete_flag` TINYINT ( <span class="hljs-number">4</span> ) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,<br>                                      `create_time` DATETIME <span class="hljs-keyword">DEFAULT</span> now(),<br>                                      `update_time` DATETIME <span class="hljs-keyword">DEFAULT</span> now(),<br>                                      <span class="hljs-keyword">PRIMARY</span> KEY ( id ),<br>                                      <span class="hljs-keyword">UNIQUE</span> INDEX user_name_UNIQUE ( user_name <span class="hljs-keyword">ASC</span> ))<br>    ENGINE <span class="hljs-operator">=</span> INNODB<br>    <span class="hljs-keyword">DEFAULT</span> <span class="hljs-type">CHARACTER</span> <span class="hljs-keyword">SET</span> <span class="hljs-operator">=</span> utf8mb4 COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;用户表&#x27;</span>;<br><br><span class="hljs-comment">-- 博客表</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> java_blog_spring.blog;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> java_blog_spring.blog (<br>                                       `id` <span class="hljs-type">INT</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>                                       `title` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>) <span class="hljs-keyword">NULL</span>,<br>                                       `content` TEXT <span class="hljs-keyword">NULL</span>,<br>                                       `user_id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NULL</span>,<br>                                       `delete_flag` TINYINT(<span class="hljs-number">4</span>) <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-number">0</span>,<br>                                       `create_time` DATETIME <span class="hljs-keyword">DEFAULT</span> now(),<br>                                       `update_time` DATETIME <span class="hljs-keyword">DEFAULT</span> now(),<br>                                       <span class="hljs-keyword">PRIMARY</span> KEY (id))<br>    ENGINE <span class="hljs-operator">=</span> InnoDB<br>    <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8mb4 COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;博客表&#x27;</span>;<br><br></code></pre></td></tr></table></figure><h1>创建项目</h1><p>创建一个Spring项目，在pom.xml文件中添加相关依赖:spring web, lombok, mybatis。</p><p>在application.yml文件中进行mybatis的相关配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/java_blog_spring?characterEncoding=utf8&amp;useSSL=false</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <br><span class="hljs-comment">#mybatis配置</span><br><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-comment">#日志打印</span><br><span class="hljs-comment">#    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span><br>    <span class="hljs-comment">#蛇形自定转驼峰</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#配置 mybatis xml的文件路径，在resource/mapper创建所有表的xml文件</span><br><span class="hljs-comment">#  mapper-locations: classpath:mapper/**Mapper.xml</span><br><br><span class="hljs-comment">#设置日志文件</span><br><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">file:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">spring-blog.log</span><br></code></pre></td></tr></table></figure><h1>公共层编写</h1><p>程序的整体逻辑如下:</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240214164120611.png" class title="image-20240214164120611"><p>程序中出现相同的异常，我们可以交给spring的统一异常处理功能，并且为了返回数据格式的统一，方便前端处理相应数据，进行统一数据返回的处理。</p><h2 id="统一返回">统一返回</h2><p>针对返回数据，我们可以进行一下封装。定义三个属性：业务状态码、错误信息、返回数据。</p><p>当我们的业务状态码返回成功的时候，就返回响应的数据，当业务状态码返回失败的时候，将返回数据置空，并将响应的错误信息填写。</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240214165331855.png" class title="image-20240214165331855"><p>首先我们定义一个返回的实体类，通过上述分析，我们发现这里的业务状态码可以使用一个整数来表示，但为了增加代码的可读性，使用枚举来进行优化(也可以定义成常量)。当我们想创建一个返回类的时候，可以直接获取到响应的返回对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//业务状态码的枚举类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">ResultStatus</span> &#123;<br>    SUCCESS(<span class="hljs-number">200</span>),<br>    FAIL(-<span class="hljs-number">1</span>),<br><br>    <span class="hljs-keyword">private</span> Integer code;<br><br>    ResultStatus(Integer code) &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">getCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCode</span><span class="hljs-params">(Integer code)</span> &#123;<br>        <span class="hljs-built_in">this</span>.code = code;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Result</span> &#123;<br>    <span class="hljs-keyword">private</span> ResultStatus code; <span class="hljs-comment">//业务状态码</span><br>    <span class="hljs-keyword">private</span> String errorMessage; <span class="hljs-comment">//错误信息</span><br>    <span class="hljs-keyword">private</span> Object data; <span class="hljs-comment">//数据</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">success</span><span class="hljs-params">(Object data)</span>&#123;<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>        result.code = ResultStatus.SUCCESS;<br>        result.errorMessage = <span class="hljs-string">&quot;&quot;</span>;<br>        result.data = data;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Result <span class="hljs-title function_">fail</span><span class="hljs-params">(String errorMessage)</span>&#123;<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Result</span>();<br>        result.code = ResultStatus.FAIL;<br>        result.errorMessage = errorMessage;<br>        result.data = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样优化以后，当我返回的时候，就可以这样写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> Result.success(data);<br></code></pre></td></tr></table></figure><p>最后再进行统一数据的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResponseBodyAdvice</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(MethodParameter returnType, Class converterType)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">beforeBodyWrite</span><span class="hljs-params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> &#123;<br>        <span class="hljs-keyword">if</span>(body <span class="hljs-keyword">instanceof</span> Result)&#123;<br>            <span class="hljs-keyword">return</span> body;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(body <span class="hljs-keyword">instanceof</span> String)&#123;<br>            <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>            <span class="hljs-keyword">return</span> objectMapper.writeValueAsString(Result.success(body));<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Result.success(body);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="统一异常">统一异常</h2><p>统一异常就是对程序出现一样的异常的统一的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionAdvice</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">exceptionAdvice</span><span class="hljs-params">(Exception e)</span>&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(e.getMessage());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h1>业务代码</h1><p>在开发玩公共层的代码后，我们需要对数据库中的表进行具体描述成对象。</p><p>User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String avatarPath;<br>    <span class="hljs-keyword">private</span> String githubUrl;<br>    <span class="hljs-keyword">private</span> Integer deleteFlag;<br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-keyword">private</span> Date updateTime;<br>&#125;<br></code></pre></td></tr></table></figure><p>Blog：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span> &#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String title;<br>    <span class="hljs-keyword">private</span> String content;<br>    <span class="hljs-keyword">private</span> Integer userId;<br>    <span class="hljs-keyword">private</span> Integer deleteFlag;<br>    <span class="hljs-keyword">private</span> Date createTime;<br>    <span class="hljs-keyword">private</span> Date updateTime;<br>    <span class="hljs-keyword">private</span> Integer loginUser;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来进行业务代码实现。</p><h2 id="一、用户登录">一、用户登录</h2><p><strong>约定前后端交互接口</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http">[请求]<br>GET /user/login<br><br>userName=zhangsan&amp;password=123456<br><br>[响应]<br>&#123;<br>  &quot;code&quot;:&quot;SUCCESS&quot;,<br>  &quot;errorMessage&quot;:&quot;&quot;,<br>  &quot;data&quot;:&quot;&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Controller层代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">userLogin</span><span class="hljs-params">(String userName, String password)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(userName) || !StringUtils.hasLength(password)) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户名或密码为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserByName(userName);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || !password.equals(user.getPassword())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户名或密码不正确&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中Service层的代码，由于在Controller层中进行了合法性的判断，并且也不需要进行复杂的调用操作，于是只需要调用Mapper层即可。</p><p><strong>Mapper层代码</strong></p><p>这里采用的是注解的方式来操作数据库。(<strong>注意：一个项目中只可以选择一种方式操作数据库，即要么使用注解的方式，要么使用xml的方式，除非你特意配置</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from user where user_name = #&#123;userName&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">queryUserByName</span><span class="hljs-params">(String userName)</span>;<br></code></pre></td></tr></table></figure><p>最后前端再根据返回的数据进行判断，跳转博客列表页即可。</p><hr><p>虽然上述代码可以实现用户登录的功能，但是如果用户是不通过用户登录，直接去访问博客列表页，此时后续很多功能都会出现问题，而且逻辑上也不符(大部分网站都会要求先登录)。因此要解决上述问题，就需要对用户的访问进行判断，检查是否已经登录过。</p><p><strong>解决方案</strong></p><p>通过使用session来判断当前用户是否已经登录，当用户登录的时候，在session中存储信息，后续在访问其他页面的时候，就需要从session中去取数据，如果没有则是非法的访问。因此我们还需要在其他接口中专门再写检查session的代码，如果接口很多的话，这会是一个非常庞大的工程，此时我们可以使用Spring中的拦截器，对每一次请求拦截处理。</p><p><strong>拦截器代码</strong></p><p>定义拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//先从请求中获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span>(session == <span class="hljs-literal">null</span> || session.getAttribute(<span class="hljs-string">&quot;SESSION_USER_KEY&quot;</span>) == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//表示用户未登录</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置拦截器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginInterceptor loginInterceptor;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//注册自定义拦截对象</span><br>        registry.addInterceptor(loginInterceptor)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.js&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.css&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.html&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/**/*.png&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/login&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Controller层代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">userLogin</span><span class="hljs-params">(String userName, String password, HttpSession session)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(userName) || !StringUtils.hasLength(password)) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户名或密码为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserByName(userName);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || !password.equals(user.getPassword())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户名或密码不正确&quot;</span>);<br>    &#125;<br>    session.setAttribute(<span class="hljs-string">&quot;SESSION_USER_KEY&quot;</span>, user);<br>    <span class="hljs-keyword">return</span> Result.success(token);<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>虽然这里使用了session实现了用户登录检查功能，但是也存在一定的问题。</p><p>此处的session数据是保存在内存中的，当我们重启服务器的时候，就没了，虽然可以进行持久化的保存，但是也存在着集群的问题(虽然我们是单机部署)。</p><p>在此我们可以使用令牌token的方式进行检查，此时数据都存在用户那，当用户访问的时候检查token是否合法有效即可(使用token，会比较麻烦，需要自己去实现令牌生成，传递，校验)。</p><p>在这里我们使用JWT来实现token的生成和校验。</p><blockquote><p>JWT介绍</p><p>JWT全称json web token。</p><p>官网:<a href="https://jwt.io/">JSON Web Tokens - jwt.io</a></p><p>JWT由三部分组成,中间使用.来分隔: Header.Payload.Signature</p><p>Header中包含令牌的类型和使用的哈希算法</p><p>Payload中存放的是有效信息，即可以存放用户id等信息</p><p>Signature则是用来防止jwt内容被篡改，类似防伪标识</p></blockquote><p>要想使用JWT提供的API，我们需要添加相关依赖。</p><p><strong>添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/io.jsonwebtoken/jjwt-impl --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-impl<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.jsonwebtoken<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jjwt-jackson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span> <span class="hljs-comment">&lt;!-- or jjwt-gson if Gson is preferred  --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.11.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br></code></pre></td></tr></table></figure><p><strong>生成令牌</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTUtils</span> &#123;<br>    <span class="hljs-comment">//密钥字符串通过下面的方法生成</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">secretKeyString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;F1ZSY7rFvFoz3q/XjrCNW7ygjv0vzwJEpkydzaI8ZJ8=&quot;</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Key</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> Keys.hmacShaKeyFor(Decoders.BASE64.decode(secretKeyString));<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">expiration</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">generateKeyString</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Key</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> Keys.secretKeyFor(SignatureAlgorithm.ES256);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">secretKeyString</span> <span class="hljs-operator">=</span> Encoders.BASE64.encode(key.getEncoded());<br>        System.out.println(secretKeyString);<br>    &#125;<br>    <br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> claims 用来存储用户的有效信息，如id值，用户名等</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">generateToken</span><span class="hljs-params">(Map&lt;String, Object&gt; claims)</span>&#123;<br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> Jwts.builder()<br>                .signWith(key)<br>                .setClaims(claims)<br>                .setExpiration(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + expiration))<br>                .compact();<br>        <span class="hljs-keyword">return</span> token;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么不直接使用Keys.secretKeyFor()方法生成密钥呢？</p><p>程序需要生成一个一直不变的密钥，当我们重启了程序之后，我们的密钥依旧不会发生改变，因此我们只能使用Keys.hmacShaKeyFor()方法来生成密钥，而这个方法中的从参数需要进行严格的检查，即检查这个byte[]数组的长度要大于等于256bits(32byte)，在这我们通过Keys.secretKeyFor()方法，得到一个长度满足要求的密钥，然后获取他的原始序列，得到用来生成密钥的字符串，最后再通过Keys.hmacShaKeyFor()方法生成一个每次程序都一样的密钥，即使程序重启了，我们对上一次的token加密或解密也都是有效的。</p></blockquote><p><strong>校验令牌</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Claims <span class="hljs-title function_">parseToken</span><span class="hljs-params">(String token)</span>&#123;<br>    <span class="hljs-comment">//根据密钥生成解析器</span><br>    <span class="hljs-type">JwtParser</span> <span class="hljs-variable">jwtParser</span> <span class="hljs-operator">=</span> Jwts.parserBuilder().setSigningKey(key).build();<br>    <span class="hljs-comment">//解析token，并获取载荷部分的数据</span><br>    <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> (Claims) jwtParser.parse(token).getBody();<br><br>    <span class="hljs-keyword">return</span> claims;<br>&#125;<br></code></pre></td></tr></table></figure><p>得到载荷部分的数据，我们就可以根据里面的内容进行校验了(前提是登录的时候，要设置属性进去)。</p><p>使用token，我们需要<strong>重新约定前后端接口</strong>了</p><p><strong>约定前后端交互接口</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http">#请求<br>GET /user/login<br><br>userName=zhangsan&amp;password=123456<br><br>#响应<br>&#123;<br>  &quot;code&quot;:&quot;SUCCESS&quot;,<br>  &quot;errorMessage&quot;:&quot;&quot;,<br>  &quot;data&quot;:&quot;eyJhbGciOiJIUzI1NiJ9.eyJpZCI6MSwidXNlcm5hbWUiOiJ6aGFuZ3NhbiIsImlhdCI6MTY5ODM5N<br>zg2MCwiZXhwIjoxNjk4Mzk5NjYwfQ.oxup5LfpuPixJrE3uLB9u3q0rHxxTC8_AhX1QlYV--E&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Controller代码</strong></p><p>在我们登录成功后，我们需要将token字符串返回给前端，<strong>前端保存下来，下次访问的时候需要带上</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">userLogin</span><span class="hljs-params">(String userName, String password, HttpSession session)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasLength(userName) || !StringUtils.hasLength(password)) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户名或密码为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserByName(userName);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || !SecurityUtils.verify(password, user.getPassword())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户名或密码不正确&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//使用session</span><br>    <span class="hljs-comment">//session.setAttribute(&quot;SESSION_USER_KEY&quot;, user);</span><br>    <span class="hljs-comment">//登录成功，返回token</span><br>    Map&lt;String, Object&gt; claims = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    claims.put(<span class="hljs-string">&quot;id&quot;</span>, user.getId());<br>    claims.put(<span class="hljs-string">&quot;userName&quot;</span>, user.getUserName());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> JwtUtils.genToken(claims);<br>    <span class="hljs-keyword">return</span> Result.success(token);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、用户注册">二、用户注册</h2><p><strong>约定前后端交互接口</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http">[请求]<br>POST /user/register<br><br>userName=zhangsan&amp;password=123&amp;confirmPassword=123<br><br>[响应]<br>&#123;<br>  &quot;code&quot;:&quot;SUCCESS&quot;,<br>  &quot;errorMessage&quot;:&quot;&quot;,<br>  &quot;data&quot;:&quot;&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>注册接口会涉及到在数据库中添加用户，而对于用户的一些敏感信息我们需要进行加密处理，然后存储，以保证数据的安全性。如果使用的是明文存储在数据库中，一旦被入侵了，就可以轻松的获取，可能会造成不可预期的损失。我们在这里通过后端对密码进行加密处理然后存储。</p><p>这里我们使用的是摘要算法来进行加密(无法解密，只能通过一定的算法进行比对)。</p><p><strong>思路如下：</strong></p><p>随机生成一个字符串，即为&quot;盐值&quot;，然后与原始密码进行拼接，通过加密算法生成一个新的密码，最后再让这个新密码与随机生成的字符串进行拼接，最后再存入数据库中。</p><p>当下次进行验证的时候，首先从数据库中取出信息，然后分割字符串获取&quot;盐值&quot;，与传递的密码拼接、加密，生成一个字符串，让这个字符串与数据库中存储的密码进行比对，一致则说明没有问题。</p><img src="/2024/02/13/SSM%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20240216203213164.png" class title="image-20240216203213164"><p>主要包含两个过程：加密存储和校验比对。</p><p><strong>加密存储</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">encrypt</span><span class="hljs-params">(String password)</span>&#123;<br>    <span class="hljs-comment">//随机生成盐值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString().replace(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-comment">//进行加密</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">finalPassword</span> <span class="hljs-operator">=</span> DigestUtils.md5DigestAsHex((salt+password).getBytes());<br>    <span class="hljs-comment">//返回盐值+加密字符串</span><br>    <span class="hljs-keyword">return</span> salt+finalPassword;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>校验比对</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">verify</span><span class="hljs-params">(String password, String sqlPassword)</span>&#123;<br>    <span class="hljs-comment">//根据之前的保存形式获取盐值</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">salt</span> <span class="hljs-operator">=</span> sqlPassword.substring(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>);<br>    <span class="hljs-comment">//将原密码进行加密</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">finalPassword</span> <span class="hljs-operator">=</span> DigestUtils.md5DigestAsHex((salt + password).getBytes());<br>    <span class="hljs-comment">//与数据库密码进行比对</span><br>    <span class="hljs-keyword">return</span> (salt + finalPassword).equals(sqlPassword);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Contorller代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/register&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">registerUser</span><span class="hljs-params">(String userName, String password, String confirmPassword)</span>&#123;<br>    <span class="hljs-keyword">if</span>(!StringUtils.hasLength(userName) || !StringUtils.hasLength(password) || !StringUtils.hasLength(confirmPassword))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户名或密码为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!password.equals(confirmPassword))&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;两次密码不正确&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserByName(userName);<br>    <span class="hljs-keyword">if</span>(user != <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已存在&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">sqlPassword</span> <span class="hljs-operator">=</span> SecurityUtils.encrypt(password);<br>    userService.insertUser(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(userName, sqlPassword));<br>    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>最后再将登录的接口修改一下即可。</p><h2 id="三、显示用户信息">三、显示用户信息</h2><p><strong>前后端交互接口</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs http">[请求]<br>GET /user/getUserInfo<br><br>[响应]<br>&#123;<br>  &quot;code&quot;:&quot;SUCCESS&quot;,<br>  &quot;errorMessage&quot;:&quot;&quot;,<br>  //这里我们返回的是一个user对象<br>  &quot;data&quot;:&#123;<br>    &quot;id&quot;:1,<br>    &quot;userName&quot;:&quot;zhangsan&quot;，<br>    .......<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们得获取用户信息，具体实现如下：解析token，根据token中的id值，来查询用户信息，并返回给前端显示。</p><p>此处我们还需要在前端显示用户的文章数，因为我们返回的是一个user对象，我们可以<strong>在user类中添加一个属性即articleNumber</strong>。这样我们返回的时候只需要返回一个参数就行了。</p><p><strong>Controller代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/getUserInfo&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUserInfo</span><span class="hljs-params">(HttpServletRequest request)</span>&#123;<br>    <span class="hljs-comment">//获取token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;user_token&quot;</span>);<br>    <span class="hljs-comment">//解析token,获取id</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> JwtUtils.getUserIdFromToken(token);<br>    <span class="hljs-keyword">if</span>(id == <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserById(id);<br>    <span class="hljs-comment">//根据用户id计算文章个数</span><br>    user.setArticleNumber(blogService.countArticles(id));<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="四、修改用户信息">四、修改用户信息</h2><p>修改用户信息的困难之处在于上传头像。我们得了解一下项目编译后文件存放的位置。在构建项目的时候，Maven会将编译生成的类文件和资源文件放在target/classes目录下，我们后续浏览器访问的都是在这个目录下的内容，因此我们上传图片的时候，需要将上传的文件存放在这个目录下，但是这个目录是编译后生成的，也就是说我们重新启动程序后，上一次上传的文件就没有了，因此我们还需要持久化保存文件。</p><p>总的来说我们上传用户头像，需要将上传的文件存放在类目录下(target/classes)，和本地文件中(持久化保存)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadFileUtils</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">uploadFile</span><span class="hljs-params">(MultipartFile file)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//判断文件是否为空</span><br>        <span class="hljs-keyword">if</span>(file == <span class="hljs-literal">null</span> || file.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//获取文件名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> file.getOriginalFilename();<br>        <span class="hljs-comment">//防止文件名重复</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">newName</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString() + <span class="hljs-string">&quot;_&quot;</span> + fileName;<br>        <span class="hljs-comment">//获取文件上传的目录</span><br>        List&lt;File&gt; files = getUploadPath();<br>        <span class="hljs-comment">//上传文件</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">classFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(files.get(<span class="hljs-number">0</span>), newName);<br>        file.transferTo(classFile);<br>        FileCopyUtils.copy(classFile, <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(files.get(<span class="hljs-number">1</span>), newName));<br><br>        <span class="hljs-keyword">return</span> newName;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;File&gt; <span class="hljs-title function_">getUploadPath</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException &#123;<br>        <span class="hljs-comment">//获取类目录路劲</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">classPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(ResourceUtils.getURL(<span class="hljs-string">&quot;classpath:&quot;</span>).getPath());<br>        <span class="hljs-comment">//获取本地目录路劲(在linux上有些差异)</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">localPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>));<br><br>        <span class="hljs-comment">//上传的路径</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">classFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(classPath.getAbsolutePath(), <span class="hljs-string">&quot;/head&quot;</span>);<br>        <span class="hljs-type">File</span> <span class="hljs-variable">localFile</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(localPath.getAbsolutePath(), <span class="hljs-string">&quot;/src/main/resources/static/pic/head&quot;</span>);<br><br>        <span class="hljs-keyword">if</span>(!classFile.exists())&#123;<br>            classFile.mkdirs();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(!localFile.exists())&#123;<br>            localFile.mkdirs();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Arrays.asList(classFile, localFile);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ResourceUtils.getURL(“classpath:”).getPath()，用来获取类路径,即target/classes路径</p><p>System.getProperty(“user.dir”)，用来获取用户工作路径</p></blockquote><p>由于浏览器无法直接访问服务器的系统文件资源，因此我们需要进行配置映射，将前端请求图片的路径映射到刚刚存储图片的地方。</p><p>在WebConfig类中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> &#123;<br>    registry.addResourceHandler(<span class="hljs-string">&quot;/head/**&quot;</span>)<br>            .addResourceLocations(<span class="hljs-string">&quot;classpath:head/&quot;</span>, <span class="hljs-string">&quot;file:&quot;</span>+System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>)+<span class="hljs-string">&quot;src/main/resources/static/pic/head/&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码表示，当前端发起以head开头的请求资源时，首先映射到类路径下的资源文件，如果没找到，再去从本地文件中去寻找资源。</p><p>经此，我们就实现了文件的上传操作。</p><p><strong>约定前后端交互接口</strong></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs http">[请求]<br>POST /user/updateUser<br><br>userName=zhangsan&amp;githubUrl=https://github.com/&amp;avatarFile=.......<br><br>[响应]<br>&#123;<br>  &quot;code&quot;:&quot;SUCCESS&quot;,<br>  &quot;errorMessage&quot;:&quot;&quot;,<br>  &quot;data&quot;:&quot;&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Controller代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-meta">@RequestMapping(&quot;/updateUser&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">updateUser</span><span class="hljs-params">(HttpServletRequest request,</span><br><span class="hljs-params">                         <span class="hljs-meta">@RequestPart(value = &quot;avatar&quot;, required = false)</span> MultipartFile avatarFile,</span><br><span class="hljs-params">                         String userName,</span><br><span class="hljs-params">                         String githubUrl)</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;user_token&quot;</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> JwtUtils.getUserIdFromToken(token);<br>    <span class="hljs-keyword">if</span> (userId == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户未登录&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userService.getUserById(userId);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户不存在&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 处理头像上传</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">avatarPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;head/&quot;</span> + UploadFileUtils.uploadFile(avatarFile);<br><br>    <span class="hljs-keyword">if</span>(StringUtils.hasLength(avatarPath))&#123;<br>        user.setAvatarPath(avatarPath);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(StringUtils.hasLength(userName))&#123;<br>        user.setUserName(userName);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(StringUtils.hasLength(githubUrl))&#123;<br>        user.setGithubUrl(githubUrl);<br>    &#125;<br>    <span class="hljs-comment">// 保存用户信息</span><br>    userService.updateUser(user);<br><br>    <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、博客列表页">五、博客列表页</h2><p><strong>约定前后端交互接口</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[请求]</span><br>GET /blog/getBlogList<br><br><span class="hljs-selector-attr">[响应]</span><br>&#123;<br>  &quot;<span class="hljs-selector-tag">code</span>&quot;:<span class="hljs-string">&quot;SUCCESS&quot;</span>,<br>  <span class="hljs-string">&quot;errorMessage&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>:[<br>  &#123;<br>    &quot;id&quot;:<span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;第一篇博客&quot;</span>,<br>    <span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;xxxxxxxxxxxxxx&quot;</span><br>    .........<br>  &#125;,<br>  .......<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Controller代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/getBlogList&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;Blog&gt; <span class="hljs-title function_">getBlogList</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">return</span> blogService.queryAllBlogs();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="六、博客详情页">六、博客详情页</h2><p><strong>约定前后端交互接口</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[请求]<br><span class="hljs-built_in">GET</span> /blog/getBlogById<br><br><span class="hljs-attribute">blogId</span>=1<br><br>[响应]<br>&#123;<br>  <span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;SUCCESS&quot;</span>,<br>  <span class="hljs-string">&quot;errorMessage&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>:&#123;<br>  <span class="hljs-string">&quot;id&quot;</span>:1,<br>  <span class="hljs-string">&quot;title&quot;</span>:<span class="hljs-string">&quot;第一篇博客&quot;</span>,<br>  <span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;xxxxxxxxxxxxxx&quot;</span><br>  <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>.<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们需要对当前博客和当前用户进行比对，检查是否为作者，如果为作者就让前端显示编辑按钮和删除按钮，我们可以通过给user类增加一个loginUser的属性来简便实现。</p><p><strong>Controller代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/getBlogById&quot;)</span><br><span class="hljs-keyword">public</span> Blog <span class="hljs-title function_">getBlogById</span><span class="hljs-params">( Integer blogId, HttpServletRequest request)</span>&#123;<br>    <span class="hljs-keyword">if</span>(blogId == <span class="hljs-literal">null</span> || blogId &lt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> blogService.queryBlogById(blogId);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;user_token&quot;</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> JwtUtils.getUserIdFromToken(token);<br>    <span class="hljs-keyword">if</span>(id != <span class="hljs-literal">null</span> &amp;&amp; id.equals(blog.getUserId()))&#123;<br>        blog.setLoginUser(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> blog;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="七、博客修改页">七、博客修改页</h2><p><strong>约定前后端交互接口</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[请求]<br><span class="hljs-built_in">GET</span> /blog/updateBlog<br><br><span class="hljs-attribute">id</span>=1&amp;title=“第一篇博客&quot;......<br><br>[响应]<br>&#123;<br>  <span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;SUCCESS&quot;</span>,<br>  <span class="hljs-string">&quot;errorMessage&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>:<span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Controller代码</strong></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">RequestMapping(<span class="hljs-string">&quot;/updateBlog&quot;</span>)</span><br>public Result update<span class="hljs-constructor">Blog(Blog <span class="hljs-params">tmpBlog</span>, HttpServletRequest <span class="hljs-params">request</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(tmpBlog.get<span class="hljs-constructor">Id()</span><span class="hljs-operator"> == </span>null<span class="hljs-operator"> || </span>tmpBlog.get<span class="hljs-constructor">Id()</span> &lt;= <span class="hljs-number">0</span>)&#123;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;非法输入&quot;</span>);<br>    &#125;<br>    Blog blog = blogService.query<span class="hljs-constructor">BlogById(<span class="hljs-params">tmpBlog</span>.<span class="hljs-params">getId</span>()</span>);<br>    blog.set<span class="hljs-constructor">Title(<span class="hljs-params">tmpBlog</span>.<span class="hljs-params">getTitle</span>()</span>);<br>    blog.set<span class="hljs-constructor">Content(<span class="hljs-params">tmpBlog</span>.<span class="hljs-params">getContent</span>()</span>);<br><br>    String token = request.get<span class="hljs-constructor">Header(<span class="hljs-string">&quot;user_token&quot;</span>)</span>;<br>    Integer id = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">JwtUtils</span>.</span></span>get<span class="hljs-constructor">UserIdFromToken(<span class="hljs-params">token</span>)</span>;<br>    <span class="hljs-keyword">if</span>(id != null<span class="hljs-operator"> &amp;&amp; </span>id.equals(blog.get<span class="hljs-constructor">UserId()</span>))&#123;<br>        blogService.update<span class="hljs-constructor">Blog(<span class="hljs-params">blog</span>)</span>;<br>        return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>success(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Result</span>.</span></span>fail(<span class="hljs-string">&quot;修改失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八、博客发布页">八、博客发布页</h2><p><strong>约定前后端交互接口</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[请求]<br><span class="hljs-built_in">GET</span> /blog/addBlog<br><br><span class="hljs-attribute">id</span>=1&amp;title=“第一篇博客&quot;......<br><br>[响应]<br>&#123;<br>  <span class="hljs-string">&quot;code&quot;</span>:<span class="hljs-string">&quot;SUCCESS&quot;</span>,<br>  <span class="hljs-string">&quot;errorMessage&quot;</span>:<span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-string">&quot;data&quot;</span>:<span class="hljs-string">&quot;&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Controller代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/deleteBlog&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">deleteBlog</span><span class="hljs-params">(Integer blogId, HttpServletRequest request)</span> &#123;<br>    <span class="hljs-keyword">if</span> (blogId == <span class="hljs-literal">null</span> || blogId &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;非法输入&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> blogService.queryBlogById(blogId);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;user_token&quot;</span>);<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> JwtUtils.getUserIdFromToken(token);<br>    <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span> &amp;&amp; id.equals(blog.getUserId())) &#123;<br>        blogService.deleteBlog(blog.getId());<br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-string">&quot;&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;删除失败&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h1>总结</h1><p>至此我们实现了博客系统，功能比较简单，但博客系统的一些核心功能都实现了。</p><p>本次项目中遇到的最大的困难是上传图片，因为开始不懂的项目构建的路径知识，以及对io不太熟悉，导致项目写了挺久。后期又遇到了线上路径与开发路径不统一的情况，又卡了一天时间，最终是在2.8号将项目部署完毕。</p><p>开发一个web项目刚开始的时候比较困难，无从下手，但是通过不断的搜集资料，自己慢慢写，写了一些简单的增删改查之后就好多了。期间发现bug不要紧，根据日记信息进行调试分析。首先得找到问题的所在，即是前端的问题，还是后端的问题，一定需要定位准确，如开发的时候遇到了，在一个项目中即使用注解又使用了xml的方式操作数据库，然后前端就一直报404，虽然404一般是前端的问题，但是不能凭借经验主义，一口咬定，通过抓包等操作，发现是后端问题，一旦找到问题就很好解决了。</p><p>在开发的时候，也借助了chatGPT，虽然chatGPT无所不知，但是它并不能帮我解决问题，并且有很多问题也不好描述，比较尴尬，只能通过自己一步一步分析，然后将问题分解，告诉chatGPT才能有解决的可能。因此，我感觉chatGPT短时间内还是无法取代程序员的，它无法对业务代码进行很好的处理，不过对写代码的效率会有很大提升。</p><p>接下来就要开始写另一个项目了——消息队列，它不是web项目，有点类似mysql，需要写一个客户端版本，和一个服务器版本。用户通过客户端来访问服务器，有点意思哈~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cookie&amp;session&amp;token</title>
    <link href="/2024/01/31/cookie-session-token/"/>
    <url>/2024/01/31/cookie-session-token/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><p><strong>cookie</strong>是由<strong>服务器发送给客户端</strong>，并<strong>存储在客户端</strong>上的文本文件。当用户首次访问某个网站时，此时没有cookie，此时服务器可以根据需要，将一些内容存储在cookie中然后返回给客户端，客户端就会存储下来，当下一次访问的时候，就会自动带上cookie值访问。</p><h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><p><strong>session</strong>是<strong>服务器的会话管理机制</strong>，客户端那边是感知不到的。当用户首次访问服务器时，服务器会为其创建一个会话标识(SessionID)，<strong>每一个SessionID都对应一个Session，每一个Session又是一个key-value形式存储的结构</strong>，可以用于存储用户的一些信息。由于session是存储在服务器上的，相较于cookie比较安全(不能伪造),并且session可以根据需要进行配置修改。</p><p>在实际应用中，<strong>Cookie和Session会进行结合使用</strong>，例如用户登录的场景，当用户登录完成，服务端可以信息存储在cookie、session中，然后将cookie更新后的内容返回给客户端，客户端下次请求带上cookie，然后服务器就可以根据sessionID查找相应的session，然后验证是否登录。</p><h1 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h1><p>虽然cookie和session配合能很好完成任务，但还存在一定缺陷。</p><p>在<strong>集群环境</strong>下，服务器不止一台，当用户的请求过来时，通过负载均衡，第一次到了服务器1，服务器1进行验证，并存储了相应session，当第二次请求的时候，通过负载均衡来到了服务器2，服务器2由于没有存储session，就需要用户进行相应的操作。</p><img src="/2024/01/31/cookie-session-token/image-20240212210340828.png" class title="image-20240212210340828"><p>上述情况也可以通过将所有的session存储在一个共享的地方，存的时候存一个地方，取的时候也从同一个地方取。</p><p>不过还可以使用更加优雅的方案——Token，令牌技术。</p><p>Token，<strong>本质上就是一个字符串，类似于身份证，存储在客户端上</strong>，用户访问，服务器通过某种算法生成一个字符串，然后发送给客户端，客户端下次访问的时候带上token，然后<strong>服务器再通过算法进行比对校验token</strong>。</p><h2 id="令牌的优缺点"><a href="#令牌的优缺点" class="headerlink" title="令牌的优缺点"></a>令牌的优缺点</h2><p>优点：</p><ul><li>解决了集群环境的验证问题</li><li>减轻服务器的存储负担(存储在客户端上)</li></ul><p>缺点：</p><p>需要自己实现，令牌生成、发送、校验。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringAOP</title>
    <link href="/2024/01/21/SpringAOP/"/>
    <url>/2024/01/21/SpringAOP/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、什么是AOP"><a href="#一、什么是AOP" class="headerlink" title="一、什么是AOP"></a>一、什么是AOP</h1><p><strong>AOP全称</strong>：Aspect Oriented Programming (<strong>面向切面编程</strong>)</p><p>AOP类似OOP，<strong>是一种思想，用于对某一类事情的集中处理</strong>。</p><p><strong>举个例子</strong>：</p><p>假设我们需要对每个方法进行计算运行时间，那我们<strong>需要对每个方法都进行修改</strong>，在里面添加代码，如果方法比较多，工程量就会很大，还很容易出错。如果实现AOP的思想，就可以<strong>做到不改动原始方法(无侵入性)，并完成功能的增强。</strong></p><h1 id="二、AOP应用"><a href="#二、AOP应用" class="headerlink" title="二、AOP应用"></a>二、AOP应用</h1><h2 id="2-1-拦截器"><a href="#2-1-拦截器" class="headerlink" title="2.1 拦截器"></a>2.1 拦截器</h2><p>在进行web开发的时候，往往会对用户的登录进行校验，这就需要对一些接口进行修改(成本比较高)，此时的耦合性很高(如果我要修改登录的逻辑，所有的实现的接口就需要跟着修改)。</p><p>Spring就提供了拦截器，可以拦截用户的请求，在指定方法的前后执行。</p><img src="/2024/01/21/SpringAOP/SpringAOP.png" class title="image-20240212112559652"><p>实现拦截器分为两步: </p><p><strong>1.定义拦截器</strong></p><p>实现HandlerInterceptor，并重写方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginIntercept</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//目标方法前执行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">//目标方法后执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>preHandler方法：目标方法执行前执行，如果返回值为true，则执行目标方法，否则就不执行</li><li>postHandler方法：目标方法执行后执行</li></ul><p><strong>2.注册拦截器配置</strong></p><p>实现WebConfigurer接口，重写addInterceptors方法，将自定义的拦截器注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> LoginIntercept loginIntercept;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        <span class="hljs-comment">//注册拦截器对象</span><br>        registry.addInterceptor(loginIntercept)<br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                .excludePathPatterns(<span class="hljs-string">&quot;/login&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>addInterceptors方法：添加拦截器对象</li><li>addPathPatterns方法：添加拦截路径</li><li>excludePathPatterns方法：排除拦截路径</li></ul><table><thead><tr><th>拦截路径</th><th>含义</th><th>举例</th></tr></thead><tbody><tr><td>&#x2F;*</td><td>⼀级路径</td><td>能匹配&#x2F;user，&#x2F;book，&#x2F;login，不能匹配&#x2F;user&#x2F;login</td></tr><tr><td>&#x2F;**</td><td>任意级路径</td><td>能匹配&#x2F;user，&#x2F;user&#x2F;login，&#x2F;user&#x2F;reg</td></tr><tr><td>&#x2F;book&#x2F;*</td><td>&#x2F;book下的⼀级路径</td><td>能匹配&#x2F;book&#x2F;addBook，不能匹配&#x2F;book&#x2F;addBook&#x2F;1，&#x2F;book</td></tr><tr><td>&#x2F;book&#x2F;**</td><td>&#x2F;book下的任意级路径</td><td>能匹配&#x2F;book，&#x2F;book&#x2F;addBook，&#x2F;book&#x2F;addBook&#x2F;2，不能匹 配&#x2F;user&#x2F;login</td></tr></tbody></table><h2 id="2-2-统一返回功能"><a href="#2-2-统一返回功能" class="headerlink" title="2.2 统一返回功能"></a>2.2 统一返回功能</h2><p>在项目开发中，所有的接口不一定是一个人写的，因此返回值可能会不一样，如果去要求每个人的话，就会增加许多成本，因此可以使用Spring提供的统一返回功能，这样就算接口的返回值写的天花乱坠，最终返回给前端的数据都能够统一。大大降低了前后端程序员沟通成本，也有利于数据统一维护</p><p>实现统一返回功能分为两步:</p><p><strong>1.添加注解</strong></p><p>在类上添加@ControllerAdvice，表示控制器通知类</p><p><strong>2.实现接口，重写方法</strong></p><p>实现ResponseBodyAdvice接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResponseAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ResponseBodyAdvice</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">supports</span><span class="hljs-params">(MethodParameter returnType, Class converterType)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">beforeBodyWrite</span><span class="hljs-params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>supports方法：判断是否要执行beforBodyWrite方法。如果为true表示执行，为false则不执行。</li><li>beforBodyWrite方法：对返回值进行处理的方法。当body为String类型需要使用jackson来实现序列化处理。</li></ul><h2 id="2-3-统一异常处理"><a href="#2-3-统一异常处理" class="headerlink" title="2.3 统一异常处理"></a>2.3 统一异常处理</h2><p>在编写代码的过程中有些代码抛出的异常是相同的，因此我们可以使用统一异常处理，当出现了某一个异常的时候统一的进行处理，这样提升了开发效率，也提高了代码的维护性。</p><p>实现统一异常处理分为两步：</p><p><strong>1.添加类注解</strong></p><p>在要实现的类上添加@ControllerAdvice，表示此类是一个通知类</p><p><strong>2.添加方法注解</strong></p><p>针对每一个异常处理的方法，添加@ExceptionHandler，表示此方法是一个异常处理方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorAdvice</span> &#123;<br>    <span class="hljs-meta">@ExceptionHandler</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handler</span><span class="hljs-params">(Exception e)</span>&#123;<br>        <span class="hljs-keyword">return</span> e.getMessage();<br>    &#125;<br>    <br>    <span class="hljs-meta">@ExceptionHandler</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">handler</span><span class="hljs-params">(NullPointerException e)</span>&#123;<br>        <span class="hljs-keyword">return</span> e.getMessage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="三、自定义实现AOP"><a href="#三、自定义实现AOP" class="headerlink" title="三、自定义实现AOP"></a>三、自定义实现AOP</h1><h2 id="3-1-实现AOP程序"><a href="#3-1-实现AOP程序" class="headerlink" title="3.1 实现AOP程序"></a>3.1 实现AOP程序</h2><p><strong>1.添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2.编写程序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAspect</span> &#123;<br>    <span class="hljs-meta">@Around(&quot;execution(* com.example.aopdemo.controller.*.*(..))&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">function</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        log.info(<span class="hljs-string">&quot;目标方法执行前&quot;</span>);<br><br>        proceedingJoinPoint.proceed();<br><br>        log.info(<span class="hljs-string">&quot;目标方法执行后&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@Aspect：标识这个类是一个通知类</li><li>@Around：通知类型，(“execution(* com.example.aopdemo.controller.<em>.</em>(..))”)为切点表达式</li><li>proceedingJoinPoint.proceed()，执行原始方法，即被增强的方法。</li></ul><h2 id="3-1-AOP核心概念"><a href="#3-1-AOP核心概念" class="headerlink" title="3.1 AOP核心概念"></a>3.1 AOP核心概念</h2><p>1.<strong>切点：</strong>作用的范围，指出对哪些方法进行切入。</p><p>上述的”execution(* com.example.aopdemo.controller.<em>.</em>(..))”为切点。</p><p>可以使用@Pointcut将切点表达式提取出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.example.aopdemo.controller.*.*(..))&quot;)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pt</span><span class="hljs-params">()</span>&#123;&#125;<br><br><span class="hljs-meta">@Around(&quot;pt()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">function</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>2.<strong>连接点：</strong>被切入的方法，即每一个被切入的方法都是一个连接点，因此切点也是连接点的集合</p><p>3.<strong>通知：</strong>具体功能的实现，即切入其他方法之后要做的事情。</p><p>上述方法中的执行逻辑就为通知。</p><blockquote><p>通知类型：</p><ul><li>@Around：环绕通知,标注的通知方法，在目标方法的执行前后都会执行。目标方法发生异常，不再执行</li><li>@Before：前置通知，标注的通知方法，在目标方法执行前执行</li><li>@After：后置通知，标注的通知方法，在目标方法执行后执行。目标方法即使异常也会执行</li><li>@AfterReturning：返回后通知，标注的通知方法，在目标方法执行后执行。目标方法有异常就不执行</li><li>@AfterThrowing：异常后通知，标注的通知方法，在目标方法发生异常后执行。</li></ul></blockquote><p><strong>执行顺序：</strong></p><img src="/2024/01/21/SpringAOP/image-20240212163911946.png" class title="image-20240212163911946"><p>4.<strong>切面：</strong>切点+通知。</p><h1 id="四、SpringAOP原理"><a href="#四、SpringAOP原理" class="headerlink" title="四、SpringAOP原理"></a>四、SpringAOP原理</h1><p>SpringAOP是<strong>基于动态代理</strong>来实现的，而动态代理又是基于JDK和CGlib实现的。</p><blockquote><p>静态代理：由程序员创建代理类自动生成源代码再进行编译，在程序运行前代理类的.class文件就已经存在了</p><p>动态代理：在程序运行时，运用反射机制动态创建</p></blockquote><p><strong>区别：</strong></p><p>JDK使用的是基于接口的动态代理，只能代理接口，不能代理类，通过反射的方式创建，由于是官方提供的标准API，优化比较好，性能也就比较好。</p><p>CGLib使用的是字节码生成技术，修改字节码来生成，既可以代理接口也可以代理类。</p><p>SpringAOP中既使用了JDK代理，又使用了CGLib代理。SpringBoot2.X开始,默认使⽤CGLIB代理，但也可以通过配置项spring.aop.proxy-target-class来设置代理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis</title>
    <link href="/2023/12/04/MyBatis/"/>
    <url>/2023/12/04/MyBatis/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是MyBatis"><a href="#什么是MyBatis" class="headerlink" title="什么是MyBatis"></a>什么是MyBatis</h1><p>MyBatis是一个优秀的持久层框架,用于<strong>简化JDBC的开发</strong>,免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。</p><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a>案例引入</h2><p>现在我们要通过java程序来去数据库查询一个表中的数据,当我们使用JDBC来开发的时候,会写特别多的代码。</p><blockquote><p>步骤如下:</p><p>1.创建数据源(Datasource)</p><p>2.和数据库服务建立连接</p><p>3.构造sql语句并执行</p><p>4.关闭连接，释放资源</p></blockquote><p>当使用JDBC的时候,会发现有大量重复的代码,最需要修改的也就是构造sql语句,因此可以使用框架来简化操作。</p><p><strong>JDBC代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-comment">//查询表中的数据 username 为 &quot;admin&quot; 的数据</span><br><br>    <span class="hljs-comment">//1.创建数据源</span><br>    <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>    ((MysqlDataSource)dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/mybatis_test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>    ((MysqlDataSource)dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>    ((MysqlDataSource)dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>    <span class="hljs-comment">//2.建立连接</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br><br>    <span class="hljs-comment">//3.构造SQL并执行</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from useinfo where username = ?&quot;</span>;<br>    <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>    statement.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> statement.executeQuery();<br>    <span class="hljs-keyword">while</span>(resultSet.next())&#123;<br>        System.out.println(<span class="hljs-string">&quot;id: &quot;</span> + resultSet.getString(<span class="hljs-string">&quot;id&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;username: &quot;</span> + resultSet.getString(<span class="hljs-string">&quot;username&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;password: &quot;</span> + resultSet.getString(<span class="hljs-string">&quot;password&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-comment">//4.释放资源</span><br>    resultSet.close();<br>    statement.close();<br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Mybatis代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInfoMapper</span> &#123;<br>    <span class="hljs-meta">@Select(&quot;select * from userinfo where username = #&#123;name&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> UserInfo <span class="hljs-title function_">queryUserByName</span><span class="hljs-params">(String name)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用MyBatis框架,只需要加上几个注解即可轻松完成JDBC的操作。</p><h1 id="MyBatis创建"><a href="#MyBatis创建" class="headerlink" title="MyBatis创建"></a>MyBatis创建</h1><h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>创建springboot项目,导入相关依赖:mybatis,mysql</p><img src="/2023/12/04/MyBatis/image-20231204194140522.png" class title="image-20231204194140522"><img src="/2023/12/04/MyBatis/image-20231204194244520.png" class title="image-20231204194244520"><h2 id="配置数据库连接"><a href="#配置数据库连接" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h2><p>MyBatis中连接数据库,需要设置如下相关参数配置</p><blockquote><ul><li>MySQL驱动类</li><li>url</li><li>username</li><li>password</li></ul></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#数据库连接配置</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://127.0.0.1:3306/mybatis_test?characterEncoding=utf8&amp;useSSL=false</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><blockquote><p>注意事项：<br>MySQL是5.x之前版本使用”com.mysql.jdbc.Driver”</p><p>MySQL是5.x之后版本使用”com.mysql.cj.jdbc.Driver”</p></blockquote><h1 id="MyBatis使用"><a href="#MyBatis使用" class="headerlink" title="MyBatis使用"></a>MyBatis使用</h1><p>当我们通过MyBatis对数据库进行增删改查操作的时候，有两种实现方式：<strong>注解和XML</strong>。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>创建一个实体类，将数据库中的表映射成一个对象类。</p><img src="/2023/12/04/MyBatis/image-20231204195207822.png" class title="image-20231204195207822"><img src="/2023/12/04/MyBatis/image-20231204195225027.png" class title="image-20231204195225027"><blockquote><p>注意事项：</p><p>在Java中通常使用驼峰命名，数据库设计通常使用蛇形命名</p></blockquote><hr><p>为了后续可以清楚的查看sql语句的执行、执行传递参数和结果,可以使用打印日志的方式。</p><p>只需在配置文件中进行配置即可：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><p><strong>首先定义一个接口，然后加上@Mapper注解</strong>。<strong>再编写一个查询方法,”具体实现”是在@Select注解中</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInfoMapper</span> &#123;<br>    <span class="hljs-comment">//注解里的是&quot;具体实现&quot;</span><br>    <span class="hljs-meta">@Select(&quot;select * from userinfo where username = #&#123;user.username&#125;&quot;)</span><br>    <span class="hljs-keyword">public</span> UserInfo <span class="hljs-title function_">queryUserByName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span>UserInfo userInfo)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们要指定参数的时候，需要使用#{}的方式。#{}会被看作是一个占位符，里面的内容会在编译后进行转换。</p><p>我们可以对参数进行重命名，使用@Param设置别名。#{…}里面的属性名必须和@Param设置的一样。</p><p>我们可以通过日志来观察程序运行的SQL语句。</p><img src="/2023/12/04/MyBatis/image-20231204203141037.png" class title="image-20231204203141037"><p>通过观察日志，我们可以发现打印出来的结果中有些值并没有被赋值，依旧为null。</p><p><strong>这是因为MyBatis首先会去数据库查询数据，然后得到一个临时表，然后根据临时表中字段的名字对实体类的属性进行映射赋值。</strong></p><img src="/2023/12/04/MyBatis/image-20231204210859686.png" class title="image-20231204210859686"><hr><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>1.起别名</strong></p><p>起别名就是在写SQL语句的时候，对列进行起别名的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select id, username, password, age, gender, phone, &quot; +</span><br><span class="hljs-meta">        &quot; delete_flag as deleteFlag,&quot; +</span><br><span class="hljs-meta">        &quot; create_time as createTime,&quot; +</span><br><span class="hljs-meta">        &quot; update_time as updateTime&quot; +</span><br><span class="hljs-meta">        &quot; from userinfo &quot; +</span><br><span class="hljs-meta">        &quot; where username = #&#123;user.username&#125;&quot;)</span><br><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title function_">queryUserByName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span>UserInfo userInfo)</span>;<br></code></pre></td></tr></table></figure><img src="/2023/12/04/MyBatis/image-20231204205656255.png" class title="image-20231204205656255"><p><strong>2.结果映射</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from userinfo where username = #&#123;user.username&#125;&quot;)</span><br><span class="hljs-meta">@Results(id = &quot;BaseMap&quot;, value = &#123;</span><br><span class="hljs-meta">        @Result(column = &quot;delete_flag&quot;, property = &quot;deleteFlag&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;create_time&quot;, property = &quot;createTime&quot;),</span><br><span class="hljs-meta">        @Result(column = &quot;update_time&quot;, property = &quot;updateTime&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title function_">queryUserByName</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span>UserInfo userInfo)</span>;<br></code></pre></td></tr></table></figure><p><strong>这样写，其实就是告诉程序，把delete_flag的值赋值给属性名为deleteFlag的变量。</strong></p><p>后续的代码可以通过Results的id值进行代码复用。</p><img src="/2023/12/04/MyBatis/image-20231204212108020.png" class title="image-20231204212108020"><p><strong>3.开启驼峰命名</strong></p><p>通常数据库使用蛇形命名，通过下划线分割单词，而Java属性采用小驼峰的命名方式。</p><p><strong>可以通过配置，将蛇形命名自动转换成驼峰命名。</strong></p><img src="/2023/12/04/MyBatis/image-20231204212406688.png" class title="image-20231204212406688"><p>后续会自动进行转换然后映射赋值。</p><hr><h3 id="XML方式"><a href="#XML方式" class="headerlink" title="XML方式"></a>XML方式</h3><p>注解的方式通常是用来完成一些比较简单的SQL语句，当实现复杂的SQL的话，建议使用XML的方式。</p><blockquote><p>XML的方式需要以下两步:</p><p>1、配置数据库连接字符串和MyBatis</p><p>2、持久层代码</p></blockquote><p><strong>配置数据库连接字符串和MyBatis：</strong></p><img src="/2023/12/04/MyBatis/image-20231205100408692.png" class title="image-20231205100408692"><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">log-impl:</span> <span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#配置 mybatis xml的文件路径，在resource/mapper创建所有表的xml文件</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:mapper/**Mapper.xml</span><br></code></pre></td></tr></table></figure><p><strong>持久层代码：</strong></p><p>mapper接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserInfoXMLMapper</span> &#123;<br>    <span class="hljs-keyword">public</span> UserInfo <span class="hljs-title function_">queryUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span>UserInfo userInfo)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>xml代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">mapper</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.example.mybatispractice.mapper.UserInfoXMLMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&quot;queryUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.mybatispractice.dao.UserInfo&quot;</span>&gt;</span><br>        select id, username, password, age, gender, phone,<br>               delete_flag, create_time, update_time<br>                from userinfo where username = #&#123;user.username&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2023/12/04/MyBatis/image-20231205103145316.png" class title="image-20231205103145316"><p>当使用xml的方式，遇到了数据库表字段与实体类属性无法映射的问题的时候，同样也是使用上述的解决方法。只不过使用结果映射的方法有一些略微差别。</p><img src="/2023/12/04/MyBatis/image-20231205104247097.png" class title="image-20231205104247097"><h2 id="添加操作"><a href="#添加操作" class="headerlink" title="添加操作"></a>添加操作</h2><p>添加操作跟查询操作类似。</p><img src="/2023/12/04/MyBatis/image-20231205111748342.png" class title="image-20231205111748342"><p>Insert语句默认返回的是受影响的行数，我们还以通过@Option注解获取到新插入数据的id(拥有自增属性)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Options(useGeneratedKeys = true, keyProperty = &quot;user.id&quot;)</span><br><span class="hljs-meta">@Insert(&quot;insert into userinfo (username, password, age) &quot; +</span><br><span class="hljs-meta">        &quot;values(#&#123;user.username&#125;, #&#123;user.password&#125;, #&#123;user.age&#125;)&quot;)</span><br><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">insertUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span>UserInfo userInfo, String s)</span>;<br></code></pre></td></tr></table></figure><img src="/2023/12/04/MyBatis/image-20231205112524368.png" class title="image-20231205112524368"><p><strong>XML方式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">insertUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span>UserInfo userInfo)</span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;user.id&quot;</span>&gt;</span><br>    insert into userinfo (username, password, age) values(#&#123;user.username&#125;, #&#123;user.password&#125;, #&#123;user.age&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2023/12/04/MyBatis/image-20231205113403926.png" class title="image-20231205113403926"><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除操作十分简单，只需要注意参数即可。</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">deleteUserById</span><span class="hljs-params">(Integer id)</span>;<br></code></pre></td></tr></table></figure><p>XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserById&quot;</span>&gt;</span><br>    delete from userinfo where id  &gt;= #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><p>结果：</p><img src="/2023/12/04/MyBatis/image-20231205165650757.png" class title="image-20231205165650757"><h2 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h2><p>现在将id&#x3D;1 的 username和password修改为”admin”</p><p>接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">updateUserById</span><span class="hljs-params">(Integer id, String username, String password)</span>;<br></code></pre></td></tr></table></figure><p>XML：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUserById&quot;</span>&gt;</span><br>    update userinfo set username = #&#123;username&#125;, password = #&#123;password&#125; where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>结果:</p><img src="/2023/12/04/MyBatis/image-20231205114442564.png" class title="image-20231205114442564"><h1 id="和"><a href="#和" class="headerlink" title="#{}和${}"></a>#{}和${}</h1><p>#{}和${}都是MyBatis参数赋值的方式，但也存在着一定的区别。</p><h2 id="案例引入-1"><a href="#案例引入-1" class="headerlink" title="案例引入"></a>案例引入</h2><p>接口代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select username, password, age from userinfo where username = #&#123;name&#125;&quot;)</span><br><span class="hljs-keyword">public</span> UserInfo <span class="hljs-title function_">queryUserByName1</span><span class="hljs-params">(String name)</span>;<br></code></pre></td></tr></table></figure><p>当我们使用#{}的方式进行参数赋值的时候，MyBatis会采用”预编译”的方式进行处理，即并不是直接在参数后面拼接，而是使用 ? 进行占位。</p><img src="/2023/12/04/MyBatis/image-20231205172555733.png" class title="image-20231205172555733"><p>当我们把#{}修改成${}</p><img src="/2023/12/04/MyBatis/image-20231205180422178.png" class title="image-20231205180422178"><p>程序会进行报错，我们通过观察日志可以发现此处的zhangsan字符串并没有使用引号引起来。</p><blockquote><p>我们可以得出：</p><p>#{}使用的是预编译SQL，通过？占位的方式提前对SQL进行编译，然后把参数填充到SQL语句中，并且#{}会根据参数类型，自动拼接引号。</p><p>${}使用的是即时SQL，直接进行字符替换，一起对SQL进行编译，如果参数是字符串，需要自己手动加上引号。</p></blockquote><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>#{}和${}的区别就是<strong>预编译SQL</strong>和<strong>即时SQL</strong>的区别。</p><p><strong>性能</strong></p><p>一条SQL语句在执行前会经过”SQL语法解析”、”SQL优化”、”SQL编译”这些过程，这些过程都需要耗费一定的时间。</p><p>当我们使用预编译的SQL的方式，编译一次之后会将编译后的SQL语句缓存起来，后面再次执行的时候就可以采用替换参数的形式，省去解析优化的过程，提高效率。</p><p><strong>安全</strong></p><p><strong>安全指的是能防止SQL注入。</strong></p><p>SQL注入是通过操作输入的数据来修改事先定义好的SQL语句。由于没有对用户的输入充分检查，又使用的是字符串拼接的方式，当用户输入参数的时候就可以完成”注入”。</p><p>如图：</p><img src="/2023/12/04/MyBatis/image-20231206151537849.png" class title="image-20231206151537849"><p><strong>由于${}会直接拼接字符串，因此就有可能出现SQL注入的现象。</strong></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="${}使用场景"></a>${}使用场景</h2><p>既然${}的使用既不安全，又不高效，那还有存在的必要吗？</p><p>答案是存在一定的适用的场景。</p><p>当参数不再作为一个字符串，即要求不加上’’</p><p>例如：排序场景，like模糊查询场景</p><p><strong>排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from userinfo order by username #&#123;pattern&#125;&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;UserInfo&gt; <span class="hljs-title function_">queryAll</span><span class="hljs-params">(String pattern)</span>;<br></code></pre></td></tr></table></figure><img src="/2023/12/04/MyBatis/image-20231206154257076.png" class title="image-20231206154257076"><img src="/2023/12/04/MyBatis/image-20231206154518386.png" class title="image-20231206154518386"><p>这个时候我们就需要使用上${}的方式了，即直接拼接。为了防止SQL注入的现象我们可以对传递的参数进行一次校验。</p><p><strong>模糊查询</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from userinfo where username like &#x27;%#&#123;str&#125;&#x27;&quot;)</span><br><span class="hljs-keyword">public</span> List&lt;UserInfo&gt; <span class="hljs-title function_">queryAllByLike</span><span class="hljs-params">(String str)</span><br></code></pre></td></tr></table></figure><p>显然我们直接使用#{}的方式是不可以的，因此我们可以使用${}的方式，但会有SQL注入的风险。</p><p>因此我们还可以使用MySQL的内置函数concat()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Select(<span class="hljs-string">&quot;select * from userinfo where username like concat(&#x27;%&#x27;, #&#123;str&#125;)&quot;</span>)<br><span class="hljs-keyword">public</span> List&lt;UserInfo&gt; <span class="hljs-title function_">queryAllByLike</span><span class="hljs-params">(String str)</span>;<br></code></pre></td></tr></table></figure><h1 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h1><p>动态SQL是MyBatis的强大特性之一，通过在SQL语句中增加一些逻辑判断，完成不同条件下的SQL拼接。</p><p>例如：</p><p>当注册用户信息的时候，往往会涉及到两类字段：必填和非必填。针对非必填字段可以使用动态标签来判断。</p><h2 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h2><p>和Java里面的if判断相同，都是用作条件判断。</p><p>语法：在sql中使用，if标签里面的test属性为必填项，相当于if中的逻辑判断语句。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">insertDynamicUser</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">UserInfo</span> <span class="hljs-variable">userInfo</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserInfo</span>();<br>    userInfo.setUsername(<span class="hljs-string">&quot;laoliu&quot;</span>);<br>    userInfo.setPassword(<span class="hljs-string">&quot;laoliu&quot;</span>);<br>    userInfo.setPhone(<span class="hljs-string">&quot;110&quot;</span>);<br>    userInfo.setAge(<span class="hljs-number">18</span>);<br>    System.out.println(userInfoXMLMapper.insertDynamicUser(userInfo));<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertDynamicUser&quot;</span>&gt;</span><br>    insert into userinfo (username,<br>                          password,<br>                          age,<br>                          <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span>gender,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>                          phone)<br>                values(#&#123;username&#125;,<br>                       #&#123;password&#125;,<br>                       #&#123;age&#125;,<br>                       <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;gender != null&quot;</span>&gt;</span>#&#123;gender&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>                       #&#123;phone&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们真的不传递gender属性的时候，代码执行的SQL如下：</p><img src="/2023/12/04/MyBatis/image-20231206174356034.png" class title="image-20231206174356034"><p>如果带上了gender参数，此时SQL代码执行如下：</p><img src="/2023/12/04/MyBatis/image-20231206174516741.png" class title="image-20231206174516741"><p>此时带上了参数gender。</p><h2 id="trim标签"><a href="#trim标签" class="headerlink" title="trim标签"></a>trim标签</h2><p>一般配合着if标签使用。</p><p>在trim标签包含着的语句中，可以设置里面的属性，对sql语句进行修改。</p><blockquote><p>标签属性：</p><p>prefix：表示整个语句块，以prefix的值为前缀</p><p>suffix：表示整个语句块，以suffix的值为后缀</p><p>prefixOverrrides：表示整个语句块要去掉的前缀</p><p>suffixOverrides：表示整个语句块要去掉的后缀</p></blockquote><p>一般使用在if标签中某个属性如果没有传参，就会多产生一些符号，可以通过trim标签进行修改。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertDynamicUser&quot;</span>&gt;</span><br>    insert into user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>            username,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>            password,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>    values<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>            #&#123;username&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>            #&#123;password&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们的password未进行传参的时候，此时SQL就会多出来一个逗号，我们需要使用trim标签进行修改。</p><h2 id="where标签"><a href="#where标签" class="headerlink" title="where标签"></a>where标签</h2><p>where标签也是搭配if标签使用的。<strong>如果where标签中没有内容则不会添加where语句，如果里面有内容会自动的删除前缀的and。</strong></p><p>一般使用在where条件语句中非必传。</p><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDynamicUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.mybatispractice.dao.UserInfo&quot;</span>&gt;</span><br>    select * from user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>           and username = #&#123;username&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>            and password = #&#123;password&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们一个参数都不传的时候，就会执行查询所有用户数据。</p><p>上述写法还等价于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDynamicUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.mybatispractice.dao.UserInfo&quot;</span>&gt;</span><br>    select * from user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span><br>           and username = #&#123;username&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>            and password = #&#123;password&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：当trim标签没有内容的时候，此时就不会添加前后缀。</strong></p><p>使用where标签会更加简洁。</p><h2 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h2><p>使用于update修改语句中，根据传入的用户对象属性来更新用户数据。</p><p><strong>set标签会自动的插入set关键字并删除额外的逗号</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateDynamicUser&quot;</span>&gt;</span><br>    update user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>            password = #&#123;password&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where username = #&#123;username&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述写法还等价于</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateDynamicUser&quot;</span>&gt;</span><br>    update user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;set&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span><br>            password = #&#123;password&#125;,<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>    where username = #&#123;username&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h2><p>foreach标签会将传入的集合类或数组等容器里面的数据循环取出注入到sql中。</p><blockquote><p>foreach标签有五个属性：</p><p>collection：绑定方法参数中的集合</p><p>item：遍历时的每一个对象</p><p>open：语句块开头字符串</p><p>close：语句块结尾字符串</p><p>separator：每次遍历之间间隔的字符串</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteDynamicUser&quot;</span>&gt;</span><br>    delete from user where username in <br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>                        #&#123;username&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="/2023/12/04/MyBatis/image-20231206210721137.png" class title="image-20231206210721137"><h2 id="include标签"><a href="#include标签" class="headerlink" title="include标签"></a>include标签</h2><p>在xml文件中配置SQL时，有时可能会出现许多重复的代码片段，此时我们可以使用include标签将重复的代码进行封装到一起。</p><blockquote><p><sql>：定义可重用的SQL片段</sql></p><p><include>：通过属性refid，指定包含的SQL片段</include></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;xixi&quot;</span>&gt;</span><br>    username, password, age, gender<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDynamicUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.example.mybatispractice.dao.UserInfo&quot;</span>&gt;</span><br>    select<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;xixi&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    from userinfo<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring IoC&amp;DI</title>
    <link href="/2023/11/24/Spring-IoC-DI/"/>
    <url>/2023/11/24/Spring-IoC-DI/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h1><p>Spring是Java的一个开源框架。用具体的话来说，<strong>Spring是包含了众多工具方法的IoC容器</strong>。</p><h1 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h1><p>IoC全称Inversion of Control(控制反转)，是Spring的核心思想。</p><blockquote><p>控制反转也就是控制权反转。在传统开发中,需要程序猿自己通过new来创建对象,而当控制权反转后,会把创建对象的任务交给容器.</p></blockquote><h2 id="案例引入"><a href="#案例引入" class="headerlink" title="案例引入"></a>案例引入</h2><p>现在要创建一辆车Car,需要一个车架Framework,车架需要一个地盘Bottom,地盘需要一个轮胎Tire。</p><p><strong>在传统开发模式下,创建的顺序如下:</strong></p><img src="/2023/11/24/Spring-IoC-DI/image-20231124164055860.png" class title="image-20231124164055860"><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br>        <span class="hljs-keyword">private</span> Framework framework;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">()</span> &#123;<br>            framework = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Framework</span>();<br>            System.out.println(<span class="hljs-string">&quot;创建Car~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Framework</span>&#123;<br>        <span class="hljs-keyword">private</span> Bottom bottom;<br>        <span class="hljs-keyword">public</span>  <span class="hljs-title function_">Framework</span><span class="hljs-params">()</span>&#123;<br>            bottom = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bottom</span>();<br>            System.out.println(<span class="hljs-string">&quot;创建Framework~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span>&#123;<br>        <span class="hljs-keyword">private</span> Tire tire;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bottom</span><span class="hljs-params">()</span>&#123;<br>            tire = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tire</span>();<br>            System.out.println(<span class="hljs-string">&quot;创建Tire~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tire</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tire</span><span class="hljs-params">()</span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;创建Tire~&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当我们创建一个Car对象的时候,只需要new一个Car,但是现在我们的Tire的size是写死的,当我们的需求发生改变,比如让用户自定义大小,此时我们需要修改Tire的构造方法,问题又来了,Bottom中调用了Tire的构造方法,我们此时还要修改Bottom的构造方法……..以此类推,触发一系列的连锁反应。</p><p><strong>总之当使用传统的模式开发的时候，代码耦合度很高，一旦我们修改一点内容，就会引发一系列的修改。</strong></p><hr><p>IoC模式下,创建顺序如下:</p><img src="/2023/11/24/Spring-IoC-DI/image-20231124164750706.png" class title="image-20231124164750706"><p><strong>代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo02</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Tire</span> <span class="hljs-variable">tire</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tire</span>(<span class="hljs-number">10</span>);<br>        <span class="hljs-type">Bottom</span> <span class="hljs-variable">bottom</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bottom</span>(tire);<br>        <span class="hljs-type">Framework</span> <span class="hljs-variable">framework</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Framework</span>(bottom);<br>        <span class="hljs-type">Car</span> <span class="hljs-variable">car</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Car</span>(framework);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br>        <span class="hljs-keyword">private</span> Framework framework;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Car</span><span class="hljs-params">(Framework framework)</span> &#123;<br>            <span class="hljs-built_in">this</span>.framework = framework;<br>            System.out.println(<span class="hljs-string">&quot;创建Car~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Framework</span>&#123;<br>        <span class="hljs-keyword">private</span> Bottom bottom;<br>        <span class="hljs-keyword">public</span>  <span class="hljs-title function_">Framework</span><span class="hljs-params">(Bottom bottom)</span>&#123;<br>            <span class="hljs-built_in">this</span>.bottom = bottom;<br>            System.out.println(<span class="hljs-string">&quot;创建Framework~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Bottom</span>&#123;<br>        <span class="hljs-keyword">private</span> Tire tire;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Bottom</span><span class="hljs-params">(Tire tire)</span>&#123;<br>            <span class="hljs-built_in">this</span>.tire = tire;<br>            System.out.println(<span class="hljs-string">&quot;创建Tire~&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Tire</span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">Tire</span><span class="hljs-params">(<span class="hljs-type">int</span> size)</span>&#123;<br>            <span class="hljs-built_in">this</span>.size = size;<br>            System.out.println(<span class="hljs-string">&quot;创建Tire~&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察代码发现，当我们创建Car对象的时候,里面的Framework并不是Car对象自己创建,即不再是使用方对象 创建并控制依赖对象,而是把依赖的对象注入使用方对象中,即<strong>依赖对象的控制权不再由当前类控制,此时依赖类发生任何改变(增&#x2F;删属性)当前类都不受影响</strong>。</p><p><strong>总结:</strong></p><blockquote><p>传统开发模式下,是Car控制并创建Framework,Framework控制并创建Bottom,Bottom控制并创建Tire,耦合度非常高。</p><p>IoC开发模式下,使用方不再创建并控制依赖对象,而是通过”注入”的方式,注入到当前对象中，实现了解耦合。</p></blockquote><p><strong>Spring作为IoC容器,负责帮我们完成main函数中的new操作。</strong></p><img src="/2023/11/24/Spring-IoC-DI/image-20231124171033746.png" class title="image-20231124171033746"><h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><p>DI全称Dependency Injection(依赖注入).即容器在运行期间,动态的提供运行时锁依赖的资源。</p><p>所谓依赖注入,就是将依赖关系动态的放到对象中.</p><p>当我们需要某个依赖的时候,不需要自己手动创建,而是让Spring来帮我们完成。</p><p>例如,在案例IoC模式实现下的代码中,我们的Car对象并没有去new对象，而是注入了Framework对象完成了创建。</p><p>上述代码”注入过程”如下:</p><img src="/2023/11/24/Spring-IoC-DI/image-20231124173632495.png" class title="image-20231124173632495"><p>IoC是一种思想,而DI属于是具体的实现,也可以认为DI是IoC的一种实现。</p><h1 id="Spring中IoC-amp-DI使用"><a href="#Spring中IoC-amp-DI使用" class="headerlink" title="Spring中IoC&amp;DI使用"></a>Spring中IoC&amp;DI使用</h1><p>在前面我们提到Spring是一个IoC的容器，作为一个容器,就包含了两个基本的功能:存与取。</p><p>在Spring容器中,我们存储的是对象(在Spring中对象又称为”Bean”).程序猿把对象交给Spring管理,由Spring负责创建与销毁，因此开发的时候只需要告诉Spring存什么对象,取什么对象即可。</p><h2 id="Bean存储"><a href="#Bean存储" class="headerlink" title="Bean存储"></a>Bean存储</h2><p>Spring作为IoC容器,可以帮助我们进行对象的管理,不过我们需要指定哪些对象需要交给Spring来管理。</p><p>实现将某个对象交给Spring管理,可以分别使用类注解和方法注解。</p><p><strong>类注解</strong>：@Controller、@Service、@Repository、@Component、@Configuration</p><p><strong>方法注解</strong>：@Bean</p><hr><p>类注解的方式很好实现,在类的上面加一行注解即可。这几个不同的类注解，后续使用基本没啥区别。</p><p><strong>那为什么还要这么多类注解?</strong></p><p>这是因为与分层的思想呼应,程序猿看到这个注解就能大概知道这个类是干嘛的了。</p><ul><li>@Controller：控制层,接收请求和处理,并进行相应</li><li>@Service：业务层,处理具体业务逻辑</li><li>@Repository：数据访问层,负责数据访问操作</li><li>@Configuration：配置层,处理项目中的一些配置信息</li><li>@Component：组件,工具类</li></ul><p>通过观察这些注解,我们还可以发现，@Controller、@Service、@Repository、@Configuration这四个注解中都包含了@Component，即@Component是他们的”父类”。</p><hr><p>方法注解则是能解决类注解的两个非常重要的问题：</p><p>1、当使用外部包的类,此时无法添加类注解</p><p>2、一个类需要创建多个对象，如数据源(如果使用类注解只会创建一个对象)</p><p><strong>注意：当我们使用方法注解@Bean时，需要在加上类注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//不可以少</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        user.setAge(<span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果后续我们要手动获取的话,这个Bean对象的名称就为方法名即getUser.</p><p>我们还可以设置@Bean中的name属性进行重命名操作。后续获取对象的时候使用重命名即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <span class="hljs-comment">//不可以少</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo3</span> &#123;<br>    <span class="hljs-meta">@Bean(name = &#123;&quot;user1&quot;, &quot;user2&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>        user.setName(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        user.setAge(<span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Bean获取"><a href="#Bean获取" class="headerlink" title="Bean获取"></a>Bean获取</h2><p>由于对象交给了Spring管理,所有要从Spring获取对象,就得先获取到Spring的上下文(这里的上下文指的是当前的运行环境)</p><p>获取Spring上下文:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringIocDemoApplication</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//获取Spring上下文</span><br><span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> SpringApplication.run(SpringIocDemoApplication.class, args);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ApplicationContext提供了获取bean的方式,而这个功能是来自父类BeanFactory接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br>    <span class="hljs-comment">//以上省略...</span><br>    <br>    <span class="hljs-comment">// 1. 根据bean名称获取bean</span><br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String var1)</span> <span class="hljs-keyword">throws</span> BeansException;<br>    <br>    <span class="hljs-comment">// 2. 根据bean名称和类型获取bean</span><br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(String var1, Class&lt;T&gt; var2)</span> <span class="hljs-keyword">throws</span> BeansException;<br>    <br>    <span class="hljs-comment">// 3. 按bean名称和构造函数参数动态创建bean,只适⽤于具有原型(prototype)作⽤域的bean</span><br>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String var1, Object... var2)</span> <span class="hljs-keyword">throws</span> BeansException;<br>    <br>    <span class="hljs-comment">// 4. 根据类型获取bean</span><br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; var1)</span> <span class="hljs-keyword">throws</span> BeansException;<br>    <br>    <span class="hljs-comment">// 5. 按bean类型和构造函数参数动态创建bean, 只适⽤于具有原型(prototype)作⽤域的bean</span><br>    &lt;T&gt; T <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;T&gt; var1, Object... var2)</span> <span class="hljs-keyword">throws</span> BeansException;<br>    <br>    <span class="hljs-comment">//以下省略...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过观察我们会发现getBean中有一些是根据String var值来获取Bean的，此处的var值就表示的是Bean的名称(BeanId)。</p><blockquote><p>Bean的名称(BeanId)：</p><p>Spring Bean是Spring框架在运行时管理的对象,Spring会给管理的对象其一个名字,类似身份证,通过身份证就可以找到对应的人,Spring就可以根据Bean的名称(BeanId)找到对应的对象。</p></blockquote><p><strong>程序猿不需要为Bean指定名称,Spring会自动生成,程序也可以手动设定。</strong></p><p>Spring自动取名规则如下:</p><blockquote><p>小驼峰:</p><p>类名：UserInform, Bean名称：userInform</p><p>类名：UserController，Bean名称：userController</p><p>特殊情况:当有多个字符且第一个和第二个字符都是大写,保留这些大写</p><p>类名：UController，Bean名称：UController</p><p>类名：TUController，Bean名称：TUController</p></blockquote><img src="/2023/11/24/Spring-IoC-DI/image-20231126202516911.png" class title="image-20231126202516911"><p>当我们通过类注解的方式来创建Bean的话,此时只会创建一个对象。</p><h2 id="ApplicationContext-Vs-BeanFactory"><a href="#ApplicationContext-Vs-BeanFactory" class="headerlink" title="ApplicationContext Vs BeanFactory"></a>ApplicationContext Vs BeanFactory</h2><ul><li><p>从继承关系和功能方面:ApplicationContext和BeanFactory是Spring容器的两个顶级接口。BeanFactory提供了基础的访问容器的能力,ApplicationContext是BeanFactory的子类,还拥有了添加了对国际化⽀持、资源访问⽀持、以及事件传播等⽅⾯的⽀持 。</p></li><li><p>从性能方面:ApplicationContext是”预加载”,一次性加载并初始化所有的Bean对象,而BeanFactory是”懒加载”,需要哪个区加载哪个。</p></li></ul><h2 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h2><p>依赖注入是一个过程,是指IoC容器在创建Bean时,提供运行时依赖的资源</p><p>在Spring中可以使用@Autowired注解来实现依赖注入。</p><p>注入的方式有三种:</p><ul><li>属性注入</li><li>构造方法注入</li><li>Setter注入</li></ul><hr><h3 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入:"></a>属性注入:</h3><p>在成员属性上加上@Autowired</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hi,UserController~&quot;</span>);<br>        userService.sayHi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>方便简洁</p><p><strong>缺点：</strong>不能注入一个Final修饰的属性；只能用于IoC容器；只有在使用的时候才会报空指针异常</p><h3 id="构造方法注入："><a href="#构造方法注入：" class="headerlink" title="构造方法注入："></a>构造方法注入：</h3><p>在构造方法上加上@Autowired</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController2</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UserController2</span><span class="hljs-params">(UserService userService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hi,controller~&quot;</span>);<br>        userService.sayHi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意事项:</strong></p><p>如果类中只有一个构造方法,此时@Autowired注解可以省略。如果有多个构造方法,可以使用@Autowired来指定通过哪个方法来注入。</p><p><strong>优点：</strong>可以注入Final修饰的属性；注入对象不会被修改(构造方法只调用一次)；通用性好,构造方法任何框架都支持</p><p><strong>缺点：</strong>注入多个对象时,比较麻烦</p><h3 id="Setter注入："><a href="#Setter注入：" class="headerlink" title="Setter注入："></a>Setter注入：</h3><p>Setter注入和属性的Setter方法实现类似,只不过在设置set方法的时候需要加上@Autowired注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserController2</span> &#123;<br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUserService</span><span class="hljs-params">(UserService userService)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userService = userService;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayHi</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;hi,controller~&quot;</span>);<br>        userService.sayHi();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优点：</strong>方便重新对对象进行配置或注入</p><p><strong>缺点：</strong>不能注入Final修饰属性；注入对象容易被改变</p><h2 id="Autowired的问题"><a href="#Autowired的问题" class="headerlink" title="@Autowired的问题"></a>@Autowired的问题</h2><p>当同一个类型存在多个Bean时，使用@Autowired会抛出异常。</p><img src="/2023/11/24/Spring-IoC-DI/image-20231127170031879.png" class title="image-20231127170031879"><p>报错的原因是非唯一的Bean对象。</p><p>针对这种情况，Spring提供了如下几种解决方案:</p><ul><li>@Primary</li><li>@Qualifier</li><li>Resource</li></ul><hr><h3 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h3><p>使用@Primary注解，来确定默认的实现。</p><img src="/2023/11/24/Spring-IoC-DI/image-20231127170450025.png" class title="image-20231127170450025"><h3 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h3><p>使用@Qualifier注解,指定当前要注入的Bean对象。@Qualifier的value属性中指定注入的Bean名称。</p><img src="/2023/11/24/Spring-IoC-DI/image-20231127170717594.png" class title="image-20231127170717594"><p>并且Qualifier注解不能单独使用，需要配合@Autowired注解。</p><h3 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h3><p>使用@Resource注解,按照Bean的名称进行注入。@Resource的name属性中指定注入的Bean名称。</p><img src="/2023/11/24/Spring-IoC-DI/image-20231127171005827.png" class title="image-20231127171005827"><p>此时不需要配合@Autowired注解了。</p><h3 id="Autowired-VS-Resource"><a href="#Autowired-VS-Resource" class="headerlink" title="@Autowired VS @Resource"></a>@Autowired VS @Resource</h3><ul><li>@Autowired是Spring框架提供的，@Resource是JDK提供的</li><li>@Autowired默认是按照类型注入,@Resource是按照名称(Bean的名称)注入的。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/2023/11/14/JVM/"/>
    <url>/2023/11/14/JVM/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、JVM的内存区域划分"><a href="#一、JVM的内存区域划分" class="headerlink" title="一、JVM的内存区域划分"></a>一、JVM的内存区域划分</h1><p>一个进程在运行的时候,会向操作系统申请到内存资源,从来存放程序运行的相关数据。</p><p>JVM本质上就是一个java进程,在运行的时候也会从操作系统那搞一块内存，供Java代码执行使用。</p><p>JVM又把申请的一块内存根据不同的用途划分出了不同区域。</p><img src="/2023/11/14/JVM/image-20231114150935223.png" class title="image-20231114150935223"><p><strong>每一个线程中都独有一份自己的栈空间和程序计数器(PC)</strong></p><p>**栈:**存放方法调用关系,局部变量。</p><p>**程序计数器(PC):**记录当前线程执行的下一条指令的内存地址。</p><p>**堆:**存放对象的实例,即new出来的对象都在这里。</p><p>**方法区(元数据区):**存放类对象,常量池,静态成员。</p><h1 id="二、JVM类加载机制"><a href="#二、JVM类加载机制" class="headerlink" title="二、JVM类加载机制"></a>二、JVM类加载机制</h1><p>类加载本质上就是将.class文件(硬盘)加载到内存(方法区)中。</p><p>Java程序最开始在编写的时候是一个.java文件,然后通过编译生成.class(字节码)文件,运行java程序,JVM就会读取.class文件,把文件的内容放到内存中,构造.class对象。</p><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><img src="/2023/11/14/JVM/image-20231114154740988.png" class title="image-20231114154740988"><ul><li><p>加载:找到.class文件,打开文件,读取文件内容。</p></li><li><p>验证:检查当前.class文件的格式。</p></li><li><p>准备:给类对象分配内存空间。给类对象分配空间并进行默认初始化(一般置为0)。</p></li><li><p>解析:主要针对字符串常量,将常量池中的符号引用替换为直接引用。</p><blockquote><p>符号引用:相对的位置</p><p>直接引用:真是的内存地址</p><p>在.class文件中,由于还未加载到内存中,无法确定内存地址,只能使用一个相对偏移量来表示内存地址。当JVM将.class文件进行加载分配了内存地址，此时字符串常量就有了真实地址,然后将一些引用变量中的”符号引用”替换成直接引用。</p></blockquote></li><li><p>初始化:对类对象进行初始化。初始化静态成员,执行静态代码块,加载父类…..</p></li></ul><h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>双亲委派模型描述的是类加载的过程中,如何找.class文件。</p><p>JVM在加载.class文件的时候,需要用到类加载器,在JVM中就自带了三个类加载器。</p><blockquote><p>这三个类加载器存在”父子关系”,这里的父子关系并不是通过继承形成的,而是对象中有一个引用指向”父类”加载器实例</p></blockquote><ul><li>Bootstarp ClassLoader 负责加载标准库中的类(Java标准文档中规定了需要提供哪些基本类)</li><li>Extension ClassLoader 负责加载JVM扩展库中的类(JVM厂商可能还会添加一些类)</li><li>Application ClassLoader 负责加载第三方库的类(mysql、jackson…….以及一些自己写的类)</li></ul><p>双亲委派模型就描述了类加载的流程:</p><img src="/2023/11/14/JVM/image-20231114182821085.png" class title="image-20231114182821085"><p>1.先从Application ClassLoader开始</p><pre><code class="hljs"> 此时并不会立即搜索第三方库的类,而是先把加载任务委派给&quot;父亲&quot;,让父亲先尝试加载</code></pre><p>2.到了Extension ClassLoader</p><p>​此时也不会立即搜索扩展库的类,而是再把加载任务委派给”父亲”,让父亲先尝试加载</p><p>3.到了Bootstrap ClassLoader</p><p>​此时Bootstrap ClassLoader没有”父亲”了,只好自己去加载类了。</p><p>​如果找到了这个类,就会进行下一个类的加载,如果没找到了就会回到委派的那个类加载器,即Extension ClassLoader</p><p>4.任务回到Exension ClassLoader</p><p>​此时只能自己去搜索扩展库的类了。</p><p>​如果找到了这个类,就会进行下一个类的加载,如果没找到了就会回到委派的那个类加载器,即Application ClassLoader</p><p>5.任务回到Application ClassLoader</p><p>​此时只能自己去搜索第三方库的类了。</p><p>​如果找到了这个类,就会进行下一个类的加载,如果没找到了会抛出异常。</p><p><strong>总结:双亲委派模型就是一个找.class文件的过程。</strong>平时如果我们创建一个跟标准库中名字一样的类,使用的时候依旧是标准库中的那一个,因为双亲委派模型机制,<strong>会优先使用标准库的类</strong>,这也是这个机制的意义。</p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p><strong>类加载使用了懒汉模式,即当使用的时候才会进行加载。</strong></p><p>大致可以分为三个时机:</p><ol><li>构造类的实例</li><li>使用了类的静态方法&#x2F;静态属性</li><li>子类的加载会触发父类</li></ol><p>一旦类被加载好了,后续使用就不必再加载了,直接使用即可。</p><h1 id="三、JVM垃圾回收机制"><a href="#三、JVM垃圾回收机制" class="headerlink" title="三、JVM垃圾回收机制"></a>三、JVM垃圾回收机制</h1><p>在C语言中使用malloc手动申请完内存后需要手动释放,如果光申请而不去释放的话,到达一定程度后,内存被耗尽,程序就会崩溃,但是通过程序猿来手动操作就非常考验个人水平了,无法保证可靠。</p><p>Java为了解决上述问题,就引入了垃圾回收机制,自动的把垃圾释放掉。</p><p>虽然这个垃圾回收(GC)这个机制非常香,但是也是需要付出代价的,即消耗额外的系统资源和性能开销,同时也出现STW问题。</p><blockquote><p>STW问题:</p><p>Stop-The-World 简称 STW，是指在执行垃圾回收的过程冻结所有用户线程的运行，直到垃圾回收线程执行结束。</p></blockquote><p>垃圾回收的主战场在堆区,进行垃圾回收需要两步:判断对象是否为”垃圾”; 释放对象的内存。</p><h2 id="判断对象是否为”垃圾”"><a href="#判断对象是否为”垃圾”" class="headerlink" title="判断对象是否为”垃圾”"></a>判断对象是否为”垃圾”</h2><p>当一个对象,在后续代码中不会被继续使用了,即这个对象已经没有任何引用指向它了,就可以认为是垃圾了。</p><p>如何判断,有如下两种思路:引用计数和可达性分析。</p><h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p><strong>核心思路</strong>:给每个对象里面安排一个计数器,每当有引用指向它的时候,就把计数器的值+1,每当引用被销毁,计数器的值-1.当计数器为0的时候,表示这个对象为垃圾。</p><p><strong>优点</strong>:简单，好实现。</p><p><strong>缺点</strong>:**空间利用率低,浪费内存空间(**当对象本身比较小的时候,会大大降低空间利用率)；</p><p>​  <strong>存在循环引用问题,导致对象不能被正确识别为垃圾</strong>。如图:</p><img src="/2023/11/14/JVM/image-20231114195645704.png" class title="image-20231114195645704"><p>此时对象A,B在外部已经没有人指向了,即此时我们无法通过代码再去操作A和B了,按理来说已经成为了垃圾,但此时他们的计数器都不为0,无法正确的被识别为垃圾。</p><p><strong>在Java中没有使用这种方式,但在Python,PHP的虚拟机中就是使用了引用计数的方式来完成的</strong>。</p><h3 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h3><p>在Java中就采用了这个方案。</p><p>**核心思路:**JVM首先会从现有代码中的能直接访问到的引用出发,尝试遍历所有能访问的对象,只要对象能访问到,就会被标记为”可达”。完成整个遍历后,除开可达对象外,其它的也就是不可达对象,也就相当于是垃圾了。</p><p>**优点:**能够很好的解决引用计数中的循环引用问题。</p><p>**缺点:**需要消耗更多的时间。</p><h2 id="释放对象内存"><a href="#释放对象内存" class="headerlink" title="释放对象内存"></a>释放对象内存</h2><p>释放对象内存主要有三种方式:标记清除;复制算法;标记整理。</p><h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p><strong>标记清除是一种直接释放对象内存的方式</strong>。这种方式简单粗暴,但会遇到如下问题,即当GC对象是离散,空间不连续的时候：</p><img src="/2023/11/14/JVM/image-20231115115526286.png" class title="image-20231115115526286"><p>**此时如果直接释放对象的话,就会引起”内存碎片”**。在申请内存空间的时候都是申请一块连续的内存,当使用标记清除直接释放的话,此时如果申请的内存空间比正GC对象大的话,就无法使用这块已经被回收的内存。</p><p>例如:假设上图中的每个GC对象的大小是1MB,但我们此时要申请一个2MB的内存空间,由于每个GC对象内存的前后的内存被占用了,我们就无法申请到空间.</p><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>复制算法的核心思路是将空间分成两份,把有效对象复制到另一部分内存空间,来避免内存空间。</p><img src="/2023/11/14/JVM/image-20231115120523947.png" class title="image-20231115120523947"><p>先是将左侧有效对象进行复制,放到右侧,然后再释放内存,当用了一段时间后,右侧也会有许多需要GC的对象,此时就将有效对象复制到左侧,循环往复。</p><p>虽然这种方式能有效的解决内存碎片问题,但当需要复制的对象内容比较多,就会引发不小的开销,并且由于会将内存进行划分,也会造成内存利用低的问题。</p><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><p>标记整理是使用顺序表删除元素的思路。</p><p>每当要GC一个对象,会将后面的对象往前搬运。</p><img src="/2023/11/14/JVM/image-20231115121506810.png" class title="image-20231115121506810"><p>这种方式,不仅可以解决内存碎片问题,也解决了内存利用率低的问题,但是会涉及频繁搬运的问题,这就会带来不小的开销。</p><hr><h3 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h3><p>设计JVM的大佬集百家之长,搞了一个综合性的解决方法:分代回收。</p><p>分代回收是基于”一个对象存在的越久,那么它将继续存在的可能性就越高”的事实,然后对每个对象使用”年龄”标记,根据年龄来制定不同的回收策略。</p><img src="/2023/11/14/JVM/image-20231115122610167.png" class title="image-20231115122610167"><p><strong>分代回收将整个堆分成了两部分:新生代和老年代。在新生代中又划分了两个不同的区域:伊甸区和幸存区。</strong></p><p><strong>在新生代中以复制算法为主,在老年代中以标记整理算法为主。</strong></p><p>伊甸区中存放的是新生的对象,在经过一轮的GC后,没有被回收的对象就会被通过复制算法，复制到幸存区中。</p><p>幸存区中又划分了两块不同的空间,用来针对后续的复制算法,当第二轮GC后,没有被回收的对象就会被复制到幸存区中另一块空间。</p><p>如果一个对象在幸存区中存活了好多轮都没有挂,这个对象的年龄就比较大了,就会被复制到老年代中。</p><p><strong>在新生代中每一轮GC留下的对象并不会很多,所以进行复制算法的开销并不会很大,而在老年代中,对象比较重要,所以销毁的也很少，此时标记整理开销也不会很大。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet搭建博客系统</title>
    <link href="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>现在我们可以使用Servlet来搭建一个动态(前后端可以交互)的博客系统了(使用Hexo只能实现一个纯静态的网页,即只能在后台自己上传博客)。有一种”多年媳妇熬成婆”的感觉。</p><h1 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h1><p>首先创建好项目,引入相关依赖。具体过程在”Servlet的创建”中介绍了。</p><p>在这我们要引入servlet,mysql,jackson的相关依赖。</p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231106162646872.png" class title="image-20231106162646872"><p>然后将相关web.xml配置好，将网站前端的代码也引入webapp中。</p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231106162759938.png" class title="image-20231106162759938"><h1 id="二、业务逻辑的实现"><a href="#二、业务逻辑的实现" class="headerlink" title="二、业务逻辑的实现"></a>二、业务逻辑的实现</h1><p>由于数据要进行持久化保存,在这我们使用mysql数据来存储。</p><p>首先我们先进行数据库的设计。</p><p>在这个博客系统中,会涉及到写博客和登陆的简单操作,因此需要创建两个表:<strong>用户表和博客表</strong>。</p><p>因为数据库需要创建,当们换了一台机器的时候需要再一次创建,为了简便,可以将创建的sql语句保存下来,下次直接调用即可。</p><h1 id><a href="#" class="headerlink" title></a><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231106165257763.png" class title="image-20231106165257763"></h1><p>然后将上述代码复制到mysql的命令行执行即可。</p><hr><h2 id="封装数据库"><a href="#封装数据库" class="headerlink" title="封装数据库"></a>封装数据库</h2><p>为了简化后续对数据库的crud操作,在这对JDBC进行封装,后续代码就轻松许多了。</p><p>在这创建一个dao的文件夹,表示Data Access Object, 即数据访问对象,通过写一些类,然后通过类中的封装好的方法来间接访问数据库。</p><p>在dao文件下创建一个DBUtil的类,将连接数据库和释放资源操作进行封装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> dao;<br><br><span class="hljs-keyword">import</span> com.mysql.jdbc.jdbc2.optional.MysqlDataSource;<br><br><span class="hljs-keyword">import</span> javax.sql.DataSource;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DBUtil</span> &#123;<br>    <span class="hljs-comment">//使用单例模式中的饿汉模式创建实例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource <span class="hljs-title function_">getDataSource</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//防止竞争太激烈</span><br>        <span class="hljs-keyword">if</span>(dataSource == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span> (DBUtil.class)&#123;<br>                <span class="hljs-keyword">if</span>(dataSource == <span class="hljs-literal">null</span>)&#123;<br>                    dataSource = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>                    ((MysqlDataSource)dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/blog_system?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>                    ((MysqlDataSource)dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>                    ((MysqlDataSource)dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">//获取数据库连接</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> getDataSource().getConnection();<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//释放资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">(Connection connection, PreparedStatement statement, ResultSet resultSet)</span>&#123;<br>        <span class="hljs-comment">//一个一个释放,防止一个抛出异常,后续就不释放连接了</span><br>        <span class="hljs-keyword">if</span>(resultSet != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                resultSet.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(statement != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                statement.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span>(connection != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                connection.close();<br>            &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>创建实体类</strong></p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231106184725520.png" class title="image-20231106184725520"><p><strong>创建实体类的Dao类,进一步封装数据库操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> dao;<br><br><span class="hljs-keyword">import</span> java.net.ConnectException;<br><span class="hljs-keyword">import</span> java.sql.Connection;<br><span class="hljs-keyword">import</span> java.sql.PreparedStatement;<br><span class="hljs-keyword">import</span> java.sql.ResultSet;<br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">//通过这个类,封装针对 blog 表的增删改查操作</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogDao</span> &#123;<br>    <span class="hljs-comment">//新增一个博客</span><br>    <span class="hljs-comment">//使用try catch捕获异常,finally释放资源</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(Blog blog)</span>  &#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            connection = DBUtil.getConnection();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into blog values(null, ?, ?, ?, now())&quot;</span>;<br>            statement = connection.prepareStatement(sql);<br>            statement.setString(<span class="hljs-number">1</span>, blog.getTitle());<br>            statement.setString(<span class="hljs-number">2</span>, blog.getContent());<br>            statement.setInt(<span class="hljs-number">3</span>, blog.getUserId());<br>            statement.executeUpdate();<br>        &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            DBUtil.close(connection, statement, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> List&lt;Blog&gt; <span class="hljs-title function_">getBlogs</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        List&lt;Blog&gt; blogs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">try</span>&#123;<br>            connection = DBUtil.getConnection();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from blog&quot;</span>;<br>            statement = connection.prepareStatement(sql);<br>            resultSet = statement.executeQuery();<br>            <span class="hljs-keyword">while</span>(resultSet.next())&#123;<br>                <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blog</span>();<br>                blog.setBlogId(resultSet.getInt(<span class="hljs-string">&quot;blogId&quot;</span>));<br>                blog.setTitle(resultSet.getString(<span class="hljs-string">&quot;title&quot;</span>));<br>                blog.setContent(resultSet.getString(<span class="hljs-string">&quot;content&quot;</span>));<br>                blog.setUserId(resultSet.getInt(<span class="hljs-string">&quot;userId&quot;</span>));<br>                blog.setPostTime(resultSet.getTimestamp(<span class="hljs-string">&quot;postTime&quot;</span>));<br>                blogs.add(blog);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            DBUtil.close(connection, statement, resultSet);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> blogs;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Blog <span class="hljs-title function_">getBlog</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            connection = DBUtil.getConnection();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from blog&quot;</span>;<br>            statement = connection.prepareStatement(sql);<br>            resultSet = statement.executeQuery();<br>            <span class="hljs-keyword">if</span>(resultSet.next())&#123;<br>                blog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blog</span>();<br>                blog.setBlogId(resultSet.getInt(<span class="hljs-string">&quot;blogId&quot;</span>));<br>                blog.setTitle(resultSet.getString(<span class="hljs-string">&quot;title&quot;</span>));<br>                blog.setContent(resultSet.getString(<span class="hljs-string">&quot;content&quot;</span>));<br>                blog.setUserId(resultSet.getInt(<span class="hljs-string">&quot;userId&quot;</span>));<br>                blog.setPostTime(resultSet.getTimestamp(<span class="hljs-string">&quot;postTime&quot;</span>));<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            DBUtil.close(connection, statement, resultSet);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> blog;<br>    &#125;<br><br>    <span class="hljs-comment">//根据博客ID指定博客删除</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">int</span> blogId)</span>&#123;<br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            connection = DBUtil.getConnection();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delete from blog where blogId = ?&quot;</span>;<br>            statement = connection.prepareStatement(sql);<br>            statement.setInt(<span class="hljs-number">1</span>, blogId);<br>            statement.executeUpdate();<br>        &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            DBUtil.close(connection, statement, <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>后面再处理数据库操作的时候就可以直接使用这些代码了。</p><p>通过观察这些代码,我们会发现非常多重复的东西,后期通过学习了一些高级的框架后就能将代码的结构再优化一下.</p><p>同理,UserDao类也是如此完成。</p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231106195317962.png" class title="image-20231106195317962"><p>至此，数据方面的东西我们都已经写完了,后续只需要调用即可。</p><p>接来下就可以进行一些前后端交互逻辑的实现了。</p><p>在这以功能点为维度进行展开,针对每个功能点,进行**”设计前后端交互接口”,”开发后端代码”,”开发前端代码”,”调试”**</p><h2 id="实现博客列表页"><a href="#实现博客列表页" class="headerlink" title="实现博客列表页"></a>实现博客列表页</h2><p>让博客列表页能够加载博客列表。</p><p>大致流程如下：</p><ol><li>前端发起一个HTTP请求,向后端所要博客列表数据</li><li>后端收到请求之后查询数据库获取数据库中的 博客列表，将数据返回给前端</li><li>前端拿到响应后,根据内容构造出html片段,并显示。</li></ol><p>在写代码前,需要进行约定,即规范双方发什么样的数据,发什么请求,如何解析数据等。</p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231106205134853.png" class title="image-20231106205134853"><p>假设双方约定按照如下格式发送数据。</p><p><strong>后端代码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/html/blog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//从数据库中获取数据</span><br>        <span class="hljs-type">BlogDao</span> <span class="hljs-variable">blogDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlogDao</span>();<br>        List&lt;Blog&gt; blogs = blogDao.getBlogs();<br>        <span class="hljs-comment">//将数组转换成对象字符串</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">respJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(blogs);<br>        resp.setContentType(<span class="hljs-string">&quot;application/json; charset=utf8&quot;</span>);<br>        <span class="hljs-comment">//写回到响应中</span><br>        resp.getWriter().write(respJson);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>前端代码:</strong></p><p>让页面通过js的ajax的方式发起http请求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getBlogs</span>(<span class="hljs-params"></span>)&#123;<br>    $.<span class="hljs-title function_">ajax</span>(&#123;<br>        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>        <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;blog&#x27;</span>,<br>        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">body</span>)&#123;<br>            <span class="hljs-keyword">let</span> container = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container-right&#x27;</span>);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> blog <span class="hljs-keyword">of</span> body)&#123;<br>                <span class="hljs-keyword">let</span> blogDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>                blogDiv.<span class="hljs-property">className</span>=<span class="hljs-string">&#x27;blog&#x27;</span>;<br>                <span class="hljs-comment">//构造标题</span><br>                <span class="hljs-keyword">let</span> titleDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>                titleDiv.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;title&#x27;</span>;<br>                titleDiv.<span class="hljs-property">innerHTML</span> = blog.<span class="hljs-property">title</span>;<br>                blogDiv.<span class="hljs-title function_">appendChild</span>(titleDiv);<br>                <span class="hljs-comment">//构造发布时间</span><br>                <span class="hljs-keyword">let</span> dateDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>                dateDiv.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;date&#x27;</span>;<br>                dateDiv.<span class="hljs-property">innerHTML</span> = blog.<span class="hljs-property">postTime</span>;<br>                blogDiv.<span class="hljs-title function_">appendChild</span>(dateDiv);<br>                <span class="hljs-comment">//构造博客摘要</span><br>                <span class="hljs-keyword">let</span> descDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);<br>                descDiv.<span class="hljs-property">className</span> = <span class="hljs-string">&#x27;desc&#x27;</span>;<br>                descDiv.<span class="hljs-property">innerHTML</span> = blog.<span class="hljs-property">content</span>;<br>                blogDiv.<span class="hljs-title function_">appendChild</span>(descDiv);<br>                <span class="hljs-comment">//构造查看全文按钮</span><br>                <span class="hljs-keyword">let</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>                a.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;blog_content.html?blogId=&#x27;</span> + blog.<span class="hljs-property">blogId</span>;<br>                a.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;查看全文 &amp;gt;&amp;gt&#x27;</span>;<br>                blogDiv.<span class="hljs-title function_">appendChild</span>(a);<br><br>                container.<span class="hljs-title function_">appendChild</span>(blogDiv);<br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br><span class="hljs-title function_">getBlogs</span>();<br></code></pre></td></tr></table></figure><p>由于数据库中的数据为标明啥数据,我们还需要手动指定.</p><p><strong>效果如下:</strong></p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231107104057626.png" class title="image-20231107104057626"><h2 id="博客详情页"><a href="#博客详情页" class="headerlink" title="博客详情页"></a>博客详情页</h2><p>1.约定前后端交互接口</p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231107110814510.png" class title="image-20231107110814510"><p>和前面博客列表页类似,不同的是我们只需要在请求中带上blogId的属性,以及后端代码的稍作修改即可。</p><p><strong>后端代码:</strong></p><p><strong>我们可以通过对之前的后端代码稍作修改,就可以完成上述操作。</strong></p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231107111737769.png" class title="image-20231107111737769"><p><strong>前端代码:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script src=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.4/jquery.min.js&quot;</span>&gt;&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">getBlog</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">        $.<span class="hljs-title function_">ajax</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;blog&#x27;</span>+location.<span class="hljs-property">search</span>,</span></span><br><span class="language-javascript"><span class="language-xml">            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">body</span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-keyword">let</span> h3 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container-right h3&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                h3.<span class="hljs-property">innerHTML</span> = body.<span class="hljs-property">title</span>;</span></span><br><span class="language-javascript"><span class="language-xml">                <span class="hljs-keyword">let</span> dateDiv = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.container-right .date&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">                dateDiv.<span class="hljs-property">innerHTML</span> = body.<span class="hljs-property">postTime</span>;</span></span><br><span class="language-javascript"><span class="language-xml">                editormd.<span class="hljs-title function_">markdownToHTML</span>(<span class="hljs-string">&#x27;content&#x27;</span>, &#123; <span class="hljs-attr">markdown</span>: body.<span class="hljs-property">content</span> &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">            &#125;</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">getBlog</span>();</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h2 id="登录功能"><a href="#登录功能" class="headerlink" title="登录功能"></a>登录功能</h2><p><strong>1.约定前后端交互接口</strong></p><p>此处提交用户名和密码,可以使用form也可以使用ajax。在这使用form的形式(更简单一些)。</p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231108201859507.png" class title="image-20231108201859507"><p><strong>2.后端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/html/login&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-comment">//首先获取请求中的查询字符串中的用户名和密码</span><br>        <span class="hljs-comment">//需要手动告诉Servlet,使用什么样的编码方式来读取请求</span><br>        req.setCharacterEncoding(<span class="hljs-string">&quot;utf8&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;username&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;password&quot;</span>);<br>        <span class="hljs-keyword">if</span>(username == <span class="hljs-literal">null</span> || password == <span class="hljs-literal">null</span> || username.equals(<span class="hljs-string">&quot;&quot;</span>) || password.equals(<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            <span class="hljs-comment">//用户提交的数据非法</span><br>            resp.setContentType(<span class="hljs-string">&quot;text/html; charset=utf8&quot;</span>);<br>            resp.getWriter().write(<span class="hljs-string">&quot;当前的用户名或密码非法&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//再去数据库中比对</span><br>        <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDao</span>();<br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userDao.getUserByName(username);<br>        <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>            resp.setContentType(<span class="hljs-string">&quot;text/html; charset=utf8&quot;</span>);<br>            resp.getWriter().write(<span class="hljs-string">&quot;当前的用户名或密码错误&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(!user.getPassword().equals(password))&#123;<br>            resp.setContentType(<span class="hljs-string">&quot;text/html; charset=utf8&quot;</span>);<br>            resp.getWriter().write(<span class="hljs-string">&quot;当前的用户名或密码错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">//创建会话关系</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession(<span class="hljs-literal">true</span>);<br>        session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>        <span class="hljs-comment">//发送重定向网页,跳转到列表页</span><br>        resp.sendRedirect(<span class="hljs-string">&quot;blog_list.html&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意:</strong></p><p>由于请求中可能带有中文字符,我们需要手动指定一下字符集utf8,防止读取请求的时候出现乱码。</p><p>使用一个会话,让服务器保存当前用户的一些数据。</p><p><strong>3.前端代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;login&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>&gt;</span><br>             <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>         <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="检查用户登录状态"><a href="#检查用户登录状态" class="headerlink" title="检查用户登录状态"></a>检查用户登录状态</h2><p>强制用户登录,当用户直接去访问博客列表页或者其他页面的时候,如果是未登录过的状态,会强制跳转到登录页要求用户登录。</p><p>如何实现?</p><p>在其他页面中的前端代码,写一个ajax请求,通过这个请求,访问服务器来获取当前的登录状态。</p><p>如果当前未登录,则跳转登录页面,如果已经登录,就不进行操作。</p><p><strong>1.约定前后端交互接口</strong></p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231108210048726.png" class title="image-20231108210048726"><p><strong>2.后端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span>(session == <span class="hljs-literal">null</span>)&#123;<br>        resp.setStatus(<span class="hljs-number">403</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User) session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>    <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>        resp.setStatus(<span class="hljs-number">403</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    resp.setStatus(<span class="hljs-number">200</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.前端代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login-container&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 登录对话框 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;login-dialog&quot;</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 使用 form 包裹一下下列内容, 便于后续给服务器提交数据 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;login&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>用户名<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>密码<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;row&quot;</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登录&quot;</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>form表单中的action为请求中的url,method为请求中的方法类型,id属性时针对html获取元素,name属性则是针对form表单构造http请求。</strong></p><h2 id="显示用户信息"><a href="#显示用户信息" class="headerlink" title="显示用户信息"></a>显示用户信息</h2><p>当我们进入博客列表页的时候,用户显示的内容应该是登录用户的信息,一旦我们进入到博客详情页的时候,显示的就应该是该博客作者的信息。</p><h3 id="首先是博客列表页"><a href="#首先是博客列表页" class="headerlink" title="首先是博客列表页"></a>首先是博客列表页</h3><p><strong>1.约定前后端交互接口</strong></p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231110100206928.png" class title="image-20231110100206928"><p><strong>2.后端代码</strong></p><p>由于我们进入博客列表页,首先会去检查是否已经登录过,如果登录过就可以拿到用户的数据,此时我们可以将用户数据返回给前端,然后修改用户姓名的属性。此时我们也只要在前面代码的基础上稍加修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//防止将密码传输回去</span><br>user.setPassword(<span class="hljs-string">&quot;&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">respJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br>resp.setContentType(<span class="hljs-string">&quot;application/json; charset=utf8&quot;</span>);<br>resp.getWriter().write(respJson);<br></code></pre></td></tr></table></figure><p><strong>3.前端代码</strong></p><p>前端代码也只需要在之前的基础上稍加修改就行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkLogin</span>(<span class="hljs-params"></span>)&#123;<br>   $.<span class="hljs-title function_">ajax</span>(&#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;login&#x27;</span>,<br>    <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">body</span>)&#123;<br>        <span class="hljs-keyword">let</span> h3 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;h3&#x27;</span>);<br>        h3.<span class="hljs-property">innerHTML</span> = body.<span class="hljs-property">username</span>;<br>    &#125;,<br>    <br>    <span class="hljs-attr">error</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">body</span>)&#123;<br>        location.<span class="hljs-title function_">assign</span>(<span class="hljs-string">&#x27;blog_login.html&#x27;</span>);<br>    &#125;<br>   &#125;) ;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="然后是博客详情页"><a href="#然后是博客详情页" class="headerlink" title="然后是博客详情页"></a>然后是博客详情页</h3><p>详情页这里显示的是当前文章的作者信息,由于我们知道blogId,就可以查询到userId然后就能查询到user的信息。最后再将信息显示出来即可。</p><p><strong>1.约定前后端交互接口</strong></p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231110111836884.png" class title="image-20231110111836884"><p><strong>2.后端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ObjectMapper</span> <span class="hljs-variable">objectMapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">blogId</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;blogId&quot;</span>);<br>        <span class="hljs-comment">//如果用户直接访问博客详情页</span><br>        <span class="hljs-keyword">if</span>(blogId == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//从session中拿到user对象</span><br>            <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">if</span>(session == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">//为了方便后续统一处理,返回空对象</span><br>                <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">respJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br>                resp.setContentType(<span class="hljs-string">&quot;application/json; charset=utf8&quot;</span>);<br>                resp.getWriter().write(respJson);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">respJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br>            resp.setContentType(<span class="hljs-string">&quot;application/json; charset=utf8&quot;</span>);<br>            resp.getWriter().write(respJson);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-type">BlogDao</span> <span class="hljs-variable">blogDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlogDao</span>();<br>            <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> blogDao.getBlog(Integer.parseInt(blogId));<br><br>            <span class="hljs-keyword">if</span>(blog == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">respJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br>                resp.setContentType(<span class="hljs-string">&quot;application/json; charset=utf8&quot;</span>);<br>                resp.getWriter().write(respJson);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-type">UserDao</span> <span class="hljs-variable">userDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDao</span>();<br>            <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userDao.getUserById(blog.getUserId());<br>            <br>            <span class="hljs-keyword">if</span>(user == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">respJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br>                resp.setContentType(<span class="hljs-string">&quot;application/json; charset=utf8&quot;</span>);<br>                resp.getWriter().write(respJson);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">respJson</span> <span class="hljs-operator">=</span> objectMapper.writeValueAsString(user);<br>            resp.setContentType(<span class="hljs-string">&quot;application/json; charset=utf8&quot;</span>);<br>            resp.getWriter().write(respJson);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>3.前端代码</strong></p><p>前端代码前面博客列表页类似</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>)&#123;<br>    $.<span class="hljs-title function_">ajax</span>(&#123;<br>        <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;get&#x27;</span>,<br>        <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;user&#x27;</span>+location.<span class="hljs-property">search</span>,<br>        <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">body</span>)&#123;<br>            <span class="hljs-keyword">let</span> h3 = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;.card h3&#x27;</span>);<br>            h3.<span class="hljs-property">innerHTML</span> = body.<span class="hljs-property">username</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br><br><span class="hljs-title function_">getUser</span>();<br></code></pre></td></tr></table></figure><h2 id="用户退出功能"><a href="#用户退出功能" class="headerlink" title="用户退出功能"></a>用户退出功能</h2><p>当用户点击注销的时候,即点击了a标签,此时会触发一个get请求,服务器收到这个get请求,就可以把当前用户会话中的user对象删除。即通过代码删除之前的session对象(最好是删除映射关系,但是Servlet没有提供相应简单的API).</p><p><strong>1.约定前后端交互接口</strong></p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231110121129744.png" class title="image-20231110121129744"><p><strong>2.后端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/html/logout&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogoutServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span>(session == <span class="hljs-literal">null</span>)&#123;<br>            resp.sendRedirect(<span class="hljs-string">&quot;blog_login.html&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        session.removeAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        resp.sendRedirect(<span class="hljs-string">&quot;blog_login.html&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.前端代码</strong></p><p>只需要给a元素写个href即可。</p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231110121735665.png" class title="image-20231110121735665"><h2 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h2><p>在写博客页中,用户可以写博客标题,正文,然后点击发布即可上传数据。</p><p><strong>1.约定前后端交互接口</strong></p><img src="/2023/11/06/Servlet%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/image-20231110122120784.png" class title="image-20231110122120784"><p><strong>2.后端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;<br>    <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> req.getSession(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span>(session == <span class="hljs-literal">null</span>)&#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html; charset=utf8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">&quot;用户未登录! 无法发布博客!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> (User)session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html; charset=utf8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">&quot;用户未登录! 无法发布博客!&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    resp.setCharacterEncoding(<span class="hljs-string">&quot;utf8&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">title</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;title&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> req.getParameter(<span class="hljs-string">&quot;content&quot;</span>);<br>    <span class="hljs-keyword">if</span> (title == <span class="hljs-literal">null</span> || content == <span class="hljs-literal">null</span> || <span class="hljs-string">&quot;&quot;</span>.equals(title) || <span class="hljs-string">&quot;&quot;</span>.equals(content)) &#123;<br>        resp.setContentType(<span class="hljs-string">&quot;text/html; charset=utf8&quot;</span>);<br>        resp.getWriter().write(<span class="hljs-string">&quot;标题或者正文为空&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blog</span>();<br>    blog.setTitle(title);<br>    blog.setContent(content);<br>    blog.setUserId(user.getUserId());<br>    <span class="hljs-type">BlogDao</span> <span class="hljs-variable">blogDao</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlogDao</span>();<br>    blogDao.insert(blog);<br>    resp.sendRedirect(<span class="hljs-string">&quot;blog_list.html&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.前端代码</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blog-edit-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;blog&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 标题编辑区 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title-input&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 博客编辑器 --&gt;</span><br>        <span class="hljs-comment">&lt;!-- 把 md 编辑器放到这个 div 中 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;editor&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display: none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>11_4深夜思考</title>
    <link href="/2023/11/03/11-4%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/"/>
    <url>/2023/11/03/11-4%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、为什么坚持写代码</h1><p>首先从热爱的角度出发,我个人感觉写代码是一件简单轻松的事,当然这是相比较其他事而言,如写实验报告这种东西,麻烦又没啥用,技术上得不到一点提升,而在写代码的过程中,我能感受到思绪的流动,我感觉我在创造一个全新的东西,我能够改变世界！或许在将来的某一天,大家能用上我写的代码,用上我开发的产品。</p><p>其次我觉得写代码的这群人很酷很有意思。就如开源社区这种东西,将代码公布出来,大家能够一起学习进步,这让我想到了小时候,我想要抄别人的作业，他就死活不肯,得威逼利诱,但当别人问我要作业的时候,我会毫不犹豫的选择给他。(我觉得抄作业其实没啥,学习都是自己的事,况且也可以帮到别人,何乐而不为呢)。</p><p>最后我听说互联网行业薪资比较高,正适合我这种比较缺钱的家伙,我想要攒够一定的积蓄,然后去实现一个一个的小愿望,我想要&quot;说走就走&quot;的底气,因此钱是一个非常重要的能够让我有底气的东西。</p><h1>二、焦虑</h1><p>我真的在焦虑吗?我感觉答不上来。</p><p>自从上周打完CCPC的比赛以后,我感觉我简直弱爆了,虽然这也是早有预料了(比赛前将近一个月没写CF的算法题,每天最多就写几道笔试的题,也没有补题),在比赛中最让我记忆犹新的是M题,我想破脑袋也没想到啊,这咋和二分结合呢???好歹也写了100+的题了,二分也都非常熟悉了,可真遇到就不行了。不过也是和那些很厉害的高校去竞争,我也能安慰自己,只是对不起那些期许我的人了…（感觉每一次进行比较大的比赛或者考试都会这样）</p><p>还有我已经是一个大三的学生了,但我感觉我好像啥也不会呐,让我使用Java开发一个网站,不行，搞不定,问我一些C语言中更深奥的东西,我也答不出来,可能也就略知一二。c++亦是如此,总之什么都不精通,无法产出一个有用的东西。(不过我励志要在大学期间内写一个OJ平台,留在协会使用,我要搞一个更加偏向比赛向的OJ)。</p><p>以及我还看到了一些&quot;故人&quot;,一些&quot;曾经做过的事情&quot;,虽然嘴上说着满不在乎,但是再次见到再次想到依旧会有些触动。感觉还需要时间的沉淀才能做到无感吧~</p><p>我还总是觉得自己仿佛很厉害的样子,我会摆着比较高傲的姿态去评价一些事或者人,但是回过来一想好蠢…总是看不上这看不上那的,但我真的懂吗？这需要打一个问号。或许我需要反复强调&quot;满招损,谦受益&quot;的理念吧。</p><p>今天还想到一个东西，是否能用酒精麻痹自己???忘记烦恼的一种方式吗???没体验过&quot;醉&quot;的感觉。不过看别人醉了倒是挺好玩的…</p><h1>三、骑行or跑步</h1><p>自从上次夜袭相公山(凌晨从临桂骑到阳朔),然后第二天接着猛干阳朔遇龙河和西街之后,我感觉我好累,以后再也不会骑这么远了(大二时期的骑行318计划感觉肯定要鸽了),但是上次看到了广西自行车的世巡赛,好cool~等我有钱了我也要整一套玩玩~</p><p>我觉得跑步是一个很累的运动,但是跑完之后很爽,而且跑完之后你会感觉整个世界都很阳光,然后整个人变得也超级精神,但是跑完5km之后,也不知道是不是因为之前跑的太快了,就非常颓。我希望我接下来能坚持这个运动吧。</p><h1>四、最后</h1><p>在陈皓的博客中我见他说过不要加班熬夜,这往往会使你事倍功半，我是挺赞成这种观点的,但是每当我感觉比较焦虑难过的时候,我就会开始自闭，缩起来(像鸵鸟一样),然后通过熬夜假努力等一系列方式麻痹自己,我希望我能够自信起来，正确面对,加油吧。日子还是要一天一天过下去的,光焦虑解决不了什么…</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络原理-HTTPS</title>
    <link href="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTPS/"/>
    <url>/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTPS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在前面说到HTTP中,我们通过抓包,可以看到许多信息内容,其中往往会包含一些敏感信息,这些都是明文传输,当我们的请求被黑客或者不法分子截获后,那就很危险了,因此衍生出了HTTPS协议来对传输数据进行加密。</p><h1 id="一、加密原理"><a href="#一、加密原理" class="headerlink" title="一、加密原理"></a>一、加密原理</h1><p><strong>基本原理如下：</strong></p><p>明文 + 密钥 &#x3D;&gt; 密文</p><p>密文 + 密钥 &#x3D;&gt; 明文</p><p><strong>一般加密解密分为两种:</strong></p><p>**对称加密:**加密和解密都是使用相同的密钥。</p><p>**不对称加密:**生成一对密钥,分别为”公钥”和”私钥”,使用公钥进行加密,就得使用私钥进行解密。</p><h1 id="二、HTTPS的工作过程"><a href="#二、HTTPS的工作过程" class="headerlink" title="二、HTTPS的工作过程"></a>二、HTTPS的工作过程</h1><p><strong>要想实现安全的传输,最简单的方法就是进行加密。</strong></p><p>由于双方需要进行加密&#x2F;解密的操作,因此一方需要先生成一个密钥,传给对方,这样双方才能进行正确的数据交换。</p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTPS/image-20231031210455384.png" class><p><strong>虽然对数据进行了加密,但只要想办法拿到密钥就能还原明文了,然后就查看以及修改了。</strong></p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTPS/image-20231031210540381.png" class><p>此时黑客入侵了路由器,这样在客户端发送密钥的时候,<strong>黑客也能收到密钥</strong>,后续客户端发送的信息也都成了”明文”。</p><p>此时就<strong>需要想办法如何将密钥安全的发送给服务器</strong>呢?那就再进行加密!<strong>显然无穷无尽的进行对称加密操作是不行的，这时候就得用上非对称加密了。</strong></p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTPS/image-20231031211552314.png" class><p><strong>说明:</strong></p><p>由于<strong>非对称运算涉及的算法比较复杂,因此运算量较大,效率比较低</strong>,因此对数据进行加密往往使用对称加密的方式。而<strong>上述所使用的的非对称加密是针对对称密钥进行加密操作</strong>。</p><hr><p><strong>虽然非对称+对称加密组合已经是很无敌的配合了,但是还有一种方式可以破解</strong>。</p><p><strong>中间人攻击:</strong></p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTPS/image-20231031212840002.png" class><p>在上述过程中,<strong>黑客通过伪造一对自己的密钥</strong>,将服务器的公钥进行替换。</p><p>因此要解决上述情况<strong>需要让客户端能够确认当前收到的公钥是服务器的,而不是伪造的</strong>,这就引入了证书机制。</p><p><strong>通过一个第三方的认证机构作为担保,保证当前的公钥是有效的</strong>。</p><hr><p><strong>证书机制:</strong></p><p>服务器想要将生成的对称公钥发送给客户端,需要先去申请一个证书,然后再将证书发送给客户端。其中<strong>证书包含了网站域名、服务器的公钥、数字签名等信息</strong>。</p><p><strong>数字签名</strong>是一个类似于校验和的东西,公正机构根据服务器的域名、公钥和其他一些属性进行计算生成校验和，<strong>然后再针对生成的校验和使用公正机构的私钥进行加密。</strong></p><p>服务器将这个证书发送给客户端,客户端收到后,<strong>使用公正机构的公钥对数字签名进行解密,就能得到相应的校验和</strong>了,然后<strong>再将证书的其他属性进行校验和计算,检查出来是否和解密出来校验和一致,如果一致则说明证书是好的</strong>。</p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTPS/image-20231101170714540.png" class><p><strong>上述过程理论上能够实现”服务器将公钥安全送达客户端”,但是黑客依旧有办法~</strong></p><p>黑客可以伪造认证机构,骗客户端安装自己的公钥,这样就可以进行替换数字签名了……</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络原理-构造HTTP请求</title>
    <link href="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E6%9E%84%E9%80%A0HTTP%E8%AF%B7%E6%B1%82/"/>
    <url>/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E6%9E%84%E9%80%A0HTTP%E8%AF%B7%E6%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在实际开发过程中经常需要进行手动构造HTTP请求来进行测试。</p><p>构造HTTP请求往往使用3种方式:1)通过HTML中的form表单;2)通过JS的ajax;;3)借助一些地方工具。</p><h1 id="一、form构造"><a href="#一、form构造" class="headerlink" title="一、form构造"></a>一、form构造</h1><p>在HTML文件中这样写:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;https://www.sogou.com&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;box1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;box2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;box3&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><blockquote><p>此处的action属性描述了构造的HTTP请求的URL是什么,method属性则是描述了这个请求使用的方法。</p><p>text类型的input表示一个文本框。其中name属性则描述了请求中的查询字串的key,当在文本框中输入,此时的输入内容就是value值。</p><p>submit类型的input表示一个提交按钮,点击这个按钮就会发送这个请求。其中的value属性描述了这个按钮上的文本。</p></blockquote><p>当我们点击提交按钮的时候,就会发出一个请求。</p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E6%9E%84%E9%80%A0HTTP%E8%AF%B7%E6%B1%82/image-20231031180810240.png" class title="image-20231031180810240"><p>请求中首行如下:</p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E6%9E%84%E9%80%A0HTTP%E8%AF%B7%E6%B1%82/image-20231031180713749.png" class title="image-20231031180713749"><p>这里面的属性分别与上述form表单中的属性对应。</p><p>使用POST方法也是一样的。只不过前面查询字符串的内容会放到正文部分中。</p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E6%9E%84%E9%80%A0HTTP%E8%AF%B7%E6%B1%82/image-20231031181217322.png" class title="image-20231031181217322"><p><strong>然而form表单只能支持GET和POST方法,不能支持PUT&#x2F;DELETE&#x2F;OPTIONS等其他方法</strong>。</p><h1 id="二、ajax构造"><a href="#二、ajax构造" class="headerlink" title="二、ajax构造"></a>二、ajax构造</h1><p>ajax全称Asynchronous Javascript And XML,翻译过来就是异步js和xml,是浏览器提供的一种通过js构造HTTP请求的方式。</p><p>这里的异步指的是代码执行发送HTTP请求后,不必等待服务器响应回来就可以继续往下执行,当服务器的响应回来了,浏览器再去处理。</p><p>ajax是js提供的一组api,用起来不方便,在此就使用一个知名的第三方库jQuery进行构造请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引入jquery --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://code.jquery.com/jquery-3.6.3.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        $.<span class="hljs-title function_">ajax</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;get&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://www.sogou.com&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">success</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">body</span>)&#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ok&#x27;</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;);</span><br><span class="language-javascript">        <span class="hljs-comment">//验证异步处理</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello~&#x27;</span>);</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>说明:</strong></p><blockquote><p>$符号在js中是一个合法的变量名,$这个变量在jquery中已经定义好了,可以直接调用里面的方法。$.ajax 就是jquery中封装好的用来发起ajax请求的方法。</p><p>ajax的参数使用{}来表示。在js中{}表示的是js的对象,里面通过键值对的形式来描述。键的类型固定是string,可写可不写,值的话可以为其他任意类型。</p><p>success这个key描述的是服务器返回的响应,success的value是一个函数类型,这个函数在浏览器收到响应的时候会被自动调用。</p></blockquote><p>我们通过抓包就能看见这个http请求了。</p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E6%9E%84%E9%80%A0HTTP%E8%AF%B7%E6%B1%82/image-20231031185918339.png" class title="image-20231031185918339"><p>不过我们的浏览显示的是一片空白。只有在控制台中能看到一个Hello。</p><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E6%9E%84%E9%80%A0HTTP%E8%AF%B7%E6%B1%82/image-20231031190003271.png" class title="image-20231031190003271"><p>这是因为浏览器首先发出一个http请求,然后又由于是异步的,代码继续往下执行,在控制台上打印Hello,但又因为搜狗服务器无法正确处理我们的请求,我们就接受不到正确的响应,最终也无法打印出ok。</p><h1 id="三、postman构造"><a href="#三、postman构造" class="headerlink" title="三、postman构造"></a>三、postman构造</h1><img src="/2023/10/31/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E6%9E%84%E9%80%A0HTTP%E8%AF%B7%E6%B1%82/image-20231031192406877.png" class title="image-20231031192406877">]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Servlet的创建</title>
    <link href="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/"/>
    <url>/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Servlet在20年前是一种主力的网站开发技术,但随着时间的推移,Spring的出现逐渐代替了Servlet,学习Servlet有助于理解Spring的工作原理以及web开发。</p><h1 id="一、创建项目"><a href="#一、创建项目" class="headerlink" title="一、创建项目"></a>一、创建项目</h1><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030093433434.png" class title="image-20231030093433434"><p>创建后会出现如下文件：</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030093653543.png" class title="image-20231030093653543"><p>main文件夹存放一些业务代码。其中的java文件存放的是java代码，resources存放的是一些依赖的资源</p><p>test文件夹用来存放测试的代码。</p><p>pom.xml文件中存放的是maven项目的主要的配置文件。</p><h1 id="二、引入依赖"><a href="#二、引入依赖" class="headerlink" title="二、引入依赖"></a>二、引入依赖</h1><p>当前的代码需要使用Servlet开发,而Servlet并不是Java标准库自带的,需要让maven能够把Servlet的依赖获取过来。</p><p><a href="https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api">Maven Repository: javax.servlet » javax.servlet-api (mvnrepository.com)</a></p><p>根据自身的Tomcat版本来选择对应的servlet版本(如果Tomcat8,则使用Servlet3.1)。</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030095211632.png" class title="image-20231030095211632"><p>然后先在pom.xml文件中创建一个标签<dependencies></dependencies></p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030095404111.png" class title="image-20231030095404111"><p>然后将网页中的代码复制下来,放到这个标签里面</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030095544835.png" class title="image-20231030095544835"><p>此时IDEA就会自动拖过maven从中央仓库来下载这里的依赖，第一次使用,代码可能报错,需要耐心等待然后手动刷新一下。</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030095718953.png" class title="image-20231030095718953"><h1 id="三、创建一些必要的文件"><a href="#三、创建一些必要的文件" class="headerlink" title="三、创建一些必要的文件"></a>三、创建一些必要的文件</h1><p>按照如下创建：</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030100251957.png" class title="image-20231030100251957"><p><strong>此处的目录结构,目录名字都是固定的!!!</strong></p><p>web.xml就是告诉Tomcat,我现在这个目录里的东西就是一个webapp,你要把我加载。</p><p>在web.xml中还要写一些内容,具体内容也都是固定,复制粘贴即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">web-app</span> <span class="hljs-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-string">&quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot;</span> &gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>Archetype Created Web Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h1 id="四、编写代码"><a href="#四、编写代码" class="headerlink" title="四、编写代码"></a>四、编写代码</h1><p>首先创建一个类继承HttpServlet,然后重写父类的方法。</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030101630202.png" class title="image-20231030101630202"><p>参数req表示的是这次请求的http请求内容,resp表示的是这次请求要返回的http响应内容。</p><p>这里的doGet方法也不需要手动调用,Tomcat会在收到一个合适的GET请求时自动调用这个方法。而doGet方法需要做的就是根据这次req，计算出响应resp，tomcat就会根据这个resp转换成http协议的响应报文返回给浏览器。</p><p>前面网络编程中写的代码都是通过三步骤进行的:读取请求并解析;根据请求计算响应;把响应返回给客户端。在Servlet这一块,读请求和把响应返回客户端Tomcat都是直接完成好的,只需将业务代码写好即可。</p><p><strong>最终代码如下</strong>：</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030102914002.png" class title="image-20231030102914002"><p><strong>这里一定要加上@WebServlet注解</strong>，这样就能把当前这个Servlet子类和一个请求的路径关联(可以理解为是url中带层次的结构路径)。</p><p><strong>注意:</strong></p><p>Servlet程序不需要main方法,理论上一个程序是需要main方法入口的,但这里的代码并不是独立的程序,是放到Tomcat上执行的,main方法是在tomcat里执行的,因此这里不要再写了。</p><h1 id="五、打包程序"><a href="#五、打包程序" class="headerlink" title="五、打包程序"></a>五、打包程序</h1><p>由于我们写好的程序是放到Tomcat上运行的，我们需要手动对程序进行打包。打包成一个Tomcat能识别的包的格式,此时代码才会被Tomcat加载起来。</p><p>此处打包也是借助maven完成的。</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030105547361.png" class title="image-20231030105547361"><p>如果看到BUILD SUCCESS字样，就是打包成功了。</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030105641784.png" class title="image-20231030105641784"><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030105734295.png" class title="image-20231030105734295"><p>此处的jar包就是通过maven打包生成的内容。</p><p>在maven中默认打包生成的是jar包,<strong>但是Tomcat中需要的是war包,因此我们需要手动设置一下</strong>。</p><p>在pom.xml中手动配置：</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030110337829.png" class title="image-20231030110337829"><p>然后再进行打包,此时在target目录下就会生成一个war包。</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030110455977.png" class title="image-20231030110455977"><h1 id="六、部署"><a href="#六、部署" class="headerlink" title="六、部署"></a>六、部署</h1><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030110651032.png" class title="image-20231030110651032"><p>将这个war包复制到tomcat目录下webapps中。</p><hr><p>现在来启动一下tomcat服务器。</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030110927661.png" class title="image-20231030110927661"><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030110948120.png" class title="image-20231030110948120"><p>双击运行startup.bat脚本即可启动tomcat了。</p><h1 id="七、验证程序"><a href="#七、验证程序" class="headerlink" title="七、验证程序"></a>七、验证程序</h1><p>现在通过浏览器来发起http请求,触发刚刚的servlet代码。</p><p>在浏览器输入：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:8080</span>/HelloServlet/hello<br></code></pre></td></tr></table></figure><p>此处的url中的HelloServlet表示的是Context path,用来确定是哪一个webapp,通常就是war包的名字。</p><p>hello是Servlet path,用来确定是哪个servlet,和刚刚的@WebServlet注解对应。</p><img src="/2023/10/30/Servlet%E7%9A%84%E5%88%9B%E5%BB%BA/image-20231030115909331.png" class title="image-20231030115909331">]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络原理-HTTP协议</title>
    <link href="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>HTTP是应用层最常用到的协议,当使用浏览器打开网站或者使用手机APP加载数据,也都基本使用到了HTTP。</p><h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><p>HTTP协议全称为超文本传输协议,除了能传输字符串,还能传输图片、视频、音频等。</p><p>当我们在访问网页的时候,浏览器会从服务器上下载数据,这些数据都会放在HTTP响应中,然后浏览器再根据这个HTTP响应显示出网页信息。</p><h1 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h1><p>抓包工具本质上是一个代理工具,即我们将构造好的请求首先发送给抓包工具,抓包工具然后解析请求,然后发送给服务器,最后再将服务器的响应返回。在这使用Fiddler抓包工具。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/image-20231026095917111.png" class title="image-20231026095917111"><p>当我们打开工具会出现如下信息:</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/image-20231026100823647.png" class title="image-20231026100823647"><h1 id="认识HTTP请求-x2F-响应"><a href="#认识HTTP请求-x2F-响应" class="headerlink" title="认识HTTP请求&#x2F;响应"></a>认识HTTP请求&#x2F;响应</h1><p>HTTP请求是文本协议,不同于IP、TCP、UDP协议是二进制协议,因此我们可以通过抓包工具清楚的看出协议中的内容。</p><p>一个HTTP请求&#x2F;响应由四部分组成:<strong>首行、报头(请求头&#x2F;响应头)、空行、正文</strong>。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/image-20231026102857023.png" class title="image-20231026102857023"><h2 id="首行"><a href="#首行" class="headerlink" title="首行"></a>首行</h2><p>在请求报文和响应报文中,首行具有一定的区别。</p><h3 id="在请求报文中"><a href="#在请求报文中" class="headerlink" title="在请求报文中:"></a>在请求报文中:</h3><p>首行由<strong>方法+URL+版本号</strong>这三部分组成,中间由空格分隔。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/image-20231026201501207.png" class title="image-20231026201501207"><p><strong>方法:</strong> 方法描述的是语义,表示这次请求要干什么。例如: GET:表示从服务器获取xxx , POST: 表示想服务器传输xxx。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/0a4186518794179065b76398fe6fea1e.png" class><p>在这么多的方法里面,<strong>GET和POST方法最为常用</strong>。比如当获取网页信息的时候一般使用GET,而登录或者上传资源的时候使用POST。</p><p>虽然HTTP协议设计指出是希望程序员能够遵守这里规则,但是事与愿违,程序员不遵守也不影响,可以将一些参数放到其他位置。</p><hr><p>**URL:**资源定位符,用来描述网络上的资源,俗称网址。在URL中有特定的格式：</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/0209bb1d5fc6f2de5d8b775f60cc840c.png" class><p><strong>服务器地址</strong>可以是域名或者IP地址。</p><p><strong>带层次的文件路径</strong>表示要访问服务器上的哪个资源</p><p><strong>查询字符串</strong>也叫query string,表示访问服务器的时候带上哪些参数,使用键值对的格式,键和值之间使用&#x3D;,键值对之间使用&amp;分隔,查询字符串以?开始。虽然知道了查询字符串的格式,但是我们并不能知道里面的内容和含义,因为程序员可以自定义。</p><p><strong>片段标识符</strong>一般用在文档中,当你带上这个参数的时候,文档会直接展示那一页&#x2F;段。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/image-20231026204500191.png" class title="image-20231026204500191"><p>虽然规定了格式是这样,但是如果省略了某几个参数也不碍事。</p><p>当已经请求了当前域名的主页,此时这个主页如果又去请求当前域名的内容,此时就可以不带上域名&#x2F;ip，会默认为前面的域名。</p><p>如果端口不写,会根据协议来自动添加端口号,如http协议自动添加的就是80,https添加的就是443。</p><p>如果省略带层次的文件路径,那么就相当于访问的是根目录,通常对应到服务器的主页。</p><p>查询字符串也是可以没有的,因为可以将内容写到正文中。</p><p>总之,http是一个非常灵活的协议。</p><hr><p>**版本号:**表示当前http是啥版本,最新已经到了3.0,但是广为使用的还是1.0和1.1。</p><h3 id="在响应报文中"><a href="#在响应报文中" class="headerlink" title="在响应报文中:"></a>在响应报文中:</h3><p>响应的首行和请求相比差异就比较大了。</p><p>响应报文的首行是由<strong>版本号+状态码+状态码的描述</strong>组成。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/image-20231027114923976.png" class><p><strong>其中状态码大致有如下几类</strong>:</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/1f2a779e49ad452820c862ec1e687125.png" class><table><thead><tr><th>状态码</th><th>状态码描述</th></tr></thead><tbody><tr><td>200</td><td>表示成功</td></tr><tr><td>404</td><td>表示访问的资源不存在</td></tr><tr><td>403</td><td>表示访问的资源没有权限</td></tr><tr><td>502</td><td>表示服务器挂了</td></tr><tr><td>504</td><td>表示服务器超时了</td></tr><tr><td>302</td><td>表示重定向,会跳转到其他网站</td></tr></tbody></table><h2 id="报头-header"><a href="#报头-header" class="headerlink" title="报头(header)"></a>报头(header)</h2><p>在报头中属性是使用键值对的形式进行描述的。每一行是一个键值对,键与键之间使用逗号分隔,键与值之间使用冒号分隔。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/image-20231031123419931.png" class title="image-20231031123419931"><p>报头中的键大部分都是标准规定的:</p><p><strong>Host</strong>:表示要去访问的目标服务器的地址和端口</p><p><strong>Content-Length</strong>:表示正文的长度。(如果正文中没有内容可以不写,可以用来区分一个包的长度,解决粘包问题)。</p><p><strong>Contet-Type</strong>:正文的数据格式。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-HTTP%E5%8D%8F%E8%AE%AE/image-20231031124128570.png" class title="image-20231031124128570"><p><strong>User-Agent</strong>:主要包含的是当前机器的系统和浏览器的版本。在互联网早期的时候,由于浏览器支持的功能可能并不一样,一些可以支持视音频,一些只能支持文字,通过版本号就可以进行区分,然后返回不同的页面了。如今各大浏览器的功能都差不多了,UA往往用来区分是PC端还是移动端。</p><p>**Referer:**描述了当前的页面是从哪里跳转的。当我们在一个页面中点击了广告,跳转到了广告页面,此时广告主的服务器就能统计是从谁那边过来的,后期就可以给不同的网站结广告费了。</p><p><strong>Cookie</strong>:是浏览器本地存储数据的一种机制,用来缓存一些临时数据,当下次访问的时候节省访问时间。当浏览器再第一次访问服务器的时候,浏览器是一无所知的,因此需要加载很多的html,css,js,img东西,由于里面的有些内容可能会很久都不会变,就通过cookie保存机制将这些内容保存下来,下次就不需要再去请求了。</p><p>在cookie中使用的也是键值对的结构,并按照域名的维度区分不同网站的不同cookie。一个网站cookie会存储很对键值对,但往往会有一个很重要的键值对,用来表示用户的身份信息(当下次访问的时候就不要再登录了),为了实现身份识别的效果,服务器这边也需要一个Session机制来支持。</p><h2 id="空行"><a href="#空行" class="headerlink" title="空行"></a>空行</h2><p>空行相当于是一个分隔符,分隔了报头(header)和正文(body),也就描述了正文部分是从哪里开始的。</p><h2 id="正文-body"><a href="#正文-body" class="headerlink" title="正文(body)"></a>正文(body)</h2><p>在请求报文中的正文部分,也可以带有一些参数,用来针对资源的补充说明,起到查询字符串的作用。通常使用键值对的形式构成,其中的一些特殊符号会经过URLencode处理,而敏感信息则进行加密处理。</p><h1 id="GET方法-VS-POST方法"><a href="#GET方法-VS-POST方法" class="headerlink" title="GET方法 VS POST方法"></a>GET方法 VS POST方法</h1><p>GET方法一般是用来从服务器获取某些资源,POST方法则是用来向服务器上传某些资源。</p><p>不过这只是从语义层面来说,但在实际使用上没啥区别,可以相互替代。<strong>两者本质上没有区别,但在习惯使用上有一些区别。</strong></p><p><strong>GET 是把一些自定义的数据放到查询字符串中,正文部分通常是空的。</strong></p><p><strong>POST 是吧一些自定义的数据放到正文中,查询字符串通常是空的。</strong></p><p><strong>本质上都是传输数据,放在哪都一样</strong>,只不过放在查询字符串中用户是可见的,而放在正文中用户需要通过一定的手段才能看到。</p><hr><p><strong>注意：</strong></p><p>1、GET的长度并没有要求限制。在URL中并没有对长度进行限制,程序猿完全可以将一个很长的正文内容放置到查询字符串中。</p><p>2、POST并不一定比GET更加安全,安全指的是传输的数据不容易被截获,就算被截获了也不容易破解,POST只是将传输的数据放到了body没有更加安全一说。</p><p>3、GET是幂等的,POST不是幂等的(幂等指的是输入相同的值,每次返回的结果也都一样),虽然在RFC标准文档上这么建议设计,但是实际中就不一定采纳了，因此不能这么进行区分。例如:访问视频网站的时候,会根据实时热点进行推荐视频。</p><p>4、由于GET的不幂等,因此GET请求不一定就能被缓存,缓存的前提肯定是数据不能一直修改,因此能不能被缓存也不是两者的区别。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络原理-以太网协议和DNS协议</title>
    <link href="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%92%8CDNS%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%92%8CDNS%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、以太网协议"><a href="#一、以太网协议" class="headerlink" title="一、以太网协议"></a>一、以太网协议</h1><p>以太网协议会涉及到数据链路层和物理层。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%92%8CDNS%E5%8D%8F%E8%AE%AE/image-20231024162621522.png" class title="image-20231024162621522"><p>这里面的目的地址和源地址指的并不是IP地址,而是MAC地址(物理地址)。长度为6个字节。即最多能表示2^48 个地址,也是非常大的,足够给全球每个设备都分配一个地址,因此在网卡出厂的时候都会带有一个唯一的MAC地址,用作身份标识，所以说网络不是法外之地~</p><hr><p>那已经有了IP地址,为啥还要设计MAC地址呢?</p><p>IP地址:负责网络层的转发。</p><p>MAC地址:负责数据链路层的转发。</p><p>网络层负责的是整体的转发过程(统筹全局，视角更高),数据链路层负责的是局部转发过程(着眼当下)。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%92%8CDNS%E5%8D%8F%E8%AE%AE/image-20231024164413501.png" class title="image-20231024164413501"><p>在上图中:</p><p>IP地址关注的是主机A的地址和主机B的地址</p><p>MAC地址则先关注的是主机A的地址和中间节点1的地址,然后关注中间节点1的地址和中间节点2的地址…….</p><hr><p>以太网数据帧的类型有这么三种：</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%92%8CDNS%E5%8D%8F%E8%AE%AE/image-20231024165717671.png" class title="image-20231024165717671"><p>根据载荷中的不同数据可以分为IP数据报、ARP数据报、RAPP数据报。</p><p>一个以太网数据帧的载荷部分最大的长度也就1500字节,才1kb多,是一个非常小的数字,而这都跟设备的硬件有关。</p><h1 id="二、DNS"><a href="#二、DNS" class="headerlink" title="二、DNS"></a>二、DNS</h1><p>DNS全称域名解析系统,如果在没有DNS的情况下上网,我们需要输入以串数字,例如:192.168.10.15,这种数字的记忆方式非常不便于人们的记忆和传播,因此就使用单词来替代IP地址,例如:<a href="http://www.bilibili.com这样的方式来替代上述的数字形式.这样的方式单词格式称为域名./">www.bilibili.com这样的方式来替代上述的数字形式。这样的方式单词格式称为域名。</a></p><p>为了保证域名的唯一性,域名往往是分级的。例如上述的域名,其中com是一级域名,bilibili是二级域名,www是三级域名,而域名的方式显然是给人看的,在底层会将其转化为IP地址。</p><p>**早期的DNS是一个文件(hosts文件),**每个域名都会对应一个IP地址,一旦新网站出现,就得去修改这个文件(hosts文件),可世界上每天有那么多网站被创建和销毁,并且又有那么多主机上的hosts文件需要修改,因此就使用了一个DNS服务器来解决。</p><p>每当创建一个新的网站都需要想这个DNS服务器去报备一下,后续客户端通过先访问DNS服务器查询到IP地址再去访问要去的地方。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BB%A5%E5%A4%AA%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%92%8CDNS%E5%8D%8F%E8%AE%AE/image-20231024171611705.png" class><p>全世界那么多主机都要上网,DNS服务器如何承受这么大的请求量?——开源节流</p><p>1、每个电脑上再域名解析的时候进行缓存,下次访问的时候可以先看看缓存中有没有</p><p>2、全世界会搭建很多的”DNS镜像服务器”并从美国的DNS服务器同步数据</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络原理-IP协议</title>
    <link href="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-IP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-IP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、IP协议报头"><a href="#一、IP协议报头" class="headerlink" title="一、IP协议报头"></a>一、IP协议报头</h1><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-IP%E5%8D%8F%E8%AE%AE/image-20231024091920655.png" class title="image-20231024091920655"><ol><li><strong>版本号</strong>:用来表示IP协议的版本,现在常用的IP协议有两个版本,IPv4和IPv6，其他版本可能只存在于实验室中，并没有被广泛的使用。</li><li><strong>首部长度</strong>:用来表示IP报头的长度,因为存在”选项”字段，所以IP报头是可变长的,此处单位为4个字节。取值范围:20-60字节。</li><li><strong>服务类型</strong>:虽然有8位但是真正只有4位才有效,用来表示IP协议的4工作模式:最小延时、最大吞吐量、最高可靠性、最小成本,四种模式互斥,只能切换到一种模式。虽然IP协议支持这个机制,但在实际中很少用到。</li><li><strong>总长度</strong>:表示的是整个IP数据报的长度,即IP报头长度+载荷的长度。这里的总长度使用了16bit，只能表示到64kb的数据,所以当携带的数据比较多的时候，IP协议会自动将数据报拆成多份，而数据到了接收方又会进行合并操作。</li><li><strong>标识+标志位+片偏移</strong>:用来帮助IP协议正确拆包组包。当IP的载荷数据比较多的时候，会进行拆包，而同一个数据报中多个包的标识是相同的，然后再根据包的先后顺序进行片偏移的赋值。其中的标志位，一共3bit，一位不作使用，一位用来表示是否允许拆包，还有一位用作”结束标记”，判断是否为最后一个包。</li><li><strong>生存时间(TTL)</strong>:表示一个数据包在网络上最多被转发多少次，每经过一个中间节点就减1，比如有一个TTL的初始值为32,在经过32次转发后就会减为0，此时这个数据包就会被丢弃，表示不可达。</li><li><strong>协议</strong>:表示上层使用的是哪种协议。</li><li><strong>首部校验和</strong>:检验IP协议数据包的头部是否出现错误,后面的载荷为TCP&#x2F;UDP,可以自己检验。</li></ol><h1 id="二、IP地址"><a href="#二、IP地址" class="headerlink" title="二、IP地址"></a>二、IP地址</h1><p>在网络的世界中有许多的主机，彼此之间要使用IP地址找到对方才能通信，因此每个IP地址原则上是不能重复的。而所谓的IP地址本质上是一个32位的整数。不过为了便于叙述与记忆往往会使用点分十进制表示。</p><p>32位能表示的数据量是有限的，大约为42亿，随着网络的迅速发展，上网的设备越来越多已经超出了32位能表示的范围了,如何解决32位IP地址不够用呢?</p><h2 id="DHCP-动态分配IP"><a href="#DHCP-动态分配IP" class="headerlink" title="DHCP(动态分配IP)"></a>DHCP(动态分配IP)</h2><p>通过使用类似分时复用的方式,当主机需要上网的时候进行分配一个IP地址，不需要就先不分配，这种方式无法改变总量，只能缓治(你咋确定不会正好有42亿人一起上网呢?)。</p><h2 id="NAT机制-网络地址转换"><a href="#NAT机制-网络地址转换" class="headerlink" title="NAT机制(网络地址转换)"></a>NAT机制(网络地址转换)</h2><p>NAT机制本质上是使用了IP地址的复用，将网络分为了两大类，一类为内网，另一类为外网。外网之间可以直接通信，而内网之间不可以。</p><p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-IP%E5%8D%8F%E8%AE%AE/Users/11834/AppData/Roaming/Typora/typora-user-images/image-20231024111522964.png" alt="image-20231024111522964"></p><p>由于内网可以复用，因此就会出现两台不同的主机的IP地址相同的情况，此时要通信的话，需要借助外网。</p><p><strong>大致流程如下:</strong></p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-IP%E5%8D%8F%E8%AE%AE/image-20231024113917143.png" class title="image-20231024113917143"><p>在发送的过程中,每经过一个路由器的时候就会触发NAT机制，路由器会将自己IP地址替换到当前IP数据报的源IP地址，因此接收端也无法知道这个数据报是源自哪的，只知道是上一级交付的。对于每一个带有NAT机制的路由设备也都会使用一个映射表来维护对应关系，这样当一个数据报过来之后，通过查表就知道发给谁了。</p><p>在NAT机制下，一个外网IP代表的不一定是一个设备了，而是很多很多设备，但是NAT也有非常明显的缺点：</p><p>非常繁琐，不方便直接访问局域网设备，需要多层路由转发才能访问另一个局域网中的设备。</p><p>虽然NAT进一步提高了利用率，但是也没有从根本上解决问题，但为啥还是在当今广泛使用呢？这是因为NAT是一个纯软件实现的方案，开发商只需要更新一下软件，这样就能大大降低成本。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6算是从根本上解决了IP地址不够用的问题。因为IPv6增长到了16个字节，128位，其能表示的数据范围相当于能给地球上的每一粒沙子都分配一个IP地址。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-IP%E5%8D%8F%E8%AE%AE/image-20231024152047060.png" class title="image-20231024152047060"><p>但是IPv6并没有发展起来,这是因为IPv4使用的是4个字节,因此两个协议无法兼容，要想升级IPv6就得更换硬件，但这并不会提高网速,用户也就感知不到,运营商也就赚不到钱……</p><p>更多知识可参考:<a href="https://www.bilibili.com/video/BV1i14y157YV/?spm_id_from=333.788">https://www.bilibili.com/video/BV1i14y157YV/?spm_id_from=333.788</a></p><h2 id="IP地址组成"><a href="#IP地址组成" class="headerlink" title="IP地址组成"></a>IP地址组成</h2><p>IP地址由两部分组成:<strong>网络号+主机号</strong>。</p><p><strong>网络号</strong>:<strong>标识网段</strong>,保证相互连接的两个网段具有不同的标识。</p><p><strong>主机号</strong>:<strong>标识主机</strong>,同一网段内,主机之间具有相同的网络号,但是主机号必须不同。</p><hr><p>那么如何区分网络号和主机号呢？使用<strong>子网掩码</strong>。</p><p>子网掩码和IP地址一样，也是4个字节，32位的整数，但是子网掩码要求,左侧必须为连续的1，右边必须为连续的0，即0和1不能穿插出现。其中1的范围就描述了IP地址的网络号，0的范围则是主机号。</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-IP%E5%8D%8F%E8%AE%AE/image-20231024153559056.png" class title="image-20231024153559056"><p>这里就表示前23位为网络号，后9位为主机号。</p><p>子网掩码是现代的一种划分网络号的办法，上古时期还有一种：</p><img src="/2023/10/24/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-IP%E5%8D%8F%E8%AE%AE/image-20231024154054368.png" class title="image-20231024154054368"><h2 id="特殊的IP地址"><a href="#特殊的IP地址" class="headerlink" title="特殊的IP地址"></a>特殊的IP地址</h2><p>1.IP地址中的主机号全部位0,就成了网络号。</p><p>2.IP地址中的主机号全部设为1,就成了广播地址。例如:192.168.0.255,子网掩码:255.255.255.0,此时这个地址就是广播地址了,往这个地址发送UDP(TCP无法和广播地址握手)数据报,那么这个局域网中所有设备都会接收到。</p><p>3.127.*的IP地址用于本机环回地址,通常为127.0.0.1。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络原理-UPD和TCP</title>
    <link href="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在传输层中有两个非常重要的协议，UDP和TCP，现在就来研究一下这两个协议。</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231018103719412.png" class title="image-20231018103719412"><p>我们观察可以发现，里面UDP报文长度为2个字节，那么是多少呢？我们需要快速反应如下固定字节数据类型的取值范围：</p><table><thead><tr><th>字节大小</th><th>有无符号</th><th>取值范围</th></tr></thead><tbody><tr><td>1个字节</td><td>有符号</td><td>-128-127</td></tr><tr><td>1个字节</td><td>无符号</td><td>0-255</td></tr><tr><td>2个字节</td><td>有符号</td><td>-32768-32767</td></tr><tr><td>2个字节</td><td>无符号</td><td>0-65535</td></tr><tr><td>4个字节</td><td>有符号</td><td>-21亿-21亿</td></tr><tr><td>4个字节</td><td>无符号</td><td>0-42亿</td></tr></tbody></table><p>**源端口:**2个字节，无符号，取值0-65535.</p><p>**目的端口:**2个字节，无符号，取值0-65535.</p><p>**UDP报文长度:**2个字节，无符号，取值范围0-64k，也就是说一个UDP最多能传输64kb的数据，这在当今是一个很小的数字(现在一个文件动不动就几个G).</p><blockquote><p><strong>说明：</strong></p><p>能否将这个长度变大呢？理论上可以，但是几乎无法做到。</p><p>理论上，我们只需要修改系统内核中udp的参数，将unsigned short改成int就可以增加长度，但是我们不能只修改自己电脑的，我们还得修改别人的，怎么说每个人都改呢???</p><p>不过我们还可以将数据拆分成多组进行传输或者使用tcp代替udp，tcp没有报文长度限制。</p></blockquote><p>**校验和:**使用了一种简单粗暴的校验算法，把UDP数据报中的每个字节都依次进行累加。</p><blockquote><p><strong>说明：</strong></p><p>为什么要使用校验和呢？因为网络传输本质上是光信号&#x2F;电信号传输，会受到磁场，高能粒子的干扰，就有可能使传输的数据突变，即0变1，我们需要使用校验和来确保传输的数据没有变化。</p><p>一般UDP中校验和是将数据报中每个字节都累加，可能会溢出，但是不要紧，当接收方收到数据了后，再按照同样的方式进行累加，如果得到值一样，就是正确的。万一前面的字节值变小了，后面的变大了，一加一减没变，又该如何应对？这种情况是可能出现，但是概率极低，毕竟工程上有一些误差也能接受。</p></blockquote><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h2><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/format,png-20230309230534096.webp" class><p>**序列号:**给传输的数据进行编号。发送方每发送一次数据，序列号的值就累加一次该数据字节数的大小，可以用来解决乱序的问题。</p><blockquote><p>乱序问题：</p><p>为了追求效率，数据会被进行分组，例如有一个2000字节的数据包，被分为两组1-1000、1001-2000，从A端发送到B端，但网络的路径非常多，这两组数据可能会走不同的路线，又因为每个路由器&#x2F;交换机的繁忙程度不一样，转发的过程也就不一样，因此就不能保证先发先至了，此时我们需要搞清楚哪个数据在前，哪个数据在后，就可以根据序列号来确定。</p></blockquote><p>**确认应答号:**用在接收方，表示期望下一次接受的数据的序列号，发送方收到这个确认应答号可以认为在这个序号前的数据都被接收了，用来解决丢包问题。</p><blockquote><p>丢包问题：</p><p>由于网络的结构复杂，某一时刻某一路由器&#x2F;交换机数据量非常多，就导致了设备非常繁忙，数据处理的排队时延会很大，此时就有可能采取丢弃策略，就产生了丢包现象，那为了知道丢了哪些包，需要通过确认应答号告诉对方，哪部分的数据没有收到。</p></blockquote><p>**首部长度:*<em>表示的是TCP报头的长度。TCP报头的前20个字节是固定的，选项部分可以有也可以没有，因此TCP报头的长度是可变的，取值范围为：0</em>4byte ~ 15 * 4 byte。</p><p>**保留位:**暂时不用，为以后升级留下空间。</p><p><strong>标志位:</strong></p><ul><li>ACK：该位为1时，表示确认应答的为有效字段。</li><li>RST：该位为1时，表示TCP连接中出现异常必须强制断开连接。</li><li>SYN：该位为1时，表示希望建立连接，并在设置序列号字段的初始值。</li><li>FIN：该位为1时，表示不会有数据发送，希望断开连接。</li></ul><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>由于TCP中很多特性，在这列举比较熟知的。</p><h3 id="一、确认应答"><a href="#一、确认应答" class="headerlink" title="一、确认应答"></a>一、确认应答</h3><p><strong>确认应答是保证”可靠性“最核心的机制</strong>。</p><p>确认应答就是告诉对方我收到消息了。发送方发出一个数据包，如果接收方收到了，就返回一个数据包告诉发送方我收到了。</p><p>确认应答机制往往配合着确认序号与ACK标志位使用。当ACK标志位为1时，确认序号为有效值，此时这条报文就是一个应答报文，告诉发送方我这边收到了，发送方可以根据确认序号看看有没有丢包的情况。</p><h3 id="二、超时重传"><a href="#二、超时重传" class="headerlink" title="二、超时重传"></a>二、超时重传</h3><p>由于网络的情况非常复杂，避免不了出现一些丢包的现象，那又该如何处理呢？此时可以大致分为两类情况，一种是发送端发送的数据包丢了，另一种是接收端的应答数据包丢了。</p><p><strong>情况一：</strong></p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231019122221950.png" class title="image-20231019122221950"><p>如果是发送端发送的数据包丢了，此时发送端就一直接收不到ACK数据包，我们可以通过设置一个超时时间，即过了这个时间还没有收到ACK的话，就再发一次数据包。</p><p><strong>总的来说就是没收到应答，就再发一次。</strong></p><p><strong>情况二：</strong></p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231019122410885.png" class title="image-20231019122410885"><p>如果是接收端已经收到了这个数据，但是应答报文丢了，此时发送端无法区分是否是第一种情况，所以还是会进行重传，接收端就需要进行去重操作。然后再次发送一个应答报文。</p><blockquote><p>如何去重？</p><p>使用序列号作为判定的依据。tcp会在内核中给每个socket对象都安排一个内存空间，相当于一个队列，收到的数据就会被放到这里面，并按照序号排列好(还解决了乱序的问题)，当来了一个重复的数据以后，就可以根据索引值判断是否出现过了。</p></blockquote><hr><p>丢包本质上是一个概率事件，不可避免，而且随着重传的次数，概率会大幅降低。我们需要合理的设置超时时间。</p><p>具体数值可以手动配置，我们更应该去关注里面的策略。</p><p>超时时间不是一个固定的值，会随着超时轮次增加。如果好几次都没重传成功的话，说明此时网络本身的丢包率非常高，可能遇到了非常严重的故障，需要拉长一下重传时间，给网络恢复留有一个时间。超时重传的轮次也不是无限的，达到一定次数就会尝试重置tcp连接，设置RST标志位，如果RST报文也丢了，说明此时网络严重故障，那就会放弃连接。</p><h3 id="三、连接管理"><a href="#三、连接管理" class="headerlink" title="三、连接管理"></a>三、连接管理</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>TCP是面向连接的协议，所以使用TCP前必须先建立连接，而连接的建立是通过三次握手来进行的。不过三次握手本质上是”四次握手”，只是将其中的两步合并成了一步。</p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231019151651878.png" class title="image-20231019151651878"><p>ACK是应答报文，SYN是同步报文，表示申请建立请求。</p><hr><h4 id="为什么要进行三次握手？"><a href="#为什么要进行三次握手？" class="headerlink" title="为什么要进行三次握手？"></a>为什么要进行三次握手？</h4><p><strong>1、验证通信路径是否通畅，双方的发送和接受能力是否正常</strong></p><p>TCP要想保证可靠传输，就得先知道有没有路径以及路径是否通畅(<strong>网络拥堵会出现历史连接原因，造成资源的浪费</strong>)，然后通过三次握手，确定双方是否有发送和接受的能力。<strong>只有确定了双方都有接收和发送的能力，才能进行后续的可靠传输。</strong></p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231019172850965.png" class title="image-20231019172850965"><p><strong>2、协商必要的参数</strong></p><p>通信的时候会涉及到一些参数，比如序列号。由于网络是时刻变化的，会出现先发后至的现象，这时我们可以通过序列号来判断这个消息是不是合法的，即可能这个数据是上一次的连接中的。</p><hr><p><strong>那是否可以只进行两次握手呢？四次是否可以？</strong></p><p>如果值进行两次握手的话，B端就无法知道A端能否接受数据，以及自己的数据有没有发过去，也就无法保证参数进行了协商，即不能保证双方的序列号是同步，并且如果出现了网络较为拥塞的时候，建立连接的消息重发了好几次，服务器在第一次握手的时候就会建立连接，即创建了一个socket对象，造成了资源的浪费。</p><p>如果是进行四次握手的话，本质上就是将三次握手的第二次握手拆开来，而三次握手就可以建立可靠的连接了，多了反而也会浪费资源。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>在进行通信后，由于前面的连接会消耗资源，因此我们还需要进行断开连接来释放资源。由于断开连接涉及到了四次通信，因此也被称为是四次挥手。</p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231021105019483.png" class title="image-20231021105019483"><p>四次握手能变成三次握手吗？理论上是可以的,当我们调用socket.close方法足够快的时候，即收到关闭请求的后续没啥业务逻辑,就可以合并。但是一般服务器后续还有很多的收尾工作要处理,这时候close方法执行的时机比较慢，就不能合并了。</p><p><strong>丢包问题</strong></p><p>由于网络通信的复杂，可能会出现丢包，这时候怎么办呢?</p><p>一个原则，收不到回应就重传，重传多次还收不到，那就单方面断开连接。</p><p>如果第一次挥手丢了，那么就重传，一直收不到回应就断开连接。</p><p>如果第二次挥手丢了，由于客户端无法区分，客户端会重传FIN报文，跟第一次挥手丢了同理。</p><p>如果第三次挥手丢了，重传，一直收不到回应，就断开连接。</p><p>如果第四次挥手丢了，此时站在客户端的角度，客户端收到了服务器的FIN报文并已经发出ACK报文确认了，但是客户端还不能立马释放连接，因为还不能确定服务器是否收到，因此会等待一个2*MSL的时长，在此期间没收到重传的FIN报文，就可以释放连接了。如果丢包了，服务器会重传FIN报文，客户端也就可以回应ACK报文了。</p><h3 id="四、滑动窗口"><a href="#四、滑动窗口" class="headerlink" title="四、滑动窗口"></a>四、滑动窗口</h3><p>滑动窗口机制是用来提高TCP的传输效率，让TCP在保证可靠的前提下，效率别要太低。虽然滑动窗口能提升TCP的效率，但是这也是有限的，还是不可能比UDP高。</p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231021114320285.png" class title="image-20231021114320285"><p>本质就是节省了应答时间。之前是每发一次数据就需要等待一个确认报文的时间，使用滑动窗口后，可以在等待确认报文的时间内，再多发几次数据。</p><hr><p><strong>丢包问题</strong></p><p>在发数据的时候，丢包情况分为两种:1)数据报了 2)确认应答(ACK)丢了</p><p><strong>1)数据丢了</strong></p><p>由于前面的确认应答机制，我们TCP协议中的确认序号字段会记录当前发到哪个数据了，如果前面某一个数据丢了，确认序号不会改变，依旧和上一次应答的确认序号是一样的，后面客户端连续收到了服务器索要的相同确认序号的数据时，客户端就明白了丢了哪部分数据，然后就可以进行重传。</p><p><strong>2)确认应答丢了</strong></p><p>确认应答丢了并不要紧，只要后续确认应答的序号比前面确认应答的序号大的话，就可以理解为，前面的数据都已经接收到了,如果所有ACK都丢了，说明网络出现了重大故障，此时也不满足网络可靠的前提条件了。</p><h3 id="五、流量控制"><a href="#五、流量控制" class="headerlink" title="五、流量控制"></a>五、流量控制</h3><p>流量控制是作为滑动窗口的补充，理论上滑动窗口越大，传输效率就越高，但是当窗口大小达到一定程度后，接收方可能就处理不过来了，或者说网络传输上的某条链路就处理不过来了，这样就会出现丢包，就得进行重传，结果适得其反了。因此我们需要进行流量控制，让发送方慢一点~</p><p>流量控制就是根据接收方的接收能力，来限制发送方的速度，即限制窗口大小。当接收方接收数据的时候，会先将数据存储在缓存区中，因此可以是用缓存区中的剩余空间大小来作为窗口的大小，即修改TCP的中窗口大小字段。</p><p><strong>大致流程:</strong></p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231021122404214.png" class title="image-20231021122404214"><p>首先客户端先发送一下数据，看看窗口大小多少合适，然后根据窗口大小发送数据，当窗口大小为0的时候就不发数据，期间会发送窗口探测包，来询问服务器啥时候有空？一旦发现不是0了以后，就继续开始发数据。这样接收方可以根据窗口大小来限制发送方的传输速度了。</p><h3 id="六、拥塞控制"><a href="#六、拥塞控制" class="headerlink" title="六、拥塞控制"></a>六、拥塞控制</h3><p>上述的流量控制是针对接收方的处理能力来判断当前的窗口大小，但是由于在传输的过程中会经过许多节点(路由器&#x2F;交换机),那么这些中间节点的处理能力是否能达到窗口大小呢？</p><p>由于路过哪些节点，在一开始的时候是无法确定的，因此设计TCP的大佬们选择使用”实验”的方式来测试路径节点的接收能力,然后综合分析计算得出一个值，后续再发送数据的速度就不应该超过这个值(木桶效应)。</p><p>拥塞控制具体是这样展开的:</p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/8a7f369d10830e939fc554332812a766.png" class title="img"><p>1.慢启动:刚开始通信的时候使用一个小窗口,如果传输顺利,没有丢包就会进行扩大窗口。</p><p>2.指数增长:在传输顺利后,拥塞窗口大小就会指数增长。</p><p>3.线性增长:当指数增长到一个阈值的时候,就会从指数增长转变为线性增长。</p><p>4.拥塞窗口回归小窗口:在窗口增长的过程中,如果传输过程中出现丢包了,说明此时发送的速率接近当前网络的极限，此时会把窗口调整为最初的小窗口并将指数增长的阈值变小，然后继续重复上述的过程。</p><p>因此还可以得出一个结论:实际发送的窗口大小不光要考虑接收方的处理能力，还要考虑中间节点的处理能力。</p><p><strong>实际发送方的窗口&#x3D; min (拥塞窗口, 流量控制窗口)</strong></p><h3 id="七、延时应答"><a href="#七、延时应答" class="headerlink" title="七、延时应答"></a>七、延时应答</h3><p>延时应答也是为了增大滑动窗口的大小,从而挺高传输效率而提出的。</p><p>延时应答通过在返回ACK应答报文的时候,尽量慢一点,利用拖延出来的一点点时间,让接收方多处理一些数据,这样接收方的接收缓冲区的空间就更大了，下一次就能接收更多的数据。</p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231023175050710.png" class title="image-20231023175050710"><h3 id="八、捎带应答"><a href="#八、捎带应答" class="headerlink" title="八、捎带应答"></a>八、捎带应答</h3><p>捎带应答是在延迟应答的基础上，引入的进一步提高效率的方式。</p><p>延迟应答是让ACK报文传输的时机更慢，我们不仅可以让接收方利用这段时间处理缓存中数据，还可以让接收方做出响应的同时再带上ACK报文(类似将四次握手合并成三次握手)。</p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231023193257867.png" class title="image-20231023193257867"><p>之前所提到的四次挥手也有可能变成三次，主要是通过延时应答和捎带应答完成的。在第二挥手的时候进行延时应答，然后跟第三次挥手一起发送给对方，而数据包从两个合并成一个，效率会有明显的提升，因为每次传输数据都会进行封装分用以及传输时延都会花费不少时间。</p><h3 id="九、面向字节流——粘包问题"><a href="#九、面向字节流——粘包问题" class="headerlink" title="九、面向字节流——粘包问题"></a>九、面向字节流——粘包问题</h3><p>由于TCP是面向字节流的，所接收到的数据包会按照一个字节一个字节的存储在缓存区中，如果我们不认为的进行约定，那么就无法区分一个数据的结尾是哪。</p><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231023202340577.png" class title="image-20231023202340577"><p>如上所示:</p><p>对于发送方来说,发送了3个数据报，AAA为一个应用层数据报,BBB是一个应用层数据报,CCC是一个应用层数据报，但是接收方可区分不了,三个数据报都粘在一起了，很有可能后续会理解错发送方的意思,比如将这三个数据包理解为了AAAB, BBC, CC，就出现了bug。</p><p><strong>此时就只能在应用层面来处理这个问题了</strong>。如：</p><ol><li>在应用层协议中引入分隔符区分包之间的边界。例如：以\n作为一个数据包的结束标志。</li><li>在应用层协议中引入包长度区分包之间的边界。</li></ol><h3 id="十、异常情况处理——心跳包"><a href="#十、异常情况处理——心跳包" class="headerlink" title="十、异常情况处理——心跳包"></a>十、异常情况处理——心跳包</h3><p>在实际生活中，会出现许多不可抗力的因素，比如电源被家长关了、网线被人拔了等，不过这些大差不差，可以分为四大类。</p><p>1、<strong>进程崩溃</strong></p><p>当进程崩溃了，进程所持有的PCB中的文件描述符表也就被释放了，即相当于调用了socket.close方法，崩溃的一方在内核中就会发出FIN，就变成了四次挥手了，此时也就和进程的正常退出没啥区别了。</p><p>2、<strong>主机关机</strong></p><p>电脑在正常关机的时候，会先结束掉所有的进程，后续就跟进程崩溃的处理一样了(如果没挥手完也没关系 ,也就演变成了丢了某一次挥手)。</p><p>3、<strong>主机掉电</strong></p><p>如果是台式机的话，一旦拔掉电源，电脑就立马黑屏了，根本不会给操作系统留有反应的空间。此时又分为了两种情况：</p><p>a) 如果接收方突然断电了,那么发送方就无法接收到ACK,此时发送方会进行超时重传，如果一直重传失败,就会发送复位报文(RST)，尝试重置连接，如果失败了，就会单方面释放连接了。</p><p>b)如果发送方突然断电了,接收方无法区分发送方是等一会发送呢，还是不发了，此处就会涉及到”心跳包”,接收方就会周期性的给对方发一个不携带任何业务数据的tcp数据报，发起这个这个包的目的，就是为了触发ACK确认对方是否正常工作。</p><p>4、<strong>网线断开</strong></p><p>如果是网线断开的话，其实也跟主机掉电基本类似。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络原理-自定义协议</title>
    <link href="/2023/10/17/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/17/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>应用层是借助传输层提供的服务来实现自己的功能的，在应用层存在许多现成的协议，不过，很多时候程序猿也可以自定义协议，那协议究竟是什么？</p><h1 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h1><p>在这引入一个场景：在B站上搜索英雄联盟。</p><p>在这我们的请求是：英雄联盟，而服务器的响应是一大堆视频和比赛咨询信息啥的。</p><p>在这之间发生了什么呢？**首先我们需要知道，我们的代码中包含了各种各样的对象，当我们传输数据的时候需要将其进行序列化，将其变为文本数据或者二进制数据才能传输(简单理解将对象变为一个字符串)**。在我们输入”英雄联盟”的时候，客户端会将”英雄联盟”这个字符串按找某种协议的格式，重新组织，例如转换成”请求:英雄联盟\n”,然后发送给了服务器,此时服务器根据协议(例如:规定了从冒号后面开始读取,然后以\n为结尾)进行解析这个字符串,就得到了”英雄联盟”,之后计算响应,将一大堆视频信息组织整理,例如转换成”响应:视频1,xxxx;视频2,xxxx”，此时客户端再根据协议约定来解析这个响应，提取出里面的信息。</p><p><strong>总得来说，协议就是用来规定通信数据的格式、包含哪些信息，通信双方得遵守这个协议，才能读懂对方的意思</strong>，举个例子，我们都知道GBK编码后的中文字符，然后使用utf8来解读的话，会出现乱码，这就是因为双方没有遵守协议~ <strong>协议的具体格式可以非常灵活，但是要表征通信双方都使用相同的规则!!!</strong></p><h1 id="一些大佬的协议"><a href="#一些大佬的协议" class="headerlink" title="一些大佬的协议"></a>一些大佬的协议</h1><p>虽然说自定义格式可以是任意的，但是为了避免出现离离原上谱的设计方式，大佬门就搞出了一些”通用的协议格式”,我们可以参考这些格式。</p><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><p>xml是以成对的标签，来表示”键值对”信息，和html长的差不多，不过<strong>xml中的标签是程序猿自己定义的</strong></p><p><strong>例如：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">request</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">userId</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">userId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">request</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>优点：xml能非常清晰的把数据结构化表示出来。</strong></p><p><strong>缺点：表示数据需要引入大量标签，比较繁琐，传输的数据也多，会占用不少带宽。</strong></p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>json本质上也是”键值对”,相比xml更简洁一些，使用{}表示键值对。json是当前主流使用的一种网络传输数据的格式，其对换行并不敏感，在传输的时候会对json进行压缩,去掉不必要的换行来降低带宽(会影响可读性)。</p><p><strong>例如：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Zhangsan&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hobbies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;sleep&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;read&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>优点：相比xml，数据简洁，可读性好。</strong></p><p><strong>缺点：依旧需要花费一定的带宽来传输”键”的数据。</strong></p><h2 id="protobuffer"><a href="#protobuffer" class="headerlink" title="protobuffer"></a>protobuffer</h2><p>protobuffer是谷歌提出的一套二进制的数据序列化方式。使用二进制的方式，约定某几个字节，表示什么什么属性，不必传输”键”的数据，通过位置和长度来区分每个属性。我们需要使用一个proto文件来编写，然后使用protobuf编译器将其转换。</p><p><strong>优点：不用传输”键”，节省带宽，最大化效率。</strong></p><p><strong>缺点：二进制数据，无法肉眼观察，使用比较复杂。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-网络编程</title>
    <link href="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、UDP-Socket编程"><a href="#一、UDP-Socket编程" class="headerlink" title="一、UDP Socket编程"></a>一、UDP Socket编程</h1><p>由于<strong>UDP是面向数据报</strong>的,我们需要用一个类来表示数据包,即DatagarmPacket.</p><h2 id="DatagramPacket-API"><a href="#DatagramPacket-API" class="headerlink" title="DatagramPacket API"></a>DatagramPacket API</h2><p><strong>构造方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int length)</td><td>构造一个DatagramPacket来<strong>接收数据报</strong>,数据存储在buf数组中，长度为length.</td></tr><tr><td>DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)</td><td>构造一个DatagramPacket来发送数据报,发送的数据是从buf数组的offset位置开始往后length长度的数据，address指定目的ip和port</td></tr></tbody></table><p><strong>成员方法:</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>SocketAddress getSocketAddress()</td><td>返回SocketAddress,一般是ip+port</td></tr><tr><td>int getPort()</td><td>返回port</td></tr><tr><td>InetAddress getAddress()</td><td>返回ip地址</td></tr><tr><td>byte[] getData()</td><td>获取数据包中的数据</td></tr></tbody></table><h2 id="DatagramSocket-API"><a href="#DatagramSocket-API" class="headerlink" title="DatagramSocket API"></a>DatagramSocket API</h2><p>我们为了是层间传输的数据更小，就引入了Socket，我们需要使用Socket来表示一些特定的信息.如UDP的Socket本质上是一个整数，用来代表的一端的会话关系。</p><p><strong>构造方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>一般是在客户端使用,创建一个UDP的Socket，端口号由系统分配</td></tr><tr><td>DatagramSocket(int port)</td><td>一般是在服务器端使用,创建一个UDP的Socket，端口号手动分配</td></tr></tbody></table><p><strong>成员方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>void receive(DatagramPacket p)</td><td>此处的p是返回型参数，将收到的数据报放到p中,如果没有接受到,会阻塞等待</td></tr><tr><td>void send(DatagramPacket p)</td><td>将数据报p发送</td></tr></tbody></table><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231013110641383.png" class title="image-20231013110641383"><h2 id="简单通信程序"><a href="#简单通信程序" class="headerlink" title="简单通信程序"></a>简单通信程序</h2><p>在这里我们实现一个简单的UDP客户端&#x2F;服务器通信程序，这个程序中没啥业务逻辑，是一个回显服务器，服务器收到客户端的字符串后，原封不动的返回即可。</p><p><strong>UDPEchoServer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><span class="hljs-keyword">import</span> java.net.SocketException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpEchoServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//手动指定服务器的端口号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UdpEchoServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> SocketException &#123;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(port);<br>    &#125;<br><br>    <span class="hljs-comment">//通过start方法来启动服务器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器启动!&quot;</span>);<br>        <span class="hljs-comment">//服务器一般都是7*24小时运行着</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//1.读取请求并解析</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">requestPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>], <span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">//服务器没收到请求的话就会在这阻塞等待</span><br>            socket.receive(requestPacket);<br><br>            <span class="hljs-comment">//2.根据请求计算响应</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(requestPacket.getData(), <span class="hljs-number">0</span>, requestPacket.getLength());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> process(request);<br><br>            <span class="hljs-comment">//3.将响应发送给客户端</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">responsePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(response.getBytes(), <span class="hljs-number">0</span>, response.getBytes().length, requestPacket.getAddress(), requestPacket.getPort());<br>            socket.send(responsePacket);<br><br>            <span class="hljs-comment">//打印日志</span><br>            System.out.printf(<span class="hljs-string">&quot;[%s:%d] req: %s, resp: %s\n&quot;</span>, requestPacket.getAddress().toString(), requestPacket.getPort(), request, response);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">process</span><span class="hljs-params">(String request)</span>&#123;<br>        <span class="hljs-keyword">return</span> request;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">UdpEchoServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UdpEchoServer</span>(<span class="hljs-number">8080</span>);<br>        server.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>UdpEchoClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpEchoClient</span> &#123;<br>    <span class="hljs-comment">//客户端不需要手动指定</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> String serverIp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> serverPort;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UdpEchoClient</span><span class="hljs-params">(String ip, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> SocketException &#123;<br>        serverIp = ip;<br>        serverPort = port;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端上线!&quot;</span>);<br>        <span class="hljs-comment">//循环去发请求</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            System.out.println(<span class="hljs-string">&quot;请输入：&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> sc.next();<br><br>            <span class="hljs-comment">//1.将服务器的地址和端口号放进数据报，然后发送</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">requestPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(request.getBytes(), <span class="hljs-number">0</span>, request.getBytes().length, InetAddress.getByName(serverIp), serverPort);<br>            socket.send(requestPacket);<br><br>            <span class="hljs-comment">//2.等待接受服务器发来的响应</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">responsePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>], <span class="hljs-number">1024</span>);<br>            socket.receive(responsePacket);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(responsePacket.getData(), <span class="hljs-number">0</span>, responsePacket.getData().length);<br>            System.out.println(response);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">UdpEchoClient</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="二、TCP-Socket编程"><a href="#二、TCP-Socket编程" class="headerlink" title="二、TCP Socket编程"></a>二、TCP Socket编程</h1><p>由于<strong>Tcp是面向字节流和有连接</strong>的，因此与Udp编程有一些差异，不过依旧是那三部曲：服务器读取请求并解析，根据请求计算响应，将响应返回给客户端。</p><p>Tcp的socket是用来标识通信的双方，是一个四元组，包含了：源ip、源port、目的ip、目的port。</p><h2 id="ServerSocket-API"><a href="#ServerSocket-API" class="headerlink" title="ServerSocket API"></a>ServerSocket API</h2><p>ServerSocket是在服务器端使用的。</p><p><strong>构造方法</strong>：</p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>创建一个服务器端的socket，并绑定到指定端口</td></tr></tbody></table><p><strong>普通方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>Socket accept()</td><td>守候自己的端口号上等待用户的连接，当有连接后，返回一个Socket对象，表示与客户端建立的连接。</td></tr><tr><td>void close()</td><td>关闭socket</td></tr></tbody></table><h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><p>这个socket类可以表示客户端Socket，也可以表示为服务器端接受到客户端连接的请求后，返回的服务器端Socket。</p><p><strong>构造方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>Socket(String host, int port)</td><td>创建一个socket，与对应ip上的对应port建立连接</td></tr></tbody></table><p><strong>普通方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>InetAddress getInetAddress()</td><td>返回socket所连接的地址</td></tr><tr><td>InputStream getInputStream()</td><td>返回socket的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回socket的输出流</td></tr></tbody></table><h2 id="大致流程-1"><a href="#大致流程-1" class="headerlink" title="大致流程"></a>大致流程</h2><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016104641763.png" class title="image-20231016104641763"><h2 id="简单通信程序-1"><a href="#简单通信程序-1" class="headerlink" title="简单通信程序"></a>简单通信程序</h2><p><strong>TcpEchoServer：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpEchoServer</span> &#123;<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//指定服务器端的port</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TcpEchoServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>    &#125;<br><br>    <span class="hljs-comment">//启动服务器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器启动!&quot;</span>);<br>        <span class="hljs-comment">//服务器往往是7*24小时一直运转~</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//获取一个和服务器端的连接</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-comment">//处理连接</span><br>            processConnection(socket);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processConnection</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        System.out.printf(<span class="hljs-string">&quot;[%s:%d] 客户端已经上线~\n&quot;</span>, socket.getInetAddress().toString(), socket.getPort());<br>        <span class="hljs-comment">//与udp同理三部曲，不过tcp是字节流，使用流对象来读请求和发响应</span><br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream())&#123;<br>            <span class="hljs-comment">//为了方便，使用Scanner直接当做字符来处理</span><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(inputStream);<br>            <span class="hljs-comment">//客户端可能会多次发请求</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!scanner.hasNext())&#123;<br>                    System.out.printf(<span class="hljs-string">&quot;[%s:%d] 客户端已经下线~\n&quot;</span>, socket.getInetAddress().toString(), socket.getPort());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//1、读取请求并解析</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> scanner.next();<br>                <span class="hljs-comment">//2.根据请求计算响应</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> process(request);<br>                <span class="hljs-comment">//3.将响应发送给客户端</span><br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStream);<br>                writer.println(response);<br>                <span class="hljs-comment">//刷新缓冲区</span><br>                writer.flush();<br>                <span class="hljs-comment">//打印日志</span><br>                System.out.printf(<span class="hljs-string">&quot;[%s:%d] req: %s, resp: %s\n&quot;</span>, socket.getInetAddress().toString(), socket.getPort(), request, response);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">process</span><span class="hljs-params">(String request)</span>&#123;<br>        <span class="hljs-keyword">return</span> request;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">TcpEchoServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TcpEchoServer</span>(<span class="hljs-number">8080</span>);<br>        server.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>TcpEchoClient:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpEchoClient</span> &#123;<br>    <span class="hljs-comment">//客户端自己的socket</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TcpEchoClient</span><span class="hljs-params">(String ip, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//指定服务器的地址和端口号</span><br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(ip, port);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream())&#123;<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scannerConsole</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-comment">//1.组织请求</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> scannerConsole.next();<br>                <span class="hljs-comment">//2.将请求发送给服务器</span><br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStream);<br>                writer.println(request);<br>                writer.flush();<br>                <span class="hljs-comment">//3.接受服务器端的响应</span><br>                <span class="hljs-type">Scanner</span> <span class="hljs-variable">scannerResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(inputStream);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> scannerResponse.next();<br>                System.out.println(response);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">TcpEchoClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TcpEchoClient</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>        client.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p><strong>虽然Java有着垃圾回收机制，但是我们的服务器端一般是7*24小时运行着</strong>，而我们的代码中有着一个死循环，它一直在创建Socket对象，而每个socket对象与文件有关，也就是说<strong>每创建一个socket对象会占用一定的文件资源，因此我们需要去手动释放它</strong>。由于Socket类实现了closeable接口，我们可以使用try with resourse来关闭。</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016111221970.png" class title="image-20231016111221970"><p><strong>那么我们是否还需要去手动关闭Scanner和PrintWriter呢</strong>？不用，这是因为这两个里面<strong>持有的是inputStream和outputStream对象的引用</strong>，我们已经设置了自动关闭这两个对象，因此我不需要再关闭一次。</p><h2 id="多个客户端访问"><a href="#多个客户端访问" class="headerlink" title="多个客户端访问"></a>多个客户端访问</h2><p>虽然我们代码现在是安全了，但是还存在一个问题，当我们来了<strong>多个客户端访问服务器</strong>的时候，由于我们在processConnection中写了一个while循环，那么当客户端A进来后，<strong>程序就会阻塞在这个循环中</strong>，直到客户端A断开连接后，服务器才能去服务器客户端B，因此我们需要使用多线程来处理并发。</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016112051391.png" class title="image-20231016112051391"><p>很自然的我们可以写出这样的代码，然后就会出现如下错误：</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016112152276.png" class title="image-20231016112152276"><p>这是因为我们主线程在执行完代码块的时候，我们的另一个线程去执行了processConnction方法，但是还没执行完，我们的主线程就自动调用了socket.close，于是就抛出了上述异常。</p><p><strong>正确写法应该这样：</strong></p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016113704003.png" class title="image-20231016113704003"><p>在processConnection中关闭连接，因为<strong>一个processConnection处理完了，也就相当于一个连接结束</strong>了，因此我们可以在这进行关闭。</p><p>不过手动创建线程会涉及到用户态和内核态的转变，我们还可<strong>以使用一个线程池来进一步优化效率</strong>。</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016114507131.png" class title="image-20231016114507131"><p>最终结果如下：</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016114531403.png" class title="image-20231016114531403">]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-IO</title>
    <link href="/2023/10/05/JavaEE-IO/"/>
    <url>/2023/10/05/JavaEE-IO/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="认识文件"><a href="#认识文件" class="headerlink" title="认识文件"></a>认识文件</h1><p>文件是一个广义的概念，在操作系统中，会把很多的硬件设备和软件资源都抽象成”文件”, 统一进行管理。我们平时所谈到的文件，都是指硬盘中的文件。文件就相当于是对”硬盘”数据的一种抽象。</p><h2 id="文件组织结构"><a href="#文件组织结构" class="headerlink" title="文件组织结构"></a>文件组织结构</h2><p>由于文件很多，那么如何来管理文件呢？——<strong>使用一种按照层级结构进行组织，即树形结构</strong>。</p><img src="/2023/10/05/JavaEE-IO/image-20231005104001376.png" class title="image-20231005104001376"><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>文件路径是用来定位当前文件资源的，被分为<strong>相对路径和绝对路径</strong>。</p><p><strong>绝对路径：从根节点(以C,D盘符开头的)到叶子节点(当前文件)的路径。</strong></p><p>如: C:\植物大战僵尸\Plants Vs Zombies\PlantsVsZombies.exe</p><p><strong>相对路径：使用一个基准目录(使用.或者..表示,一个.表示当前目录,两个.表示当前目录的上一级),表示从这个基准目录往后到叶子节点的路径。</strong></p><p>如：.\Plants Vs Zombies\PlantsVsZombies.exe 这里的.就代表了C:\植物大战僵尸</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>从编程的角度来看，文件主要分为两大类：</p><p><strong>1、文本文件(文件中保存的都是字符串，都是合法的字符)。</strong></p><p><strong>2、二进制文件(文件中保存是二进制数据)</strong></p><p>如何区分？丢将文件丢记事本中,<strong>记事本会尝试按照字符的方式来展示内容，这个过程中会自动查码表，如果出现了一些看不懂的内容，那大概率就是二进制文件了。</strong></p><img src="/2023/10/05/JavaEE-IO/image-20231005110248724.png" class title="image-20231005110248724"><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>Java中通过java.io.File类来对一个文件进行描述。File对象可以对应到一个已经真实存在的文件，也可以对应到一个不存在的文件。</p><h2 id="File中常用方法"><a href="#File中常用方法" class="headerlink" title="File中常用方法"></a>File中常用方法</h2><p><strong>构造方法</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>File(File parent, String child)</td><td>根据父目录+孩子文件路径创建File实例</td></tr><tr><td>File(String pathname)</td><td>根据文件路径来创建一个File实例</td></tr><tr><td>File(String parent, String child)</td><td>根据父目录+孩子文件路径创建File实例</td></tr></tbody></table><p><strong>成员方法</strong></p><table><thead><tr><th>返回值</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>String</td><td>getParent()</td><td>返回File对象的父目录文件路径</td></tr><tr><td>String</td><td>getName()</td><td>返回File对象的文件名称</td></tr><tr><td>String</td><td>getPath()</td><td>返回File对象的文件路径</td></tr><tr><td>String</td><td>getAbsolutePath()</td><td>返回 File 对象的绝对路径</td></tr><tr><td>String</td><td>getCanonicalPath()</td><td>返回 File 对象的修饰过的绝对路径</td></tr><tr><td>void</td><td>deleteOnExit()</td><td>根据 File 对象，标注文件将被删除，删除动作会到 JVM 运行结束时才会进行</td></tr><tr><td>boolean</td><td>exists()</td><td>判断File对象文件是否存在</td></tr><tr><td>boolean</td><td>createNewFile()</td><td>根据File对象创建空文件</td></tr><tr><td>boolean</td><td>delete()</td><td>根据File对象，删除该文件</td></tr><tr><td>boolean</td><td>isFile()</td><td>判断 File 对象代表的文件是否是一个普通文件</td></tr><tr><td>boolean</td><td>isDirectory()</td><td>判断 File 对象代表的文件是否是一个目录</td></tr><tr><td>boolean</td><td>mkdir()</td><td>创建File对象代表的目录&#x2F;文件夹</td></tr><tr><td>boolean</td><td>mkdirs()</td><td>创建File对象代表的目录，可以创建中间目录</td></tr></tbody></table><h1 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h1><p>以上是文件系统的操作，但我们日常更多的是进行文件内容的操作。这时候我们就需要用到”文件流”了。</p><p>“流”是一种抽象的概念，程序员不用关注数据是怎么从硬盘上读入&#x2F;读出的，只需要关注如何写入到”流”中。文件流一般又分为两大类：字节流和字符流。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流顾名思义是一个字节一个字节的读入&#x2F;读出的，更适合与二进制文件的操作，这样可以保证文件不失真。</p><p>字节流又分为输入字节流InputStream和输出字节流OutputStream。这两个类在Java中是各种实现字节流类的基类，而且还是抽象类。</p><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p><strong>常用方法</strong></p><table><thead><tr><th>返回值</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>int</td><td>read()</td><td>读取一个字节的数据，返回-1表示已经读完了</td></tr><tr><td>int</td><td>read(byte[] b)</td><td>最多读取b.length个字节的数据到b数组中，返回实际读到的数量，-1表示读完了</td></tr><tr><td>int</td><td>read(byte[] b, int off, int len)</td><td>最多读取len-off个字节到b数组，放在从off开始位置</td></tr><tr><td>void</td><td>close</td><td>关闭字节流</td></tr></tbody></table><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><table><thead><tr><th>返回值</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>void</td><td>write(int b)</td><td>将b写入到文件</td></tr><tr><td>void</td><td>write(byte[] b)</td><td>将b数组中全部数据写入文件</td></tr><tr><td>int</td><td>write(byte[] b, int off, int len)</td><td>将b数组中从off位置往后len个数据写入文件</td></tr><tr><td>void</td><td>close()</td><td>关闭字节流</td></tr><tr><td>void</td><td>flush()</td><td>刷新缓冲区</td></tr></tbody></table><p><strong>注意</strong>：</p><p>为什么要手动进行刷新缓冲区呢？这是因为I&#x2F;O写入的速度很慢，OutputStream为了频繁多次只写一点点数据，就在写数据的时候会先将数据暂时<strong>写入缓冲区</strong>，然后才会将真正的数据写入文件。因此有可能当我们写完数据，结束程序后去看文件发现什么也没有，这是因为数据都在缓冲区中，还没来得及到文件里，这时需要手动刷新缓冲区。</p><p>我们可以使用上述的方法，进行读文件与写文件操作，但我们还可以<strong>使用PrintWriter类来帮我更简便的操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, UnsupportedEncodingException &#123;<br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/Test/test.txt&quot;</span>);<br>    <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">outputStreamWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(outputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStreamWriter);<br><br>    writer.println(<span class="hljs-string">&quot;我是第一行~&quot;</span>);<br>    writer.println(<span class="hljs-string">&quot;我是第二行~&quot;</span>);<br>    writer.println(<span class="hljs-string">&quot;我是第三行~&quot;</span>);<br>    writer.flush();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>在字符流中会使用到两个重要的基类：Reader和Writer。里面的方法使用跟上述字节流基本一致，只不过一个针对的是字节一个针对的是字符。</p><p>在Java中字符通常用char类型表示，字节用byte表示，一个char类型为2个字节，一个utf8编码的中文字符占3个字节。在Java标准库中，对字符编码进行了很多处理，如果只是用char，此时使用的字符集固定是Unicode，如果是使用了String，此时会自动把每个字符的unicode转为utf8编码，同样一个中文汉字，在unicode编码下占2个字节，而在utf8编码下占3个字节。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>我们每创建一个流对象就应该在不使用的时候进行关闭，即调用它的close方法。这是因为一个进程创建的时候，其PCB中会有一个文件描述符表来描述文件相关资源，如果我们的代码一直打开文件而不去关闭文件，这个文件描述符表里的元素越来越多，直到占满了，后续再次尝试创建就会出错，最终导致了文件资源泄漏。</p><p><strong>方案一：</strong></p><p><strong>每次使用完，人为的去手动调用它的close方法.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:/Test/test.txt&quot;</span>;<br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(path);<br>        <br>        <span class="hljs-comment">//写入文件~</span><br>        <br>        writer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样去写的话，万一中间抛出了什么异常，那么就不会往下执行代码了，就导致了close方法没有执行。</p><p><strong>方案二:</strong></p><p><strong>在finally代码块中调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:/Test/test.txt&quot;</span>;<br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(path);<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//写文件</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            writer.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样无论如何，finally代码块中的代码都会被执行，即close方法一定被执行了。虽然能这么写，但是不够优雅~</p><p><strong>方案三：</strong></p><p><strong>使用try(){}语法，这个语法会在try代码块执行结束的时候(正常结束或者抛出异常)，自动调用()定义的变量中的close方法。不过里面的变量类型必须实现了closeable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:/Test/test.txt&quot;</span>;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(path))&#123;<br>            <span class="hljs-comment">//写文件</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-多线程进阶</title>
    <link href="/2023/09/22/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/09/22/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、常见的锁策略"><a href="#一、常见的锁策略" class="headerlink" title="一、常见的锁策略"></a>一、常见的锁策略</h1><h2 id="乐观锁-vs-悲观锁"><a href="#乐观锁-vs-悲观锁" class="headerlink" title="乐观锁 vs 悲观锁"></a>乐观锁 vs 悲观锁</h2><p>乐观锁和悲观锁并不是一个具体的锁，而是一类锁的特性。</p><p><strong>悲观锁</strong>：悲观锁认为接下来<strong>锁冲突的概率较大</strong>，所以在<strong>访问资源共享资源前会先上锁</strong>。</p><p><strong>乐观锁</strong>：乐观锁认为接下来<strong>锁冲突的概率不大</strong>，所以会<strong>先修改共享资源</strong>，然后<strong>再去验证这段时间内有没有发生冲突</strong>，如果没有，则完成操作，<strong>如果有，放弃本次操作，返回用户错误信息，让用户再去处理。</strong></p><p><strong>两种锁并没有孰优孰劣之分，而是需要看当前使用的场景。</strong></p><p>如果当前冲突概率确实大，使用悲观锁策略会更好，而使用乐观锁的话，会导致”白操作”很多次，耗费资源。</p><p>如果当前冲突概率比较小，使用乐观锁更好，而使用悲观锁的话就会一直加锁，并发程度就下降了。</p><p>synchronized 初始使用的是乐观锁策略，当发现锁竞争比较频繁的时候，就会自动切换成悲观锁策略(真是太强了~~)。</p><h2 id="重量级锁-vs-轻量级锁"><a href="#重量级锁-vs-轻量级锁" class="headerlink" title="重量级锁 vs 轻量级锁"></a>重量级锁 vs 轻量级锁</h2><p>重量级和轻量级描述的是实际的开销量。<strong>在底层，加锁机制是通过操作系统提供的mutex锁来实现的，因此一旦加上锁，就会涉及到操作系统的内核，即在内核态与用户态间切换，这就会带来不小的开销。</strong></p><p>上述悲观锁就是重量级锁，因为会频繁加锁，而乐观锁则是轻量级锁，其原则是尽量不加锁。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><strong>在多线程中数据的读取操作不会产生线程安全问题，但是当有线程在写入数据的时候，另一个线程无论是读还是写操作都会出现线程安全的问题。</strong>如果在这两种场景(都是读或者有读有写)都只是用一个锁的话，就会产生很大的性能消耗，因此读写锁应运而生~</p><p>读写锁分为两部分：一个”读锁”,一个”写锁”。适合于”读多，写少”的场景。<strong>在Java中ReentrantReadWriteLock类就实现了读写锁。</strong></p><img src="/2023/09/22/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/image-20230927160351210.png" class title="image-20230927160351210"><p><strong>读写锁将读操作和写操作进行了区分对待</strong>，其中：</p><ul><li><p>读加锁和读加锁之间，不互斥。</p></li><li><p>写加锁和写加锁之间，互斥。</p></li><li><p>写加锁和读加锁之间，互斥。</p></li></ul><h2 id="自旋锁-vs-互斥锁-挂起等待锁"><a href="#自旋锁-vs-互斥锁-挂起等待锁" class="headerlink" title="自旋锁 vs 互斥锁(挂起等待锁)"></a>自旋锁 vs 互斥锁(挂起等待锁)</h2><p><strong>自旋锁是一种轻量级锁</strong>，其实现套路往往是<strong>使用一个循环不停的检查当前锁是否被释放</strong>，如果没有释放就继续循环，释放了就去获取锁，<strong>因此自旋锁往往是在纯用户态实现</strong>。但是不停的循环，就会产生”忙等”现象(消耗cpu换取更快的响应速度)。</p><p><strong>互斥锁是一种重量级锁</strong>，一个<strong>线程针对互斥锁进行加锁失败而阻塞是由操作系统内核实现</strong>的，当加锁失败，内核会将线程置为睡眠状态，等待锁释放后，内核会在合适的时机唤醒线程。所以<strong>当加锁失败后，会从用户态切换到内核态</strong>，而这就会产生不小的开销。</p><h2 id="可重入锁-vs-不可重入锁"><a href="#可重入锁-vs-不可重入锁" class="headerlink" title="可重入锁 vs 不可重入锁"></a>可重入锁 vs 不可重入锁</h2><p>如果一个<strong>针对同一把锁，连续加锁两次不会产生死锁，那么就是可重入锁</strong>，如果会死锁，就是不可重入锁。</p><p><strong>synchronized就是可重入锁</strong>，而linux中的mutex就是不可重入锁。</p><h2 id="公平锁-vs-非公平锁"><a href="#公平锁-vs-非公平锁" class="headerlink" title="公平锁 vs 非公平锁"></a>公平锁 vs 非公平锁</h2><p>当很多线程尝试去加一把锁的时候，只有一个线程能够拿到这把锁，其他线程进行阻塞等待，当这个线程释放锁后，接下来哪个线程能够拿到锁呢？</p><p><strong>公平锁：按照”先来后到”的顺序</strong>。(需要使用数据结构来维护加锁顺序)</p><p><strong>非公平锁：剩下的线程以”均等”的概率来重新竞争锁</strong>。</p><h1 id="二、CAS"><a href="#二、CAS" class="headerlink" title="二、CAS"></a>二、CAS</h1><p>CAS的全称是Compare And Swap, 本质上是<strong>一个cpu提供的指令，具有原子性</strong>，其被操作系统封装提供成api，然后又被JVM封装成api提供给程序员使用。</p><p><strong>CAS比较交换的是内存和寄存器</strong>，假设现在有一个内存M,两个寄存器A,B,CAS的操作如下：</p><p><strong>如果M和A的值相同，则交换M和B中的值，如果不同的话，则无事发生。</strong></p><hr><p>在介绍线程安全的时候，我们引入了一个案例，即通过i++操作让两个线程对变量i进行2w次的自增操作，最终结果并不是我们所想要的。<strong>这是因为i++操作本质上不是原子的，由load、add、save这三个指令完成，在并发的时候由于穿插执行，导致了线程不安全</strong>。解决办法是进行加锁。不过我们也可以使用CAS指令来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicInteger</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;<br>        <span class="hljs-keyword">while</span> ( CAS(value, oldValue, oldValue+<span class="hljs-number">1</span>) != <span class="hljs-literal">true</span>) &#123;<br>        oldValue = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里CAS是通过重试的方法来避免穿插执行的。</p><p>当两个线程同时进行操作的时候，线程1已经自增过一次了，线程2此时使用CAS，发现value不等于oldValue，此时就不进行操作了，然后一直循环，知道发现某一次相等才会进行自增操作。</p><h2 id="CAS中的ABA问题"><a href="#CAS中的ABA问题" class="headerlink" title="CAS中的ABA问题"></a>CAS中的ABA问题</h2><p>虽然CAS已经是一个原子指令了，但是还是可能会出现一些问题，即反复横跳问题。</p><img src="/2023/09/22/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/image-20230927211126606.png" class title="image-20230927211126606"><p>如图所示，本来是让两个线程去同时操作value的值，理论上value的值应该只能被修改一次，但是<strong>后面又来了线程3，它偷偷将value的值修改回去了</strong>，然后线程1发现值没变，最后又修改了，这样就导致了value的值被修改了两次。如果带入到取钱场景中，会发现非常要命，假设ATM机卡了，你多点了两次，就创建了两个线程去扣款50，此时剩下的钱变为了50，但恰巧有人给你转账了50，余额又变为了100，前面扣款的某个线程发现了值没变，又再一次扣款了,最终导致多扣了50……</p><hr><p>大部分情况下ABA问题都是没啥问题的，但又一些极端情况，还是会出现bug的。</p><p><strong>解决方案</strong>：</p><p><strong>ABA问题是因为某个值出现有增有减的情况</strong>，<strong>那么只要让判定的数值，按照一个方向增长即可。</strong>我们可以<strong>引入一个版本号，约定好每次修改余额的时候，都让版本号自增</strong>，此时CAS判定的时候就不是判定余额了，而是<strong>判定版本号是否发生了变化</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-线程安全</title>
    <link href="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、-案例引入"><a href="#一、-案例引入" class="headerlink" title="一、 案例引入"></a>一、 案例引入</h1><p><strong>线程安全是多线程中最重要最复杂的部分。可能同一份代码在单线程的环境下执行是正确的，但在多线程环境中就不一定了。</strong></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>                count++;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>                count++;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br><br>        t1.join();<br>        t2.join();<br><br>        System.out.println(<span class="hljs-string">&quot;count: &quot;</span> + count);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在逻辑上，count应该自增了2w次，最终count的值应该为2w，然而结果却不是2w，而且<strong>几乎每次运行的结果都不相同</strong>。</p><img src="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20230823154800674.png" class title="image-20230823154800674"><p><strong>解释：</strong></p><p>这是因为count++ 操作并不是原子的，<strong>本质上是分成三步的</strong>：</p><blockquote><p>1、load 把数据从内存中读到cpu寄存器中</p><p>2、add 把寄存器中的数据进行+1</p><p>3、save 把寄存器中的数据，保存到内存中。</p></blockquote><p><strong>如果是多个线程执行的话，由于线程之间的调度顺序是随机的，并不确定，就会导致出现问题</strong>。</p><p>如：当第一个线程正在进行第一个操作的load的时候，第二个线程已经完成了第二、三、四的操作，此时第一个线程再进行第一个操作的add的时候，从寄存器中读取到的数据是0，而非3，因此就会出现错误。</p><p><strong>总结：</strong></p><p>产生线程安全问题的原因：</p><blockquote><p>1、操作系统中，线程的调度顺序是随机的(抢占式执行)</p><p>2、不同线程，最对同一个变量进行修改</p><p>3、修改操作，不是原子的，即某个操作必须一起全部完成。</p><p>4、内存可见性问题</p><p>5、指令重排序问题</p></blockquote><hr><p>那要如何保证代码一定准确呢？答案是<strong>加锁</strong>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象名)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>() 中需要表示一个用来加锁的对象，这个<strong>对象是啥不重要</strong>，<strong>重要的是通过这个对象来区分两个线程是否在竞争同一个锁</strong>。如果两个线程是在针对同一个对象加锁，就会有锁竞争，如果不是针对同一对象加锁，就不会有锁竞争，而此时的并发程度最高，但是不能保证正确。</p><p>{}内的代码就是要执行的内容了。</p><p>当一个线程拿到了这把对象锁之后，另外一个线程就得阻塞，等待上一个线程释放锁，之后再进行竞争这把锁。</p><h1 id="二、Synchronized的特性"><a href="#二、Synchronized的特性" class="headerlink" title="二、Synchronized的特性"></a>二、Synchronized的特性</h1><h3 id="2-1-修饰权限"><a href="#2-1-修饰权限" class="headerlink" title="2.1 修饰权限"></a>2.1 修饰权限</h3><p><strong>synchronized不仅能修饰代码块，还可以修饰方法。</strong></p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>      <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>            <br>      &#125;<br>&#125;<br><br><span class="hljs-comment">//相当于</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-comment">//使用this，表示对当前对象加锁</span><br>          <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>              <br>          &#125;<br>      &#125;<br>&#125;<br><br><span class="hljs-comment">//静态方法也是一样</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//相当于</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//这里Test.class为类对象</span><br>        <span class="hljs-keyword">synchronized</span>(Test.class)&#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-刷新内存"><a href="#2-2-刷新内存" class="headerlink" title="2.2 刷新内存"></a>2.2 刷新内存</h3><p>由于网上众说纷纭…….</p><h3 id="2-3-可重入"><a href="#2-3-可重入" class="headerlink" title="2.3 可重入"></a>2.3 可重入</h3><p>所谓的可重入锁指的是一个线程中连续对某一个对象进行加锁，但不会出现死锁的现象，如果满足就是“可重入”。</p><p><strong>举个例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">locker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                    <br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析</strong>：如果没有可重入特性的话……</p><p>假设当在最外面的时候对locker对象加锁成功了，此时locker对象应该是”被锁定的状态”，然后进行内层的加锁操作，发现此时locker已经是锁定的状态了，原则上，需要阻塞等待locker对象的锁被释放，才能进行第二次加锁，这样就形成了“死锁”，即第二次加锁操作需要等待第一次加锁操作释放锁，第一次加锁操作需要等待第二次加完锁后执行代码才能释放锁……. </p><p>但在Java中并不会出现这种情况，这是因为<strong>synchronized的可重入特性</strong>。当进行加锁操作的时候，会先记录一下是哪个线程获得了这个对象锁，后续这个线程再进行加锁的话，会检查是否已经持有了这个对象锁，如果有直接加锁成功。同理释放锁是在最外层的synchronized结束后，才释放锁(底层使用了计数器来管理，每当加锁一次，计数器+1，出了这个锁，计数器-1，如果为0了，则真正释放锁)。</p><h1 id="三、-死锁"><a href="#三、-死锁" class="headerlink" title="三、 死锁"></a>三、 死锁</h1><p>死锁可大致分为两类：一个线程一把锁，N个线程M把锁。</p><h3 id="3-1-一个线程一把锁"><a href="#3-1-一个线程一把锁" class="headerlink" title="3.1 一个线程一把锁"></a>3.1 一个线程一把锁</h3><p>这种情况也就是上面所说的情况，但在Java中synchronized是可重入锁，并不会产生，但在c++中，std::mutex可并不是可重入锁，就会出现死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">locker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//并不会死锁~~</span><br>            <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                    <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                        <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                            <span class="hljs-keyword">synchronized</span> (locker)&#123;<br><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-N个线程M把锁"><a href="#3-2-N个线程M把锁" class="headerlink" title="3.2 N个线程M把锁"></a>3.2 N个线程M把锁</h3><p>这个情境下，最经典的就是哲学家就餐问题。</p><p><strong>描述如下</strong>：</p><p>有5个哲学家在一张桌子前吃饭，在每个哲学家左手边放置一根筷子，哲学家拿起两根筷子才能吃饭，吃完饭才能把筷子放下。</p><img src="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20230912210928449.png" class title="image-20230912210928449"><p>如果某一时刻，某几个哲学家手快，拿起了两个筷子，那么这些哲学家就可以吃饭，吃完后放回筷子，然后竞争下一次。如果非常不巧，每个哲学家都抢到一根筷子，此时，所有人都没有两根筷子且此时所有人都持有一根筷子，每个哲学家都在等待别人将筷子放下，但是只有拿到两根筷子后才能放下筷子，这就陷入了死局。</p><hr><p>死锁是比较严重的bug，会导致线程卡住，无法执行后续的代码。</p><p>如何避免死锁的产生呢？**首先考虑产生的原因(4点)**。</p><p>1、**互斥使用(锁的基本特性，无法改变)**。即两个线程不能同时获得同一把对象锁，当一个线程获得这个对象锁的时候，另一个线程需要阻塞等待。</p><p>2、**不可抢占(锁的基本特性，无法改变)**。当一个线程获得这把对象锁后，另一个线程不能抢过来，只能等待释放这把锁才能去竞争。</p><p>3、**请求保持(可通过调整代码结构避免)**。一个线程可以拿到多把对象锁。即当一个线程获取到了锁1，再获取到了锁2，锁1不会立即释放。(吃着碗里的，看着锅里的)</p><p>4、**循环等待(可通过调整代码结构避免)**。如上述哲学家就餐问题，等待的依赖关系成环了。</p><p>要想出现死锁的情况，需要把上面的4个条件都占了，但其中的1和2是锁的基本特性不可避免，因此我们只需要针对3和4的情况。</p><p>对于条件3，避免编写“锁嵌套”，但这个有时候也无法避免。因此我们着重对条件4着手。</p><p>对于条件4，可以约定加锁的顺序，这样就可以避免循环等待。如：针对锁进行编号，加多把锁的时候，先加编号小的锁，再加编号大的锁。</p><p><strong>哲学家就餐问题解决方案</strong>：</p><img src="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20230912214923919.png" class title="image-20230912215451748"><p>我们规定，每个哲学都要遵守如下规定：选择左手和右手中编号较小的一根筷子，如果较小的那根筷子没了，那就等待出现编号小的筷子再进行竞争。这样优化以后，就不会出现僵持的现象了。</p><h1 id="四、-volatile"><a href="#四、-volatile" class="headerlink" title="四、 volatile"></a>四、 volatile</h1><h3 id="4-1-案例引入"><a href="#4-1-案例引入" class="headerlink" title="4.1 案例引入"></a>4.1 案例引入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">Quit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(Quit == <span class="hljs-number">0</span>)&#123;<br><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;退出成功&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;请输入Quit的值:&quot;</span>);<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            Quit = sc.nextInt();<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，当我们通过线程2来修改Quit的值变为1时，此时线程1并没有退出输出“退出成功”，而是依然还在运行。</p><img src="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20230913100049705.png" class title="image-20230913100049705"><p>此处的问题就是”内存可见性“引起的，其实是编译器优化错了。</p><h3 id="4-2-内存可见性"><a href="#4-2-内存可见性" class="headerlink" title="4.2 内存可见性"></a>4.2 内存可见性</h3><p><strong>为什么会有内存可见性？</strong></p><p>这是因为在计算机运算代码的时候，要经常访问数据，而这些数据存储在内存中，cpu使用这个变量的时候，就会把到内存中取出这个数，放到寄存器上，然后进行计算，但是<strong>读内存的速度相较于读寄存器慢了几千倍</strong>，如果要频繁的读内存的话会大大降低效率，因此<strong>编译器为了解决频繁读内存的问题，就对代码进行了优化，把一些本来要读取内存的操作优化成读取寄存器</strong>，从而使整体效率提升了。</p><p>对于上述案例，因为线程1的循环体内没有做任何事情，因此循环的速度非常快，但每一次循环的时候，都需要读取内存中Quit的值到寄存器中，编译器发现你老是读取这个值，然后这个值还一直没有修改，而每一次读都非常浪费时间，于是编译器就做了一个大胆的决定，不再从内存中读取了，而是直接从寄存器中拿值比较，于是后面的修改只是修改了内存中的值，实际比较的时候并没有改变。</p><hr><p>这种情况下就得使用volatile来修饰Quit。在多线程环境下，编译器对于优化的判定不一定准确，此时就需要程序猿通过volatile关键字，告诉编译器不要进行优化。</p><h1 id="五、-wait和notify"><a href="#五、-wait和notify" class="headerlink" title="五、 wait和notify"></a>五、 wait和notify</h1><p>在多线程编程中，我们往往会涉及到多个线程间的配合调用。前面所提到join方法可以使线程阻塞，但得等到某个线程执行完后，才能解除阻塞，继续执行，而通过使用wait方法，可以手动阻塞某个线程，然后通过notify方法手动再让线程继续执行。</p><h3 id="5-1-wait"><a href="#5-1-wait" class="headerlink" title="5.1 wait"></a>5.1 wait</h3><p>wait方法的作用是：让当前调用的线程进入等待状态，直到其他线程调用notify方法。</p><p>wait方法是Object的方法，因此任何对象都有wait方法。</p><p>在执行wait方法的时候，会做3件事情。</p><ul><li>1、释放当前锁(如果当前线程没有进行加锁操作会报错)</li><li>2、让当前线程进入阻塞状态</li><li>3、当线程被唤醒的时候，尝试重新获取这把锁</li></ul><h3 id="5-2-notify"><a href="#5-2-notify" class="headerlink" title="5.2 notify"></a>5.2 notify</h3><p>notify方法是用来唤醒等待的线程。有以下3点需要值得注意：</p><ul><li>1、notify方法<strong>需要在synchronized代码块中调用</strong></li><li>2、notify方法调用完后，<strong>当前线程不会立马释放对象锁</strong>，而是等到执行notify方法的线程执行完所有代码后才会去释放对象锁</li><li>3、如果有对个线程等待，会<strong>随机挑选一个等待的线程唤醒</strong>。因此还提供了notifyAll方法，可以唤醒所有等待的线程。</li></ul><h3 id="5-3-线程饿死"><a href="#5-3-线程饿死" class="headerlink" title="5.3 线程饿死"></a>5.3 线程饿死</h3><p>假设现在有多个线程来竞争一把锁，第一次线程1抢到了这把锁，执行完代码后就释放了锁，然后进行下一次的锁竞争，恰巧第二、第三、第四………..第N次又抢到了这把锁(因为线程1已经在cpu上执行，没有调度的过程，更容易拿到锁)，但是线程1每一次拿到锁又不干嘛，就光竞争，最后就有可能导致某些关键的线程一直拿不到锁。我们称这种情况为“线程饿死”。</p><p>针对这种情况，我们可以使用wait和notify来解决。让线程在某个条件下调用wait，把资源让出来，不参与后续竞争。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-多线程案例</title>
    <link href="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/"/>
    <url>/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、阻塞队列"><a href="#一、阻塞队列" class="headerlink" title="一、阻塞队列"></a>一、阻塞队列</h1><h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h2><p>阻塞队列是在多线程代码中常用的一种数据结构，也具有”先进先出”的原则。与普通队列相比，阻塞队列是一种线程安全的队列，并且具有如下特性：</p><p>1、当<strong>阻塞队列为空</strong>时，继续<strong>出队</strong>，不会抛出异常，而是会<strong>阻塞等待</strong>，直到其他线程往队列中添加元素为止。</p><p>2、当<strong>阻塞队列为满</strong>时，继续<strong>入队</strong>，不会抛出异常，而是会<strong>阻塞等待</strong>，直到其他线程往队列中删除元素为止。</p><p>由于阻塞队列是一个数据结构，所以往往用来管理数据，典型的应用场景是”生产者消费者模型”。</p><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>生产者消费者模型是一种用来协调多个线程的设计模式。生产者负责生产数据，消费者用来消耗数据。</p><p>生产者与消费者之间通过一个阻塞队列来维护数据，即生产者将生成的数据放进阻塞队列中，消费者从阻塞队列中取数据，阻塞队列可以控制数据的流量，防止资源的过度消耗或浪费。</p><p><strong>生产者消费者模型的意义</strong>：</p><p><strong>1、解耦合</strong></p><p>耦合指的是两个不同的模块，如果联系紧密(一个模块的修改会影响另一个模块)，则称耦合度高。生产者消费者模型通过使用阻塞队列，生产者A不直接与消费者B联系，而是通过阻塞队列，此时耦合就降低了，如果后续增加了一个消费者C，生产者A不需要进行修改，而是只需让消费者C从阻塞队列中取数据即可~</p><p><strong>2、削峰填谷</strong></p><p>在实际生活中，有一些特定的场景，例如”学校抢课”，服务器会在某一时刻收到大量请求，如果直接处理这些请求，服务器可能会扛不住(在处理的某些环节中，可能比较脆弱，如：数据库操作)，这时候就可以把这些请求放到阻塞队列中，后续让消费者线程慢慢的处理。</p><hr><h2 id="标准库中内置的阻塞队列"><a href="#标准库中内置的阻塞队列" class="headerlink" title="标准库中内置的阻塞队列"></a><strong>标准库中内置的阻塞队列</strong></h2><p>1、BlockingQueue是一个接口，实现的类是ArrayBlockingQueue和LinkedBlockingQueue，即底层有链表和数组实现的类。</p><p>2、put方法用于阻塞式的入队了，take方法用于阻塞式出队列，offer、poll方法不带有阻塞特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>        blockingQueue.put(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-keyword">while</span>(!blockingQueue.isEmpty())&#123;<br>            System.out.println(blockingQueue.take());<br>        &#125;<br>        <span class="hljs-comment">//程序阻塞</span><br>        blockingQueue.take();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>阻塞队列的使用与普通队列类似，注意使用put和take方法即可~</p><h2 id="模拟实现阻塞队列"><a href="#模拟实现阻塞队列" class="headerlink" title="模拟实现阻塞队列"></a><strong>模拟实现阻塞队列</strong></h2><p>首先实现一个循环队列，然后对put和take方法注入阻塞等待的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBlockingQueue</span>&#123;<br>    <span class="hljs-comment">//浪费一个空间，来区分满与空</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">while</span>((tail + <span class="hljs-number">1</span>) % data.length == head)&#123;<br>                <span class="hljs-comment">//如果队列满了，就会阻塞</span><br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125;<br>            <span class="hljs-comment">//队列不满，插入元素</span><br>            data[tail] = s;<br>            tail = (tail + <span class="hljs-number">1</span>) % data.length;<br>            <span class="hljs-comment">//唤醒take中wait的线程</span><br>            <span class="hljs-built_in">this</span>.notify();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">while</span>(head == tail)&#123;<br>                <span class="hljs-comment">//如果队列为空，阻塞等待</span><br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> data[head];<br>            head = (head + <span class="hljs-number">1</span>) % data.length;<br>            <span class="hljs-comment">//唤醒put中wait的线程</span><br>            <span class="hljs-built_in">this</span>.notify();<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyBlockingQueue</span> <span class="hljs-variable">myBlockingQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBlockingQueue</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                myBlockingQueue.put(<span class="hljs-string">&quot;1&quot;</span>);<br>                myBlockingQueue.put(<span class="hljs-string">&quot;1&quot;</span>);<br>                myBlockingQueue.put(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(myBlockingQueue.take());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>        t2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>这份代码有一个地方值得注意：put方法中是否需要循环判断队列是否已满？</strong></p><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230918202907725.png" class title="image-20230918202907725"><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230918203518563.png" class title="image-20230918203518563"><p>所以使用wait的时候，需要注意当前wait唤醒的时候，是通过notify唤醒的还是通过interrupt唤醒的，如果是通过notify唤醒的，说明别的线程已经删除了元素，队列不可能为满，如果是interrupt唤醒的，队列可能还满着呢，需要继续判断。因此使用while循环判断的话，就可以保证队列一定是不为满。</p><p><strong>总结：使用wait的时候，往往都是使用while作为条件判定的方式，目的是为了让wait唤醒后的线程再确定一次，是否满足条件。上述while循环写法，也是官方文档的建议。</strong></p><h1 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h1><p><a href="https://smarmot666.github.io/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式-单例模式 - 机智的土拨鼠 (smarmot666.github.io)</a></p><h1 id="三、定时器"><a href="#三、定时器" class="headerlink" title="三、定时器"></a>三、定时器</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><strong>定时器是一种非常常用的组件，约定好某一时间，时间到达后，开始执行某些代码</strong>(在网络通信中经常出现)。</p><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230919154600704.png" class title="image-20230919154600704"><hr><p>在java库中内置了一个Timer类，里面有一个核心方法schedule方法。</p><p><strong>schedule方法包含了两个参数，第一个是指定要即将执行的任务代码，第二个是指定多久后执行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Timer;<br><span class="hljs-keyword">import</span> java.util.TimerTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行定时器任务&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>TimeTask是一个抽象类，实现了Runnable接口</strong>，所以需要进行重写run方法，通过run方法描述任务的详细情况。</p><p>主线程在执行schedule方法时，会把这个任务放到timer对象，而<strong>在timer对象内部包含了一个”扫描线程”，一旦时间到了，扫描线程就会执行刚才安排的任务</strong>。(主线程的结束，并不会影响扫描线程~)</p><h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>分析：</p><p>1、首先需要一个类来描述任务以及什么时候执行任务。</p><p>2、然后在Timer中需要一个线程，循环判断是否有任务已经到达时间了。</p><p>3、最后选择某个数据结构用来管理多个任务，由于一定是时间小的先执行，那么可以使用一个优先队列。</p><hr><p>如何描述每个任务？通过创建一个类，这个类中包含一个Runnable属性(描述任务)，和一个执行任务时间的属性time(在这使用绝对时间)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimerTask</span>&#123;<br>    <span class="hljs-comment">//通过重写run，描述执行的任务</span><br>    <span class="hljs-keyword">private</span> Runnable runnable;<br>    <span class="hljs-comment">//执行任务的时间，这里使用绝对时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>        <span class="hljs-comment">//传入的是相对时间,这里计算绝对时间</span><br>        <span class="hljs-built_in">this</span>.time = System.currentTimeMillis() + time;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建Timer类，在Timer类中需要加入一个schedule方法，来添加任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimer</span>&#123;<br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;MyTimerTask&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span>&#123;<br>        priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTimerTask</span>(runnable, time));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//描述线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <br>        &#125;);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于优先队列会进行比较的操作，所以我们需要让MyTimerTask类实现一下Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;MyTimerTask&gt;&#123;<br>    <span class="hljs-comment">//通过重写run，描述执行的任务</span><br>    <span class="hljs-keyword">private</span> Runnable runnable;<br>    <span class="hljs-comment">//执行任务的时间，这里使用绝对时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>        <span class="hljs-comment">//传入的是相对时间,这里计算绝对时间</span><br>        <span class="hljs-built_in">this</span>.time = System.currentTimeMillis() + time;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyTimerTask o)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (<span class="hljs-built_in">this</span>.time - o.time);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过前面分析，Timer中应该有一个while循环，一直扫描是否有任务到时间该执行了，不过我们还要<strong>对还未添加任务的情况处理</strong>，跟之前的阻塞队列类似，<strong>我们可以让程序先阻塞着，直到添加了任务在进行执行，此时就需要用到wait方法</strong>，再进一步发现，在多线程的应用场景下，<strong>schedule方法和构造方法可能会同时对队列进行修改操作，因此我们还需要加锁。</strong></p><p><strong>完整代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;MyTimerTask&gt;&#123;<br>    <span class="hljs-comment">//通过重写run，描述执行的任务</span><br>    <span class="hljs-keyword">private</span> Runnable runnable;<br>    <span class="hljs-comment">//执行任务的时间，这里使用绝对时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>        <span class="hljs-comment">//传入的是相对时间,这里计算绝对时间</span><br>        <span class="hljs-built_in">this</span>.time = System.currentTimeMillis() + time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getTime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Runnable <span class="hljs-title function_">getRunnable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> runnable;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyTimerTask o)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (<span class="hljs-built_in">this</span>.time - o.time);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimer</span>&#123;<br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;MyTimerTask&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">locker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>            priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTimerTask</span>(runnable, time));<br>            locker.notify();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//扫描线程，需要不停的扫描队首元素，看是否到达时间</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                    <span class="hljs-comment">//如果当前没有任务，阻塞等待</span><br>                    <span class="hljs-keyword">while</span>(priorityQueue.isEmpty())&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            locker.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">//判断是否到执行时间了</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">curTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                    <span class="hljs-type">MyTimerTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> priorityQueue.peek();<br>                    <span class="hljs-keyword">if</span>(curTime &gt;= task.getTime())&#123;<br>                        <span class="hljs-comment">//执行完任务，并删除队首元素</span><br>                        task.getRunnable().run();<br>                        priorityQueue.poll();<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">//如果还没有到时间，怎让线程阻塞等待</span><br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">//可以不做等待处理，但是会让线程一直去查看当前是否到达执行时间</span><br>                            <span class="hljs-comment">//会浪费cpu资源，可以让其阻塞至指定时间</span><br>                            locker.wait(task.getTime() - curTime);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、线程池"><a href="#四、线程池" class="headerlink" title="四、线程池"></a>四、线程池</h1><h2 id="为什么要有线程池？"><a href="#为什么要有线程池？" class="headerlink" title="为什么要有线程池？"></a><strong>为什么要有线程池？</strong></h2><p>首先我们需要知道为什么要使用多线程而不使用多进程呢？这是因为进程创建太过重量,当需要频繁销毁&#x2F;创建的时候, 就不能忽视这些资源开销了。而线程依赖与进程，多个线程共享同个进程的资源，不过线程的创建&#x2F;销毁也会消耗一定的资源(相比进程少)，因此到达一定程度，这些开销也不能忽视了!!!</p><h2 id="两种解决方案："><a href="#两种解决方案：" class="headerlink" title="两种解决方案："></a><strong>两种解决方案：</strong></h2><p><strong>1、使用协程</strong></p><p>协程相比于线程来说，更加轻量级，因为协程把系统调度的过程给省略了，程序猿可以手动调度。不过在Java中，标准库没有协程，只有一些第三方库中有，但第三方库靠不靠谱？使用协程更多的是Go和Python。</p><p><strong>2、使用线程池</strong></p><p>在计算中”池”是一个重要的思想方法，例如：线程池、进程池、内存池…….</p><p>大致思想就是，一次多创建几个线程，后续要用到的话，直接从池子里取出来，可为什么从池子里取出就比重新创建效率高呢？</p><p><strong>原因</strong>：</p><p>在计算机工作中，操作系统会在”内核态”和”用户态”两种状态来回切换，<strong>创建一个新的线程，就需要调用系统API，让操作系统的内核去完成，而操作系统内核是需要给所有的进程提供服务的，可能并不会马上回应你，这是不可控的</strong>，可能操作系统花费了很多时间才来理睬捏。但如果是<strong>从线程池中取出一个线程，这个操作是只需要”用户态”来完成，程序立马就能去执行，这是可控的。</strong></p><h2 id="标准库中的线程池"><a href="#标准库中的线程池" class="headerlink" title="标准库中的线程池"></a>标准库中的线程池</h2><p><strong>简单使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <br>        service.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>        &#125;);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里线程池对象不是直接new出来的，而是通过一个专门的方法，返回了一个线程池对象。(在这使用到了一个<strong>设计模式——工厂模式</strong>)。</p><p>在这使用了Executors.newFixedThreadPool方法，可以创建一个固定包含10个线程的线程池，其返回值类型是ExecutorService，通过调用里面的submit方法，可以将一个任务放到线程池中。</p><hr><p><strong>Executors创建线程池有这几种方式</strong>：</p><ul><li>newFixedThreadPool: 创建固定线程数的线程池.</li><li>newCachedThreadPool: 创建线程数目动态增长的线程池.</li><li>newSingleThreadPool: 创建单个线程的线程池.</li><li>newScheduleThreadPool: 设置延迟时间后执行命令，或者定期执行命令.</li></ul><p>上述的几个工厂方法生成的线程池，本质上是Executors类对ThreadPoolExecutor类的封装。</p><hr><p><strong>ThreadPoolExecutor中的重要的方法就两个</strong>：</p><ol><li>构造方法</li><li>submit方法(注册任务)</li></ol><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230922152359084.png" class title="image-20230922152359084"><p><strong>参数含义</strong>：</p><ul><li>int corePoolSize：表示核心线程数(线程池中可以摸鱼的线程数目)。</li><li>int maxiumPoolSize：表示线程池中最大线程的个数。</li><li>long keepAliveTime：表示非核心线程可以摸鱼的时间，一到时间就会销毁。</li><li>TimeUnit unit：表示keepAliveTime的时间单位。</li><li>BlockingQueue<Runnable> workQueue：表示用来维护任务的容器，但必须为阻塞队列或其子类(优先阻塞队列)。</Runnable></li><li>ThreadFactory threadFactory：使用某个工厂对象，线程由这个对象创建。使用工厂类是为了在创建过程中对线程属性做一些修改。</li><li>RejectedExecutionHandler handler：线程池的拒绝策略，一个线程池中线程数达到了最大容量，当继续往线程池中添加任务，的话就需要采用某种策略来处理。</li></ul><hr><p><strong>线程池拒绝策略：</strong></p><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230922155648608.png" class title="image-20230922155648608"><ul><li>AbortPolicy：直接抛出异常。(摆烂~老子不干了！！)</li><li>CallerRunsPolicy：新添加的任务，由添加任务的那个线程执行。(假装没听到~~依旧是自己干)</li><li>DiscardOldestPolicy：丢弃任务队列中最老未被执行的任务。(放弃很久之前没做的事，将任务添加进来)</li><li>DiscardPolicy：丢弃当前新加的任务。(任务都别干了)</li></ul><hr><p><strong>如果使用newFixedThreadPool方法来构建线程池的话，初始构建多少个合适？根据cpu核心数设置？</strong></p><p><strong>应当根据实际项目来设置。</strong>在一个线程中，执行的代码主要有两类：第一类为<strong>cpu密集型</strong>，在代码中主要进行算术运算&#x2F;逻辑判断，另一类为<strong>IO密集型</strong>，在代码中主要进行IO操作。</p><p>假设一个线程的代码都是cpu密集型，这个时候线程池中的个数不应该超过cpu的核心数，此时如果超过了，也无法进一步提高效率了，反而回应为太多线程影响调度开销。</p><p>假设一个线程的代码都是IO密集型，这个时候不吃cpu，设置的线程数就以超过N，一个核心可以通过调度来执行并发。</p><p>所以需要根据实际需求，进行多轮测试的方式，来找到最佳的线程池的线程数目。</p><h2 id="模拟实现-1"><a href="#模拟实现-1" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>在这就实现一个最简单的线程池(固定个数，不使用工厂模式)</p><p><strong>要点</strong>：</p><ul><li>线程池中核心的操作时submit方法，将线程添加到线程池中。</li><li>由于有多个线程任务，考虑使用阻塞队列来管理这些任务。</li></ul><p><strong>实现代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPool</span>&#123;<br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable runnable)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        queue.put(runnable);<br>    &#125;<br>    <br>    MyThreadPool(<span class="hljs-type">int</span> n)&#123;<br>        <span class="hljs-comment">//创建n个线程，如果没有任务，则阻塞等待</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//如果没有任务，让线程阻塞等待</span><br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> queue.take();<br>                    runnable.run();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;);<br>            t.start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>设计模式———单例模式</h1><p>单例也就是只能有一个实例，即只创建一个实例对象，不能有多个。</p><p>可能会疑惑，那我写代码的时候注意点，只new一次不就得了。理论上是可以的，但在实际中很难实现，因为你无法预料到后面是否会脑抽一下~~因此我们就可以<strong>通过编码技巧，让编译器来帮助我们检查约束。</strong></p><p>单例模式又分为两种：<strong>饿汉式和懒汉式</strong>，<strong>区别在于实例对象创建的时机不同</strong>。</p><h2 id="0x00-饿汉式">0x00 饿汉式</h2><p>说到饿汉，那一定是很饥饿的人，很急切，也就是说这个实例对象创建的时机比较早，在类加载的时候就创建了。</p><p><strong>要点</strong>：</p><ul><li>1、由于创建时机较早，设置为静态即可在类加载的时候就可以创建实例对象</li><li>2、由于只能创建一个实例对象，因此将构造函数私有化</li><li>3、对外提供一个获取实例对象的静态类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>         <br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="0x01-懒汉式">0x01 懒汉式</h2><p>懒汉，顾名思义，很懒，比较缓慢，也就是说这个实例对象是在使用到的时候才去创建。</p><p><strong>要点</strong>：</p><ul><li>1、一开始设置为null，直到在使用的时候再去new实例对象</li><li>2、由于只能创建一个实例对象，因此将构造函数私有化</li><li>3、对外提供一个获取实例对象的静态类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingletonLazy</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0x02-单例模式与多线程">0x02 单例模式与多线程</h2><p>众所周知，许多在单线程环境下的代码一到多线程环境下就会出错，在此将对单例模式在多线程下的编写进行调整优化~</p><p>先来看看饿汉式的代码，我们发现这个实现的方式是在类加载的时候就去实例化对象了，而后续在多线程中掉用getInstance方法来获取实例对象的时候，只会进行返回操作，即”<strong>只读”</strong>，<strong>因此多个线程在操作的时候是安全的</strong>。</p><img src="/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230913211123788.png" class><p>再来看看懒汉式，可以发现在调用getInstance方法的时候，会进行修改操作，<strong>如果恰巧有两个线程同时进入了if，然后就会进行new操作，那不就创建了多个实例对象了</strong>，如果恰巧每个对象不是很轻量，可能有很多属性，加载了几十G的数据到内存中…</p><img src="/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230913211530808.png" class><p>因此解决方法是进行加锁操作，<strong>保证if和new操作是原子的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingletonLazy</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(SingletonLazy.class)&#123;<br>            <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样修改以后，就能保证if和new操作是一个整体，此时线程的安全问题就得到了改善。</p><p><strong>但是这样写是否就真的完了呢？</strong></p><p>答案：不是。因为我们是单例模式，所以只需要new一次之后，实例对象就不可能是null了，后续直接return对象就行了。<strong>假如我们现在已经创建好了一个对象，当后续有多个线程去调用getInstance方法的时候，需要去获取到这把锁才能进行返回操作，也就是我们的多线程变成了串行化，并发程度几乎没了</strong>~</p><p>那是否有办法，既可以保证代码线程安全，又不会对执行效率产生大的影响呢？</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingletonLazy</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(SingletonLazy.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与前面的代码对比，可以发现，在外层多加了一个if语句。</p><p><strong>分析</strong>：</p><p>当有多个线程进入了第一个if语句，此时里面有一个加锁操作，这样可以保证只创建了一个实例对象。假设此时已经创建好了一个实例对象了，当下一次又有多个线程进来时，由于instance不为null，直接返回了，并不会进入到加锁操作，此时并发并没有再受到影响了，既保证了正确又保证了效率。</p><p><strong>总结</strong>：</p><p><strong>在锁外面的if语句保证了是否要进行加锁操作，即如果还没有创建实例对象，此时线程由于需要进行修改操作要进行加锁才能保证安全，如果已经创建了实例对象，此时线程安全了就不用加锁了。</strong></p><p><strong>在锁里面的if语句是来保证只创建一个实例对象。</strong></p><h2 id="0x03-指令重排序">0x03 指令重排序</h2><p>上述代码其实还不够安全，还存在指令重排序的问题。</p><p><strong>指令重排序，本质是编译器为了提高执行效率，调整原有的代码执行顺序(前提是保持逻辑不变)。</strong></p><p>接下来具体问题具体分析：</p><p>上述的代码中，出现了一个new操作，而new操作其实是分三步的，第一步，申请内存空间，第二步，在内存空间上构造对象，第三步，把内存地址赋值给对象引用。一般是按照1,2,3的顺序执行的，但是编译器优化过后，可能会按照1,3,2的顺序执行，在单线程环境下都可以，但是在多线程环境下则不是。如果线程1是按照1,3,2顺序执行完了3后，线程2此时返回了这个实例对象，但是此时这个对象还没有初始化呢，也就是说这是个非法对象，当我们的线程2去访问这个对象的属性或方法时，此时就是非法，会出错。此时我们还需要再对instance加一个限制操作，即用volatile来修饰instance。</p><p><strong>最终代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">SingletonLazy</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(SingletonLazy.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>至此，这段“健壮”的代码基本可以满足使用了~</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-线程引入</title>
    <link href="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/"/>
    <url>/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、计算机的组成</h1><p><strong>1、CPU</strong>：中央处理器，一台电脑最核心的部分，通过指令来完成各种算术运算和逻辑判断，是人类科技巅峰之作</p><p><strong>补充</strong>：</p><p><strong>cpu虽然技术门槛非常高</strong>，但是很<strong>便宜</strong>，这是因为<strong>cpu每年都在更新换代</strong>，并且<strong>每一代cpu的提升幅度都比较大</strong>，因此并不保值。intel的创始人之一提出了一个<strong>摩尔定律</strong>：集成电路上可容纳的晶体管数量每隔大约18至24个月就会翻倍，从而导致芯片性提升接近一倍，同时成本也下降一半。</p><p>在cpu中还有<strong>寄存器</strong>，用于<strong>暂时存储指令，操作数和中间结果</strong>，寄存器的<strong>存储空间更小</strong>，<strong>访问速度更快</strong>(相比于内存)，大概相差3-4个数量级，因此为了协调工作，cpu又引入了“缓存”来协调 寄存器 和 内存 之间的速度。</p><p><strong>2、存储器</strong>：分为内存和外存。</p><p><strong>内存：速度快，空间小，成本高，不能持久保存</strong></p><p><strong>外存：速度慢，空间大，成本小，可持久保存</strong></p><p>这里说的快和慢是内存和外存相对而言的~</p><p><strong>3、输入设备</strong>：键盘、鼠标、摄像头…</p><p><strong>4、输出设备</strong>：显示器、打印机、扬声器…</p><h1>二、操作系统</h1><h2 id="0x00-什么是操作系统">0x00 什么是操作系统</h2><p>市面上存在着许多的操作系统，如：<strong>Windows11，linux，mac os， android，ios</strong>…</p><p>这些操作系统，需要<strong>对下管理硬件设备，对上提供稳定的运行环境</strong></p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815091501568.png" class title="image-20230815091501568"><p>由于操作系统毕竟只是一个软件，不可能识别所有硬件设备，不过硬件设备就这么几个大类，因此操作系统只要知道每个大类中有什么功能，然后硬件产商在开发硬件的同时开发一个驱动程序(软件)，让操作系统通过这个驱动程序完成对硬件设备的控制。可以这么理解：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815091420684.png" class title="image-20230815091420684"><h2 id="0x01-进程-任务">0x01 进程/任务</h2><p>一个运行起来的程序就叫做进程。每个进程要想运行，就需要消耗一定的系统资源。因此<strong>进程是系统资源分配的基本单位。</strong></p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815092300478.png" class title="image-20230815092300478"><h2 id="0x02-管理进程">0x02 管理进程</h2><p>一个操作系统上可能跑了很多进程，那如何对这些进程管理呢？两方面：描述、组织</p><p>1、<strong>使用类来描述一个进程</strong>，把管理的每个对象都用属性表示出来</p><p>2、<strong>使用数据结构组织这些进程对象</strong>，类似于双向链表，方便创建、销毁</p><p>在系统中专门有一个结构体(操作系统内核是c/c++写的，java中结构体相当于类)来描述进程的属性，这个结构体叫做**“进程控制块”PCB**。</p><hr><p>PCB时一个非常庞大的结构体，包含很多的属性，在这就讨论一些比较重要的属性。</p><p><strong>1、pid：</strong></p><p><strong>进程的身份标识</strong>，每一个进程都会有一个pid，同一时刻，不同进程之间的pid是不同的。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815093901192.png" class title="image-20230815093901192"><p><strong>2、内存指针</strong></p><p><strong>描述了进程持有的“内存资源“</strong>，每个进程运行的时候，都会分配一定的内存空间。这个进程的内存空间，具体在哪，分配的内存空间有哪些部分，每个部分是干啥的，有这么一组指针来进行区分。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815093901192.png" class title="image-20230815095135867"><p><strong>3、文件描述符</strong></p><p><strong>描述了进程持有的“硬盘资源”</strong>，类似于顺序表这样的数据结构，有很多元素。如果一个进程涉及到了文件操作，保存数据啥的，就需要与硬盘挂钩，于是需要通过文件读写的方式来操作，将硬盘上的数据修改/读取。</p><hr><p>我们都知道一个程序的运行离不开cpu的运转，也就是说<strong>每个进程都需要消耗cpu资源</strong>，那<strong>怎么体现cpu资源</strong>呢？答案：<strong>进程的调度</strong>。</p><p>早期的操作系统，是一个“<strong>单任务操作系统</strong>”，<strong>同一时刻只有一个进程能运行</strong>，运行下一个进程就会退出当前进程，此时就不需要考虑调度问题，但随着发展，后面都支持<strong>多任务</strong>了，那如何运行这多个进程呢？——<strong>分时复用</strong>！</p><p>假设<strong>cpu是单核</strong>，如果使用分时复用的方法，就是<strong>将1s分成许多份，每个进程获取其中的一份或者多份，cpu在这一份的时间内执行这个进程</strong>。这样的执行方式叫作<strong>并发执行</strong>，只要我们时间<strong>轮转的够快</strong>(分成的份数够多)，此时看起来就像是同时执行一样(<strong>宏观上是同时执行的，微观上是分时复用</strong>)。</p><p>现代的<strong>cpu都是多个核心</strong>了，此时我们可以在同一时刻使用两个核心执行进程，这种执行方式叫做并行执行，也就是说<strong>在微观上也是同时执行的</strong>。</p><p>不过在应用层，我们感知不到是并发还是并行，其内部都是通过系统调度来选择的。平时普通的程序员也不会去具体区分是并发还是并行，因此<strong>常常使用“并发”来代指并行和并发</strong>。</p><p>那<strong>操作系统如何进行进程调度呢</strong>？通过如下属性~</p><hr><p><strong>4、进程的状态</strong></p><p>表示进程的状态，如就绪、运行、阻塞等，以指导操作系统的调度决策。</p><p><strong>就绪状态</strong>：进程准备好运行，只等待操作系统分配处理器时间。</p><p><strong>阻塞状态</strong>：进程某种执行条件不具备，导致这个进程暂时无法参与cpu的调度执行。例如：进程等待用户输入…</p><p><strong>运行状态</strong>：进程当前正在cpu上执行其指令，正在占用cpu资源，以完成其所需的计算和任务。</p><p><strong>5、进程的优先级</strong></p><p>操作系统在调度多个进程的时候并非一视同仁，有的进程会给更高的优先级，优先执行。例如：接受QQ消息，晚个几秒钟也没啥关系。</p><p><strong>6、进程的上下文</strong></p><p>进程从cpu离开之前，需要保存当前数据，把当前cpu中寄存器的状态都记录到内存中，等到下次进程回到cpu上执行的时候，再把保存的值恢复回去，进程就沿着上次执行到的位置继续执行，类似于游戏打了一半，然后去吃饭了，等下次继续的时候，读取数据恢复到上次的关卡。</p><p><strong>补充：</strong></p><p>CPU中有些寄存器没有特殊含义，只是用来保存运算的中间结果，还有些寄存器是有特定含义的。</p><p><strong>1、程序计数器</strong></p><p>存储的是一个内存地址，用来保存当前执行到哪个指令(可以理解为指针)。一个进程在运行的时候，操作系统会将里面的指令和数据加载到内存中并形成地址，然后CPU就会从内存中通过查询地址的方式找到指令并执行指令。</p><p><strong>2、维护栈相关的寄存器</strong></p><p>程序在调用函数的时候会创建栈帧，而栈是一块空间，通过维护头和尾就可以知道个空间的位置，大小。如：ebp寄存器是存储的地址是栈底，esp寄存器存储的是栈顶，通过修改esp的值就可以实现“入栈”，”出栈“操作。</p><p><strong>3、其他的通用寄存器</strong></p><p>一般是用来保存计算的中间结果。如：当前有一个表达式, 10+20+30+40,假设现在算完了前面两项的和，但还没来得及算后面的，此时进程调度走了，就需要将保存计算的前面两项的和的寄存器的值备份到上下文中。</p><p><strong>7、进程的记账信息</strong></p><p>通过优先级的机制，对不同的进程分配了不同权重的资源，不过有可能会出现极端的情况，将所有资源都分配给了某个进程，其他进程没有分配到，通过记账信息记录当前进程在cpu的执行情况(执行时间)，然后<strong>操作系统可以参考记账信息来进行下一次的调度进程</strong>。</p><h2 id="0x03-虚拟内存空间">0x03 虚拟内存空间</h2><p><strong>早期的操作系统，程序运行时分配的内存就是“物理内存”</strong>，这样就会导致，我的A程序通过某种方式访问到B程序的内存空间，然后进行修改，这就有可能会使B程序崩溃，为了防止这种情况，就<strong>引入了“虚拟内存空间”</strong>。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815095135867.png" class title="image-20230816211910788"><p>操作系统通过使用“虚拟内存地址”，不直接分配物理内存，而是分配虚拟的内存空间，类似哈希的思想，通过某个key来寻找value。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230816211910788.png" class title="image-20230816212757122"><p>此时进程A想要操作某个内存中的数据，先通过虚拟内存地址告诉操作系统，然后操作系统将虚拟内存翻译成物理内存地址，进行修改，在翻译的过程中，操作系统就可以进行校验操作，如果是非法访问就可以处理，不会危害到别的进程了，保持了进程的独立性，为进程提供稳定的运行环境。</p><h1>三、线程</h1><p>当今时代大部分电脑的cpu都已经是多核心的了，因此我们可以充分利用这个特点，进行并发执行多个任务，从而提高程序的执行效率。</p><p>进行并发编程可以从两个方面：<strong>多进程、多线程</strong>。</p><h2 id="0x00-多进程">0x00 多进程</h2><p>通过多进程实现并发编程效果非常理想，但是多进程模型会有明显的缺点：<strong>太重量、效率不高</strong>。(相比多线程)</p><p>这是因为<strong>进程是资源分配的基本单位</strong>，每个进程都有自己的内存空间和系统资源，这就导致<strong>创建一个进程需要去申请资源，销毁一个进程需要去释放资源</strong>。如果频繁的进行创建/销毁进程，这个时候，开销就不能忽视了~</p><h2 id="0x01-多线程">0x01 多线程</h2><p>在Java中，更加鼓励使用多线程编程，这样就能很好的解决上述问题。这是因为<strong>线程是“轻量级进程”</strong>，<strong>创建/销毁比进程更快</strong>。</p><p><strong>线程不能独立存在，而是依附于进程。一个进程可以包含一个线程，也可以包含多个线程</strong>。一个进程在最开始的时候，至少要有一个进程，也可以根据需要创建多个线程，从而实现并发编程。</p><p>一个进程中，可以有多个线程，<strong>每个线程都是可以独立的进行调度的</strong>，而调度是根据pcb属性来进行的，因此<strong>一个拥有多个线程的进程需要使用多个pcb</strong>(pid、内存指针、文件描述符表共用一份)来进行维护。</p><p>同<strong>一个进程的多个线程</strong>之间，由于<strong>共用一份内存空间和文件资源</strong>，创建线程的时候，<strong>不需要再重新申请资源了</strong>，直接复用之前操作系统分配给进程的资源，省去了<strong>资源分配的开销，提高了效率</strong>。</p><p><strong>总得来说就是：</strong></p><p>1、一个进程拥有一个或多个线程</p><p>2、每个线程使用一个pcb来表示，每个线程都可以独立的去CPU上调度执行，所以pcb中的状态、上下文、优先级、记账信息是独立的，线程是调度执行的基本单位。</p><p>3、pcb中的pid、内存指针、文件描述符表共用一份，所以创建线程的时候不需要再申请资源，创建的效率更高。</p><h2 id="0x-02-多线程的问题">0x 02 多线程的问题</h2><p>1、我们知道可以通过创建额外的线程来帮我们提升效率，假设我们的线程创建的非常多，此时还能进一步提高效率吗？肯定是不能的，反而会因为要调度的线程太多了，导致调度的开销太大，进而降低了效率。</p><p>2、如果两个线程同时去争抢某个资源，这就会引起冲突，导致线程不安全。</p><p>3、如果某个线程生气了，出现了异常，此时如果没有妥善的处理，就容易使整个进程崩溃。例如：在程序中越界了，你却没有catch。</p><h2 id="0x-03-进程与线程的区别">0x 03 进程与线程的区别</h2><p>1、进程包含线程，一个进程可以有一个或多个线程。</p><p>2、同一个进程的线程之间共用一份资源，不用再申请资源。</p><p>3、线程是资源分配的基本单位，进程是调度执行的基本单位。</p><p>4、进程和线程都是用来实现并发编程的，但是线程比进程更轻量、高效。</p><p>5、进程拥有独立性，一个进程挂了不会影响到别的进程。但一个进程内的线程挂了可能会影响到其他线程。</p><h1>四、多线程编程</h1><p>如何使用Java进行多线程编程？</p><p>线程是操作系统的概念，操作系统提供了一些API，可以用来操作线程，Java针对操作系统的API进行了封装，因此<strong>Java程序员只需要掌握一套API</strong>就可以&quot;到处运行&quot;了~~</p><h2 id="0x00-如何创建线程">0x00 如何创建线程</h2><p>在Java中通过创建Thread类对象(本质是重写run方法，调用start方法)，来进行多线程操作。如果我们要想自定义一个线程的话，我们需要继承Thread。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个<strong>线程跑起来，是从它的入口方法，也就是从run方法开始执行的</strong>，类似于一个<strong>Java程序的入口是main方法</strong>一样，只不过运行一个Java进程，会创建一个主线程，而<strong>主线程的入口是main方法</strong>。</p><p>我们观察源码会发现，Thread类实现了Runnable接口，而这个接口内部就定义了一个抽象的run方法。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822083331688.png" class title="image-20230822083331688"><p>所以，我们只需要重写一下run方法，在里面写线程的代码逻辑。不过重写了run方法只是定义了方法，要想真正<strong>启动一个线程，我们还需要调用start方法</strong>(在Thread类中定义了)。</p><p>线程，启动！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//当前线程执行的入口</span><br>        System.out.println(<span class="hljs-string">&quot;线程 启动！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结：</strong></p><p>start、run方法都是Thread的成员方法。<strong>run方法只是描述了线程的入口</strong>，该执行什么代码。<strong>start方法则是真正的调用了系统API，在系统中创建了线程，再让线程调用run方法</strong>。</p><h2 id="0x01-线程如何执行">0x01 线程如何执行</h2><p>现有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//当前线程执行的入口</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;myThread线程在执行&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;main线程在执行&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822085201024.png" class title="image-20230822085201024"><p>通过观察，我们发现，<strong>在主线程开启一个线程的时候，主线程并不过阻塞</strong>，依旧会往下执行，而且线程执行的顺序也不是完全按照线程调用顺序，而是根据调度来决定。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822085820615.png" class title="image-20230822085820615"><hr><p>如果<strong>将调用start方法，改成调用run方法</strong>呢？</p><p>由于没有使用start方法，<strong>程序不会创建一个线程</strong>，而是去调用run方法，<strong>直到调用完run方法后，才会回来继续往下执行main方法</strong>。</p><hr><p>在多线程运行的时候，可以使用<strong>jconsole</strong>来观察到进程里的多线程情况。<strong>jconsole是jdk中的一个工具</strong>。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822090753214.png" class title="image-20230822090753214"><h2 id="0x02-线程的创建方式">0x02 线程的创建方式</h2><p>创建一个线程其实很简单，<strong>只需要你重写run方法(写自己的代码逻辑)，和调用start方法</strong>。而重写run方法可以通过继承Thread、实现Runnable接口、通过匿名内部类、使用lambda表达式…</p><p><strong>1、继承Thread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、实现Runnable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-comment">//由于Runnable接口没有start方法，所以得通过Thread的构造方法来创建。</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myThread);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、通过匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//程序代码</span><br>            &#125;<br>        &#125;;<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、基于lambda表达式</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Thread thread =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//程序代码</span><br>        &#125;);<br>        thread.<span class="hljs-built_in">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>五、Thread类及常用的方法</h1><h2 id="0x00-Thread类的构造方法">0x00 Thread类的构造方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Thread()</td><td>创建线程对象</td></tr><tr><td>Thread(Runnable target)</td><td>使用Runnable对象创建线程对象</td></tr><tr><td>Thread(String name)</td><td>创建线程对象，并命名</td></tr><tr><td>Thread(Runnable target, String name)</td><td>使用Runnable对象创建线程对象，并命名</td></tr><tr><td>Thread(ThreadGroup grop, Runnable target)</td><td>将线程分组管理</td></tr></tbody></table><h2 id="0x01-Thread的几个常用的属性">0x01 Thread的几个常用的属性</h2><table><thead><tr><th>属性</th><th>获取方法</th><th>说明</th></tr></thead><tbody><tr><td>ID</td><td>getId()</td><td>获取线程的身份标识符ID</td></tr><tr><td>名称</td><td>getName()</td><td>获取线程的名称</td></tr><tr><td>状态</td><td>getState()</td><td>获取线程的状态</td></tr><tr><td>优先级</td><td>getPriority()</td><td>获取线程的优先级</td></tr><tr><td>是否是后台线程</td><td>isDaemoin()</td><td>判断是否是后台线程</td></tr><tr><td>是否存活</td><td>isAlive()</td><td>判断是否存活</td></tr><tr><td>是否被中断</td><td>isInterrupte()</td><td>判断是否中断</td></tr></tbody></table><p><strong>补充</strong>：</p><p>1、<strong>ID是线程的身份标识</strong>，标识一个进程中的唯一线程，这个ID是Java给你分配的，并不是系统api提供的线程ID。</p><p>2、优先级，在理论上可以使优先级高的线程更容易被调度到，但站在应用程序的角度，很难察觉到。</p><p>3、后台线程，也叫做守护线程，与之对应的是前台线程。</p><p><strong>前台线程：当所有的前台线程执行结束后，进程才会结束执行</strong></p><p><strong>后台线程：后台线程的结束与否不会影响进程的结束。</strong></p><p>4、判<strong>断是否存活，是判断内核线程中是否还有，而不是判断Thread对象</strong>。Thread对象的生命周期往往比线程长，线程没了，Thread对象还在。</p><h2 id="0x02-中断一个线程">0x02 中断一个线程</h2><p>在C++中可以直接终止一个正在运行的线程，但是在Java中是不可以的，因此设计思路就是<strong>让这个线程中的run方法尽快的结束</strong>。如下：</p><p><strong>1、通过共享的标记，让线程退出</strong></p><p><strong>2、通过interrupt方法来中断线程</strong></p><p><strong>示例1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">Quit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(!Quit)&#123;<br>                System.out.println(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//手动设置退出</span><br><br>        Quit = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述方式是通过<strong>修改一个共享的变量，进行控制线程的运行的</strong>。但有如下缺点：</p><p>1、需要手动创建变量，比较麻烦。</p><p>2、当修改了变量，理应让线程立马去执行完剩下的代码，但如果线程此时sleep了，会到导致这个线程还要再睡一会，不符合我们的设计初衷(让线程尽快的执行结束)。</p><hr><p><strong>示例2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-comment">//currentThread() 返回的是 哪个线程调用，就返回哪个线程对象</span><br>           <span class="hljs-comment">//isInterrupted() 判断是否中断</span><br>           <span class="hljs-keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;<br>               System.out.println(<span class="hljs-string">&quot;线程正在工作&quot;</span>);<br>               <span class="hljs-keyword">try</span> &#123;<br>                   Thread.sleep(<span class="hljs-number">600</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>               &#125;<br>           &#125;<br>        &#125;);<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">//让线程中断</span><br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230823113549767.png" class title="image-20230823113549767"><p>抛出了一个异常，这是因为这个线程在sleep，然后interrupt()唤醒了线程，这就触发了sleep的异常。</p><p>但我明明是<strong>让线程中断的，但是线程依然在工作</strong>，这是为什么呢？</p><p><strong>解释：</strong></p><p>sleep的线程被interrupt唤醒后，此时sleep方法会抛出异常，同时**将&quot;终止标识符&quot;清除(**在Thread对象内部有一个终止标识符，interrupt方法本质是通过设置终止标识符来退出程序的)。</p><p>为什么要这样设定？是因为<strong>Java期望当线程收到终止信号的时候，能够自己决定接下来如何处理</strong>。也就是说如果在catch中捕获到异常，程序员可以自己决定接下来要干嘛，如果没有捕获到，run方法尽快结束就行。</p><h2 id="0x03-线程等待">0x03 线程等待</h2><p>用来控制线程结束的顺序，让一个线程等待另一个线程执行结束，再继续执行。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>join()</td><td>等待线程结束</td></tr><tr><td>join(long millis)</td><td>等待线程结束，最多等 millis 毫秒</td></tr><tr><td>join(long millis, int nanos)</td><td>等待线程结束，精度可以达到纳秒</td></tr></tbody></table><p><strong>说明：</strong></p><p>thread.join() 工作过程：<strong>如果thread线程正在运行，那调用join的线程就会阻塞，一直阻塞到thread线程执行结束，如果thread线程已经执行结束了，调用join的线程就不会阻塞，直接继续执行</strong>。</p><h2 id="0x04-线程状态">0x04 线程状态</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>Thread对象创建了，但还没调用start方法</td></tr><tr><td>TERMINATED</td><td>Thread对象还在，但内核中的线程已经没了</td></tr><tr><td>RUNNABLE</td><td>可运行的，线程已经在cpu上执行了/线程正在排队等待上cpu执行</td></tr><tr><td>TIME_WAITING</td><td>阻塞，由于sleep这种固定时间的方式产生阻塞</td></tr><tr><td>WAITING</td><td>阻塞， 由于wait这种不固定时间的方式成的阻塞</td></tr><tr><td>BLOCKED</td><td>阻塞，由于锁竞争导致的阻塞</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>javaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/07/31/MySQL/"/>
    <url>/2023/07/31/MySQL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>本文说明</strong>：2023的暑假中mysql的学习~ 学习的内容的侧重点不同于学校的理论，而是工作、面试中可能经常出现的内容~ 本文是针对小白和稍微有一些了解的用户所讲解的~</p><h1 id="一、数据库介绍"><a href="#一、数据库介绍" class="headerlink" title="一、数据库介绍"></a>一、数据库介绍</h1><h2 id="0x00-什么是数据库"><a href="#0x00-什么是数据库" class="headerlink" title="0x00 什么是数据库"></a>0x00 什么是数据库</h2><p>数据库是一个广义的概念：</p><ol><li><p>表示 “数据库” 这一门学科。研究如何设计实现一个数据库(造轮子)</p></li><li><p>表示一类软件，用来有效管理数据</p><p>……</p></li></ol><p>我们这里介绍的是mysql数据库管理软件。学科啥的太抽象了~</p><h2 id="0x01-数据库软件"><a href="#0x01-数据库软件" class="headerlink" title="0x01 数据库软件"></a>0x01 数据库软件</h2><p>数据库的软件大致可以分为下面几种：</p><ol><li><strong>Oracle</strong> ： 数据库软件中的大哥。但是因为软件要收费，而且Oracle数据库在使用的时候，必须搭配IBM的小型机(不是一般我们用的电脑)，才能发挥出十成功力， 但是小型机很贵，所以使用Oracle数据库的<strong>成本太高</strong>了，<strong>一般都是银行这种不差钱，且要保存非常重要的数据的公司才会使用</strong>。</li><li><strong>MySQ</strong>L：<strong>开源&amp;免费</strong>的数据库(白嫖能不香嘛)！不过已经被Oracle公司收购了~ 钞能力的强大 ~</li><li><strong>SQLSever</strong>：微软做的数据库，但是最初的时候，由于只支持Windows系统，而且还收费，而使用数据库的场景一般是服务器开发，用到的系统大多是Linux，所以到现在用的公司不是很多~</li><li><strong>SQLite</strong>：主打一个轻便。运行速度快，占用内存小，经常在嵌入式设备(智能冰箱、洗衣机、空调……)中使用~</li><li><strong>redis</strong>：与上面的数据库不同的是，redis是“<strong>非关系型数据库</strong>”。</li></ol><p><strong>补充</strong>：</p><p><strong>关系型数据库(比较传统的数据库)<strong>，是</strong>使用“表”</strong>这样的结构来组织数据的，<strong>对数据的格式要求较高</strong>，也就是说每一行的每一列都得与设置的含义匹配上。举个例子：我们创建一个int的二维数组， 里面就只能存放int型的数据，而非关系型，就类似创建一个object的二维数组，里面可以存放不止一种类型的数据。</p><p><strong>非关系型数据库</strong>，更加<strong>灵活</strong>，通常<strong>使用“文档”、“键值对”</strong>这样的结构来组织数据，也就是说<strong>一行&#x2F;条数据差异可以很大</strong>~</p><h2 id="0x02-MySQL结构"><a href="#0x02-MySQL结构" class="headerlink" title="0x02 MySQL结构"></a>0x02 MySQL结构</h2><p><strong>MySQL</strong>使用的是cs的结构，就是“<strong>客户端-服务器”</strong>结构。</p><p><strong>客户端</strong>：<strong>主动</strong>发起<strong>请求</strong>的一方</p><p><strong>服务器</strong>：<strong>被动响应</strong>客户端请求的一方。由于服务器不知道客户端什么时候请求，因此服务器需要一直等待~</p><p><strong>补充</strong>：</p><p>当客户端的数量越来越多的时候，那么他们对服务器的请求也越来越多，这就要求服务器要增加性能来应对这些请求，但是往后增加性能的成本会越来越高，因此，就出现了<strong>“分布式系统”</strong>，也就是说一台机器，<strong>既可以是服务器，也可以是客户端</strong>。当机器A想要请求资源的时候，可以对机器B发起，然后B可以看看自己有没有资源，没有的话就向其他机器请求，在这里面每一个就是一个对等体，所以也可以叫做<strong>peer to peer</strong>的模式。</p><p>虽然MySQL是客户端-服务器的结构，但是我们<strong>真实的数据是存储在硬盘上</strong>的，而<strong>服务器才是MySQL的本体，负责存储和管理数据</strong>~</p><h1 id="二、数据库操作"><a href="#二、数据库操作" class="headerlink" title="二、数据库操作"></a>二、数据库操作</h1><h2 id="0x00-创建数据库"><a href="#0x00-创建数据库" class="headerlink" title="0x00 创建数据库"></a>0x00 创建数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database [if not exists] 数据库名 charset 字符集名字;<br><br>#说明<br>#[]里面的内容是可加可不加的~<br>#if not exists 可以用来避免报错，使用场景是当我们要执行一系列的SQL语句时，如果存在了同名数据库，此时依旧会执行后面的SQL语句<br>#charset 也可以写成 character set 可以指定当前数据库使用什么编码方式<br>#在写完SQL语句后要加;号，表示此行语句写完了，因为mysql客户端允许你输入的时候换行<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p>不同的字符集，会产生不同的编码方式，也就是说在不同的字符集下，一个汉字占用几个字节是不同的。例如：<strong>gbk编码</strong>，一个<strong>汉字占用2个字节</strong>，<strong>utf8编码</strong>，一个<strong>汉字占3个字节</strong>。</p><h2 id="0x01-查看所有数据库"><a href="#0x01-查看所有数据库" class="headerlink" title="0x01 查看所有数据库"></a>0x01 查看所有数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br><br>#列出当前mysql服务器上一共有哪些数据库<br></code></pre></td></tr></table></figure><h2 id="0x02-选中数据库"><a href="#0x02-选中数据库" class="headerlink" title="0x02 选中数据库"></a>0x02 选中数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据库名;<br><br>#当我们想要对数据进行操作的时候，我们首先要选中数据库，可以理解为指向性技能~<br></code></pre></td></tr></table></figure><h2 id="0x03-删除数据库"><a href="#0x03-删除数据库" class="headerlink" title="0x03 删除数据库"></a>0x03 删除数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database 数据库名;<br><br>#删除一个数据库，会删除里面的所有内容，非常危险(从删库到跑路~)<br>#当年炉石服务器就发生了严重的数据问题，服务器选择了回档，但还好补偿够给力，玩家选择了集体失忆~<br></code></pre></td></tr></table></figure><h1 id="三、表操作"><a href="#三、表操作" class="headerlink" title="三、表操作"></a>三、表操作</h1><h2 id="0x-00-字段类型"><a href="#0x-00-字段类型" class="headerlink" title="0x 00 字段类型"></a>0x 00 字段类型</h2><p>一些常用的类型。</p><table><thead><tr><th>数据类型</th><th>大小</th><th>说明</th><th>对应java类型</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td></td><td>Integer</td></tr><tr><td>bigint</td><td>8字节</td><td></td><td>Long</td></tr><tr><td>double</td><td>8字节</td><td></td><td>Double</td></tr><tr><td>decimal(M,D)</td><td>M&#x2F;D最大值+2</td><td>M指定数的长度，D表示小数点显示到D位数</td><td>BigDecimal</td></tr><tr><td>varchar(N)</td><td>0-65535字节</td><td>可变长度字符串，N表示字符串长度</td><td>String</td></tr><tr><td>datetime</td><td>8字节</td><td>插入格式：“YY-MM-DD 00:00:00”</td><td>java.util.Date</td></tr></tbody></table><p>有了这些类型，那么就可以开始创建一张表，开始存储数据了~</p><h2 id="0x-01-创建表"><a href="#0x-01-创建表" class="headerlink" title="0x 01 创建表"></a>0x 01 创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(列名 类型, 列名 类型......);<br><br>#创建一张表，指定列的属性<br></code></pre></td></tr></table></figure><h2 id="0x-02-查看所有表"><a href="#0x-02-查看所有表" class="headerlink" title="0x 02 查看所有表"></a>0x 02 查看所有表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br><br>#查看当前数据库中所有的表<br></code></pre></td></tr></table></figure><h2 id="0x-03-查看表结构"><a href="#0x-03-查看表结构" class="headerlink" title="0x 03 查看表结构"></a>0x 03 查看表结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc 表名;<br><br>#查看指定表的结构<br>#desc 的全称是 describe 描述<br></code></pre></td></tr></table></figure><h2 id="0x-04-删除表"><a href="#0x-04-删除表" class="headerlink" title="0x 04 删除表"></a>0x 04 删除表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table 表名;<br><br>#删除指定表，比较危险需要慎重<br></code></pre></td></tr></table></figure><h1 id="四、SQL的增删改查"><a href="#四、SQL的增删改查" class="headerlink" title="四、SQL的增删改查"></a>四、SQL的增删改查</h1><p>增删改查也称crud，全称create、read、update、delete，是数据库非常基础的部分，也是后端开发工作中主要的一部分。</p><h2 id="0x-00-插入数据"><a href="#0x-00-插入数据" class="headerlink" title="0x 00 插入数据"></a>0x 00 插入数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values (值, 值......);<br><br>#此处的值需要和表的列进行一一对应， 也就是值的个数和类型要匹配<br><br>insert into 表名 (列名, 列名......) values (值, 值......);<br><br>#此处的值需要和前面的列名匹配，如果有的列没有赋值，会进行赋默认值<br><br>insert into 表名 values (值, 值......), (值, 值......);<br><br>#一次插入多个数据，相比于分多次插入会有性能的提升。因为每次一次操作客户端都要向服务器请求，服务器要响应，这一定会影响性能。<br></code></pre></td></tr></table></figure><h2 id="0x-01-删除数据"><a href="#0x-01-删除数据" class="headerlink" title="0x 01 删除数据"></a>0x 01 删除数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from 表名 where 条件;<br><br>#删除表中某一行数据<br>#如果不加where的话，将会删除表中所有数据！<br></code></pre></td></tr></table></figure><h2 id="0x-02-修改数据"><a href="#0x-02-修改数据" class="headerlink" title="0x 02 修改数据"></a>0x 02 修改数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名 set 列名 = 值 where 条件;<br><br>#将表中某一列的值修改<br>#如果不加where的话，将会修改表中所有数据！<br></code></pre></td></tr></table></figure><h2 id="0x-03-查询数据"><a href="#0x-03-查询数据" class="headerlink" title="0x 03 查询数据"></a>0x 03 查询数据</h2><h3 id="3-1-全列查询"><a href="#3-1-全列查询" class="headerlink" title="3.1 全列查询"></a>3.1 全列查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名;<br><br>#把表中所有行所有列的数据查询出来<br># * 表示通配符，代指所有列<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p><strong>select * 是一个危险操作</strong>。如果当前这个表的数据特别多，可能会把<strong>硬盘的IO跑满</strong>， 此时其他程序想要访问硬盘，会非常慢。而且由于是客户端-服务器的结构，我们是通过客户端发起请求，然后服务器通过网络将查询的结构返回给客户端，此时数据太多的话， 可能会<strong>把网卡的带宽跑满</strong>，其他客户端通过网络访问服务器将非常慢~</p><h3 id="3-2-指定列查询"><a href="#3-2-指定列查询" class="headerlink" title="3.2 指定列查询"></a>3.2 指定列查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名, 列名...... from 表名 ;<br><br>#指定查询表中指定列的数据<br></code></pre></td></tr></table></figure><h3 id="3-3-查询字段为表达式"><a href="#3-3-查询字段为表达式" class="headerlink" title="3.3 查询字段为表达式"></a>3.3 查询字段为表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 +-*/ 数字 from 表名;<br><br>#一边查询，一边进行计算<br>#这里的操作不会对真正的数据库中的数据进行修改，相当于临时的<br></code></pre></td></tr></table></figure><h3 id="3-4-别名"><a href="#3-4-别名" class="headerlink" title="3.4 别名"></a>3.4 别名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 as 别名 from 表名;<br><br>#将某一列查询后面改个名字，一般配套表达式使用<br>#这里的as可以省略也可以不省略(通常建议不省略，防止看花眼)~<br></code></pre></td></tr></table></figure><h3 id="3-5-去重"><a href="#3-5-去重" class="headerlink" title="3.5 去重"></a>3.5 去重</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct 列名, 列名...... from 表名;<br><br># distinct 修饰某个列/多个列, 此时查询的结果中相同的数据只会保留一个<br></code></pre></td></tr></table></figure><h3 id="3-6-排序"><a href="#3-6-排序" class="headerlink" title="3.6 排序"></a>3.6 排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名, 列名...... from 表名 order by 列名 desc/asc;<br><br>#以某一列的数值为准，进行排序操作<br>#如果写了desc 那就是降序，如果不写或者写了asc 那就是升序<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p>如果order by 列1, 列2, 列3  写了多个字段，那么会先按照字段的顺序进行排序，比如，现在回先按照列1进行排序，如果列1的值相同，那么再比较列2 ，以此往复~</p><h3 id="3-7-条件查询"><a href="#3-7-条件查询" class="headerlink" title="3.7 条件查询"></a>3.7 条件查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 where 条件;<br></code></pre></td></tr></table></figure><p>条件中存在着一些运算符，我们来认识一下~</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;</td><td>大于，大于等于，小于，小于等于</td></tr><tr><td>&#x3D;</td><td>等于，NULL 不安全，例如 NULL &#x3D; NULL 的结果是 NULL</td></tr><tr><td>&lt;&#x3D;&gt;</td><td>等于，NULL 安全，例如 NULL &lt;&#x3D;&gt; NULL 的结果是 TRUE(1)</td></tr><tr><td>!&#x3D;, &lt;&gt;</td><td>不等于，推荐写成 !&#x3D;</td></tr><tr><td>between a0 and a1</td><td>范围匹配，[a0, a1] 都是闭区间，如果 a0 &lt;&#x3D; value &lt;&#x3D; a1，返回 TRUE(1)</td></tr><tr><td>in (n1, n2, …..)</td><td>离散化，如果是 (n1, n2, ……) 中的任意一个，返回 TRUE(1)</td></tr><tr><td>is null</td><td>是 null</td></tr><tr><td>is not null</td><td>不是null</td></tr><tr><td>like</td><td>模糊匹配。后面可以接通配符类似于癞子，或者%表示大于等于0个字符，_表示一个字符</td></tr></tbody></table><p>还有一些逻辑运算符~</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>多个条件必须都为 TRUE(1)，结果才是 TRUE(</td></tr><tr><td>OR</td><td>任意一个条件为 TRUE(1), 结果为 TRUE(1)</td></tr><tr><td>NOT</td><td>条件为 TRUE(1)，结果为 FALSE(0)</td></tr></tbody></table><p><strong>注意</strong>：</p><p><strong>where 条件可以使用表达式，但不能使用别名。</strong></p><p>因为<strong>select 条件查询的执行顺序</strong>：</p><ol><li>遍历表中每个记录</li><li>根据记录的值带入条件，根据条件进行筛选</li><li>如果这个记录条件成立，则保留当前记录，然后进行列上的表达式计算(或者重命名啥的)</li><li>如果有order by， 再进行排序</li></ol><p>所以，在条件筛选的优先级高于列上的表达式计算，因此使用别名的话，sql服务器就不认识了~</p><h3 id="3-8-分页查询"><a href="#3-8-分页查询" class="headerlink" title="3.8 分页查询"></a>3.8 分页查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 limit n offset x;<br><br>#从索引为x的记录(第一条记录的索引为0)开始， 查询出 n 条记录<br></code></pre></td></tr></table></figure><p>以上都是基础的SQL查询语句，不过很实用~</p><h1 id="五、约束"><a href="#五、约束" class="headerlink" title="五、约束"></a>五、约束</h1><p>有时候，数据库中数据是有约束的，比如 性别列，你不能填一些奇奇怪怪的数据~</p><p>如果靠人为的来对数据进行检索约束的话，肯定是不行的，人肯定会犯错~因此就需要让计算机对插入的数据进行约束要求！</p><p><strong>约束的使用语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create 表名 (列名 类型 约束);<br><br>#在创建表的时候对某一列数据进行约束操作<br></code></pre></td></tr></table></figure><p><strong>在mysql中提供了如下约束</strong>：</p><table><thead><tr><th>约束</th><th>说明</th></tr></thead><tbody><tr><td>not null</td><td>某一列的数据不能为null值</td></tr><tr><td>unique</td><td>某一列中的值唯一</td></tr><tr><td>default</td><td>规定没有给某列赋值时为默认值</td></tr><tr><td>primary key</td><td>not null 和 unique 的结合。记录身份的标识，一般配合自增主键使用</td></tr><tr><td>foreign key</td><td>保证一个表中的数据匹配另一个表中的值的参照完整性</td></tr><tr><td>check</td><td>保证列中的值符合指定条件</td></tr></tbody></table><p>注意：使用约束的话，一定会数据库的效率有影响！</p><p>由于not null、 unique、default、check比较容易，这里就对主键(primary key)和外键(foreign key) 进行解释。</p><h2 id="主键primary-key"><a href="#主键primary-key" class="headerlink" title="主键primary key"></a>主键primary key</h2><p>主键可以理解为记录的身份标识，就像身份证一样是我们每个人的身份标识，既不能为空，又不能重复。</p><p><strong>一张表里只能有一个主键</strong>，毕竟是身份标识嘛，存在多个了，以谁为准???</p><p>虽然主键只能有一个，但是<strong>主键不一定是一列</strong>，可以用<strong>多个列共同构成主键</strong>(联合主键)。</p><p>由于主键具有unique属性，因此我们一般<strong>配合mysql中 ”自增主键”</strong> 来使用，也就是会自动分配一个逐个增长的值~</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名 (列名 类型 primary key auto_increment);<br></code></pre></td></tr></table></figure><p>如果手动插入一个数据，此时<strong>数据库会与主键最高的值进行比较</strong>，如果高了就更新，<strong>此后自动分配的值也会从这个最高值进行增长</strong>！</p><p><strong>拓展</strong>：</p><p>如果是<strong>分布式系统</strong>，在<strong>同一时间插入了一个数据</strong>，此时<strong>自增主键就会出错</strong>，那么如何处理这种并发场景呢？</p><p><strong>一般会使用一个公式来形成主键</strong>：</p><p>分布式主键值 &#x3D;  时间戳 + 机房编号&#x2F;主机号 + 随机因子   此处使用的是字符串拼接操作!!!</p><p>前面两个可以<strong>防止在同一时间不同机器的的主键冲突</strong>，后面的<strong>随机因子</strong>可以<strong>防止同一时间同一机器的主键冲突</strong>，但是理论上还是有可能存在冲突的~</p><h2 id="外键foreign-key"><a href="#外键foreign-key" class="headerlink" title="外键foreign key"></a>外键foreign key</h2><p>案例引入： </p><p>现在我们有两张表，一张是学生表，里面有学号、姓名、班级号字段，另一张表示班级表，里面有班级号、班级名字段。</p><img src="/2023/07/31/MySQL/image-20230803084857974.png" class title="image-20230803084857974"><img src="/2023/07/31/MySQL/image-20230803085241442.png" class title="image-20230803085241442"><p>我们细细观察，可以发现，肯定是先有班级表，学生的班级号才能确定，但是现在突然冒出了一个classId 为 300的学生，但是在我们的班级表中不存在这个班级号，为了防止这种情况发生，我们可以使用外键约束~</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名 (列名 类型, 列名 类型, ......, foreign key (列名) references 主表名(列名));<br><br>#我们创建学生表的时候可以这样写：<br>#create table student (id int, name varchar(20), classId int, foreign key （classId） references class(classId));<br>#student表的classId 的所有数据都要出自于class表的classId这一列，也就是说如果class表中没有这个班级号，那么我们插入的学生信息将会报错~<br></code></pre></td></tr></table></figure><p><strong>使用外键</strong>之后，<strong>被约束的表就称为子表</strong>， <strong>另一张表相对的就是父表</strong>，<strong>子表</strong>中的那一个字段的<strong>数据</strong>都要<strong>出自父表</strong>。当然，力的作用是相互的，约束也不例外，当我们想要<strong>删除&#x2F;修改父表的约束子表的那个字段</strong>，如果子表<strong>已经引用</strong>过了，那么我们将会<strong>删除&#x2F;修改失败</strong></p><p><strong>注意</strong>：</p><p><strong>父表中约束子表的字段必须为主键或者unique！！！</strong></p><h1 id="六、表的设计"><a href="#六、表的设计" class="headerlink" title="六、表的设计"></a>六、表的设计</h1><p> 在实际的场景中，有大量的数据，我们需要明确当前要创建几个表，每个表有什么字段，这些表中是否存在一定的联系。</p><p>因此根据实际开发就整理出了三大范式~</p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>例如：<strong>一个学生只有一个账号，一个账号只属于一个学生</strong>。</p><p>此时我们设计两张表，让其中的一张表存储另一张表的<strong>唯一</strong>属性，这样我们可以通过这个属性就能找到想要的值了。或者也可以将两张表整合，成为一张表。</p><img src="/2023/07/31/MySQL/image-20230813092055975.png" class title="image-20230813092055975"><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>例如：<strong>一个学生只能属于一个班级，一个班级可以拥有多个学生。</strong></p><p>此时我们设计两张表，<strong>将那个“一”的表中添加上“多”的表中的唯一的字段</strong>。</p><p><strong>补充</strong>：如果是redis这种能够支持数组类型的数据库，我们可以不这样设计，可以使用一个数组类型，用来存储多个学生。如下图：</p><img src="/2023/07/31/MySQL/image-20230813093004691.png" class title="image-20230813093004691"><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>例如：一个学生可以选多门课程，一个课程可以被多名学生选择。</p><p>此时我们需要再<strong>创建一张表来描述这两张表之间的关系</strong>。</p><img src="/2023/07/31/MySQL/image-20230813093735349.png" class title="image-20230813093735349"><h1 id="七、查询增强-进阶"><a href="#七、查询增强-进阶" class="headerlink" title="七、查询增强(进阶)"></a>七、查询增强(进阶)</h1><p><strong>查询操作有很多的花样，但一般实际开发中最最最常使用的还是前面基础的crud操作。</strong></p><h2 id="0x-00-聚合查询"><a href="#0x-00-聚合查询" class="headerlink" title="0x 00 聚合查询"></a>0x 00 聚合查询</h2><p>之前的<strong>表达式查询</strong>是对于一条记录上的<strong>列与列</strong>之间进行运算的，如果要针对<strong>行与行之间进行运算</strong>呢？这时候就要用到<strong>聚合查询</strong>了~</p><p>首先来了解一些聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>count()</td><td>返回查询数据的个数</td></tr><tr><td>sum()</td><td>返回查询数据的总和，不是数字没意义</td></tr><tr><td>avg()</td><td>返回查询数据的平均值，不是数字没意义</td></tr><tr><td>max()</td><td>返回查询数据的最大值，不是数字没意义</td></tr><tr><td>min()</td><td>返回查询数据的最小值，不是数字没意义</td></tr></tbody></table><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count([distinct]表达式) from 表名;<br>select sum([distinct]表达式) from 表名;<br>select avg([distinct]表达式) from 表名;<br>select max([distinct]表达式) from 表名;<br>select min([distinct]表达式) from 表名;<br><br>#注意：<br>#count(*) 和 count(列名)的区别，count(*)会把一条为null的数据也统计进去，而count(列名)则不会<br>#如果计算字符串的值，需要字符串合法，因为mysql会尝试转成double<br></code></pre></td></tr></table></figure><h2 id="0x-01-分组查询"><a href="#0x-01-分组查询" class="headerlink" title="0x 01 分组查询"></a>0x 01 分组查询</h2><p>分组查询一般会配合聚合查询，因为分组查询会把几行数据看做是一行，如果不使用聚合查询，那么显示的结果为一组中某一个数据。</p><p><strong>举例：</strong></p><p><strong>求各班的平均成绩：</strong></p><img src="/2023/07/31/MySQL/image-20230808091752885.png" class title="image-20230808091752885"><p>那么我们的代码得这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(socre) from class group by class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808091927650.png" class title="image-20230808091927650"><p><strong>使用group by的时候，还可以搭配条件。此时我们需要区分该条件是分组前的，还是分组之后的？</strong></p><p>如果是分组前，使用where条件查询</p><p>如果是分组后，使用having条件查询</p><p>举例：</p><p><strong>查询各班平均分，但是学生成绩不能超过100</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(socre) from class where socre &lt;= 100 group by class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808092930270.png" class title="image-20230808092930270"><p><strong>查询平均分大于100分的班级</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(score) from class group by class_id having avg(score) &gt; 100;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808093239831.png" class title="image-20230808093239831"><h2 id="0x-02-联合查询"><a href="#0x-02-联合查询" class="headerlink" title="0x 02 联合查询"></a>0x 02 联合查询</h2><p>联合查询也就是多表查询，就是在多张表上进行查询。但是联合查询也会有<strong>一些问题</strong>……</p><p><strong>联合查询会产生笛卡尔积</strong>，也就是说表A中的每一条数据都会与表B中每一条数据进行组合，如果A表中的数据个数为100，表B中的数据个数为100，那么最终会产生100<em>100条数据。但是仔细观察，会发现有一些数据是“非法”的。*<em>笛卡尔积是简单的排列组合，穷举所有情况，因此你我们需要筛选数据~</em></em></p><p><strong>如果要联合n张表进行查询，那么我们需要使用n-1个连接条件，才不会出现笛卡尔积的现象~</strong></p><img src="/2023/07/31/MySQL/image-20230808094213698.png" class title="image-20230808094213698"><p><strong>此时就出现了笛卡尔积，但是仔细观察，会发现class_id 不同的数据都组合到了一起，因此我们需要一个连接条件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select student.class_id, student.name, class.socre from student, class where student.class_id = class.class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808094523104.png" class title="image-20230808094523104"><hr><p><strong>由于多表查询一般比较复杂，我们可以按照如下的步骤来写：</strong></p><p>1、先进行指定哪个几个表，进行笛卡尔积</p><p>2、指定连接条件，去除笛卡尔积</p><p>3、精简列数据</p><p>以上查询都是基于“内连接“的操作，然而mysql还提供了”外连接“(左外连接，右外连接)</p><hr><p><strong>案例引入</strong>：</p><p>现有如下表<img src="/2023/07/31/MySQL/image-20230808095817918.png" class title="image-20230808095817918"></p><p>此时<strong>student的每一条记录都可以在score表中找到对应，每一个score中记录也可以在student表中找到对应。</strong></p><p>此时我们使用外内接或者内连接查询的结果是一样。</p><img src="/2023/07/31/MySQL/image-20230808100511716.png" class title="image-20230808100511716"><p><strong>但是如果不存在记录，那么内连接与外连接就会天差地别~</strong></p><img src="/2023/07/31/MySQL/image-20230808100806990.png" class title="image-20230808100806990"><p>外连接分为左外连接和右外连接。</p><p><strong>左外连接：</strong>以左表为基准，保证左侧表的每个数据都会出现在最终的结果集里，如果右表没有与之对应的记录则显示null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名1 left join 表2 on 连接条件<br></code></pre></td></tr></table></figure><p><strong>右外连接：</strong>以右表为基准，保证右侧表的每个数据都会出现在最终的结果集里，如果左表没有与之对应的记录则显示null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名1 right join 表2 on 连接条件<br></code></pre></td></tr></table></figure><p>我们还可以用集合图来表示这些连接的关系：</p><img src="/2023/07/31/MySQL/image-20230809090138583.png" class title="image-20230809090138583"><p><strong>补充</strong>：</p><p>以上我们都是针对于两个表进行联合查询的，但我们甚至还可以<strong>将一个表当做两个表来进行联合查询</strong>，这样我们就能在一张表中进行 <strong>行与行的比较</strong>~这种连接方式一般被称为<strong>“内连接”</strong>。</p><p>自连接的查询跟上面的联合查询基本没什么区别，需要注意将两张表进行别名操作~</p><h2 id="0x-03-子查询"><a href="#0x-03-子查询" class="headerlink" title="0x 03 子查询"></a>0x 03 子查询</h2><p><strong>子查询是将多个简单的SQL语句拼成一个复杂的SQL, 也就是说将某一个查询的结果看做是一张表，然后进行操作，但本质是在套娃</strong>。因此我们实际也是可以用简单的查询完成子查询的操作的~ (合成2048？合成复杂SQL！)</p><p>语法形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 where 列名 = (select 列名 from 表名 where 列名 = (套娃下去....));<br></code></pre></td></tr></table></figure><h2 id="0x-04-合并查询"><a href="#0x-04-合并查询" class="headerlink" title="0x 04 合并查询"></a>0x 04 合并查询</h2><p>合并查询就是<strong>将多个sql的查询结果集 合并在一起</strong>。合并的两个sql结果集的列，需要<strong>匹配，列的个数和类型得是一致的</strong>！<strong>合并的时候是会进行去重的，如果不想要去重，得使用 union all</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名1 列名2 from 表1 union [all] select 列名3 列名4 from 表2;<br></code></pre></td></tr></table></figure><p><strong>最终结果</strong>：</p><img src="/2023/07/31/MySQL/image-20230809092917129.png" class title="image-20230809092917129"><h1 id="八、索引"><a href="#八、索引" class="headerlink" title="八、索引"></a>八、索引</h1><p>由于我们在使用数据库的时候，<strong>大部分操作的都是查询操作</strong>，但是我们<strong>每一次进行查询都需要遍历一遍表</strong>中所有数据，这会花费O(n)的时间，因此数据<strong>引入了“索引”</strong> 也就是在底层使用了数据结构来进行<strong>优化查询</strong>的操作，但是可能会<strong>造成插入&#x2F;删除操作变慢</strong>和<strong>消耗空间</strong>。</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show index from 表名;<br><br>#查看表中哪一列有索引<br><br>create index 索引名字 on 表名(列名);<br><br>#对某一列创建索引<br><br>drop index 索引名 on 表名;<br><br>#删除索引<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>一个索引是针对列来指定的。<strong>只有针对这一列进行查询时</strong>，查询速度才能被索引优化~如果进行全列查询的话，那还是需要遍历表的。</p><p><strong>如果某一列被primary key、foreign key、unique所约束的话，会自动创建索引</strong>。</p><p><strong>创建索引</strong>也是一个相当<strong>危险的操作</strong>，因为创建索引是需要对现有的数据进行大规模的整理，如果数据非常多，很容易就把服务器卡住，一般来说创建索引的时候都是在创建完表后立马操作，一旦使用久了的话， 需要慎重操作。不过也可以采用分治的思想，一点一点将数据写入到创建好的表中~</p><hr><p><strong>以上内容都是基础的知识，但是面试常考查的是索引的底层~~</strong></p><p>(由于本人水平有限，在此先简单介绍简单的内容知识~)</p><p>索引的底层使用的是<strong>一种类似二叉搜索树</strong>(在极端情况下，<strong>二叉搜索树的时间复杂度为O(n)，AVL树，红黑树能达到O(logn)</strong>)的树 ，也就是<strong>一棵改进的树形结构：B+树</strong>。可能会好奇，为啥不用哈希表呢？时间复杂度可以O(1),这是因为<strong>在查询的过程中我们往往会进行范围查询，而哈希表只能进行精确的查询</strong>，因此我们不使用哈希表。</p><img src="/2023/07/31/MySQL/f070fdfc8e4b40dda2ebee96c3c6170a.jpeg" class title="img"><p>B+树顾名思义是在B树的基础上改进的。那啥是B树呢？</p><p>B树：是一棵<strong>N叉搜索树</strong>，每个节点的度不确定，一个节点上保存N个数据的值，划分出N + 1个区间，每个区间衍生出一棵子树。</p><p><strong>逻辑上存储结果如下</strong>：</p><img src="/2023/07/31/MySQL/image-20230810085349816.png" class title="image-20230810085349816"><p>而B+树则是对B树的改进，感觉像是针对数据库进行量身定做。</p><p>如果使用B树会有遇到什么问题呢？假如我们现在要使用范围查询去查询10-40之间的数。我们在如下图中进行观察：</p><img src="/2023/07/31/MySQL/image-20230810093232881.png" class title="image-20230810093232881"><p><strong>搜索过程大致如下</strong>：</p><p>我们先要进行小于20区间的搜索，然后再进行20-40区间的搜索，里面<strong>包含大量“向下递”(需要开辟内存空间)，”回溯“的操作</strong>，如果一棵区间子树的高度较高，我们需要花费较多时间进行这个子树的搜索，恰巧另一些范围内的数据在另一棵子树上，那么我们又要花费较多时间进行搜索。<strong>总的来说，由于范围查询，我们有时要搜索多棵子树，这会导致效率的下降。</strong></p><p>基于这些缺点，B+树进行了优化。首先，<strong>B+数在每个非叶子节点上存储的是索引</strong>(B树上就是实际的值)，<strong>所有数据都是存储在叶子节点上</strong>，<strong>B+树再使用了一个链表</strong>，将所有叶子节点连了起来，这就导致了<strong>范围查询更加高效</strong>，因为只要找到了一个符合要求的叶子节点，我们就直接对链表进行遍历，省去了再搜索其他子树的操作。</p><hr><p><strong>B+树的优点(相比B树、哈希、红黑树)：</strong></p><p>1、<strong>是一棵N叉搜索树，因此树的高度比较小</strong>。</p><p>2、<strong>磁盘IO次数更少，效率更高</strong>。</p><p>红黑树是一棵平衡二叉搜索树，为了平衡需要进行旋转操作，而<strong>旋转操作时针对于整棵树</strong>的，但是因为数据库中可能存储着大量的数据，我们往往<strong>不能将所有的数据读取到内存中，因此需要部分多次读取</strong>，这就导致了旋转可能会有问题且效率不高，而且也<strong>无法利用磁盘预读</strong>(存储器某一个位置被访问了，那么其附近位置也会被访问)。</p><p>在B树中，<strong>每一个节点是在一个硬盘区域中</strong>，可以利用磁盘预读，<strong>一次读硬盘就能取出整个节点(<strong>多个键值对)。而</strong>读取硬盘的时间远大于内存比较的时间</strong>，近似于 读一次硬盘 &#x3D; 内存1w次比较。</p><p>在B+树中，<strong>非叶子节点上是存的索引信息</strong>，而对应数据库中一行数据可能内容比较多，但是单单某一行的<strong>某一列(索引)所占空间往往只有几个字节</strong>，因此我们能够<strong>将所有的索引信息读取到内存中进行比较</strong>，然后找到叶子节点上的值，再通过链表遍历的方式进行搜索，从而大大减少了IO次数。</p><p>3、所有的查询最终要落实到叶子节点，因此整体的<strong>查询效率比较稳定</strong>，而B树中可能在前面的节点就能找到，复杂度为O(1), 不稳定。</p><p>4、<strong>非常擅长范围查询</strong></p><h1 id="九、事务"><a href="#九、事务" class="headerlink" title="九、事务"></a>九、事务</h1><p>事务：一组数据库的操作语句，这些操作将会被视为一个整体，保证要么这些语句全部执行，要么“一个都不执行”。</p><h2 id="0x-00-案例引入"><a href="#0x-00-案例引入" class="headerlink" title="0x 00 案例引入"></a>0x 00 案例引入</h2><img src="/2023/07/31/MySQL/image-20230806090729717.png" class title="image-20230806090729717"><p>现在，SQL语句执行完了第一条但是还没执行第二条的时候，突然电脑关机&#x2F;程序崩溃了…….</p><p>张三一看已经扣了钱，但是李四却没有收到，这就很尴尬了。此时我们需要引入“事务”，来帮助我们解决这个问题，也就是要么张三扣了钱，李四收到了钱，要么就无事发生~ <strong>我们将这种“要么全部执行，要么相当于没有执行”这个特殊的性质称为“原子性”</strong></p><h2 id="0x-01-事务的特性ACID"><a href="#0x-01-事务的特性ACID" class="headerlink" title="0x 01 事务的特性ACID"></a>0x 01 事务的特性ACID</h2><p>1、<strong>原子性(Atomicity)</strong> ：<strong>事务出现的原因</strong>。将一系列sql语句看成一个整体，要么全部执行，要么通过回滚的方式，恢复如初。</p><p>2、 <strong>一致性(Consistency)</strong> ：事务执行之前和之后，数据都不能出现非法的情况。</p><p>3、 <strong>持久性(Durability)</strong> ：事务做出的修改，都是在硬盘上持久保存的，即使在系统故障或者崩溃的情况下，事务执行的修改都是有效的。</p><p>4、<strong>隔离性(Isolation)</strong> ：<strong>由于mysql是客户端-服务器的模式，会存在并发的情况，即多个用户在同一时间请求服务器。</strong>事务的执行是相互隔离的，一个事务的操作不应该影响其他事务的操作。</p><p><strong>补充</strong>：</p><p><strong>并发操作往往能提高效率，但是会降低准确性</strong>。mysql数据库在并发执行的时候，会遇到如下问题：</p><p><strong>1、脏读：</strong></p><p>事务A在**改变(修改，增加，删除) **数据</p><p>事务B在事务A未提交的时候就来读取数据</p><p>后来事物A可能在事物B读完了数据后又修改了或者回滚了，此时事务B读到数据就是“脏”的，即无效的。</p><p><strong>脏读也就是在写的过程中进行读操作。 <strong>解决脏读问题，思路是</strong>对写操作进行加锁</strong>，告诉事务B在我写的时候，不要来读取数据。此时并发性降低了，隔离性提高了，效率降低了，准确性提高了~</p><p><strong>2、不可重复读：</strong></p><p>事务B在读取数据</p><p>事务A<strong>修改或删除了数据</strong>然后提交事务</p><p>事务B第二次读数据的时候，发现两次读到的数据不相同，也就是事务A在事物B两次读取的时候进行了修改。</p><p><strong>不可重复读也就是在读的过程中进行了写操作</strong>。解决不可重复读问题，思路是<strong>对读操作进行加锁</strong>，告诉事务A在我读的时候，不要来修改数据。</p><p><strong>3、幻读：</strong></p><p>事务B在读数据</p><p>事务A此时<strong>插入了数据</strong>然后提交了事务</p><p>事务B第二次读数据，然后读到了与第一不一样的结果集。</p><p><strong>幻读与不可重复读类似，区别在于幻读是强调插入操作，不可重读是修改操作。</strong>解决幻读的问题，思路是<strong>引入串行化的方式</strong>，保证绝对的串行执行事务，此时完全没有并发了。</p><p>针对以上的问题，mysql提供了4种隔离级别，可以在mysql配置文件中修改~</p><table><thead><tr><th>隔离级别</th><th>解决问题</th></tr></thead><tbody><tr><td>read uncommitted(读未提交)</td><td>隔离性最低，但效率最高</td></tr><tr><td>read committed(读已提交)</td><td>给写加锁，解决脏读</td></tr><tr><td>repeatable read(可重复读)</td><td>给读、写加锁，解决脏读、不可重复读</td></tr><tr><td>serializable(串行化)</td><td>严格按照串行的方式，一个一个执行事务，解决脏读、不可重复读、幻读</td></tr></tbody></table><h2 id="0x-02-操作语句"><a href="#0x-02-操作语句" class="headerlink" title="0x 02 操作语句"></a>0x 02 操作语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction; #开启事务<br><br>进行一些列sql语句......<br><br>rollback;   #回滚事务，恢复到未执行事务前<br><br>commit;   #提交事务<br><br><br>#事务的使用很简单，但需要关注事务背后的一些原理性质的内容<br></code></pre></td></tr></table></figure><h1 id="十、JDBC"><a href="#十、JDBC" class="headerlink" title="十、JDBC"></a>十、JDBC</h1><h2 id="0x-00-什么是JDBC"><a href="#0x-00-什么是JDBC" class="headerlink" title="0x 00 什么是JDBC"></a>0x 00 什么是JDBC</h2><p>JDBC代表Java连接数据库，也就是<strong>通过Java代码操作数据库</strong>。</p><p>在初期，市面上有着许多的数据库，如：MySQL, Oracle, SQL Sever…….但是<strong>不同的数据库</strong>大概率是<strong>由不同的程序员所开发</strong>出来的，因此在使用方面<strong>存在差异(如：方法名，类名，功能不同)<strong>，这就大大的增加了程序员的难度，苦不堪言~这时候就需要一个真正有分量的大佬来一统江湖！！！于是</strong>Java就自己设计出一套API的规范</strong>，让各种各样的<strong>数据库都要遵守</strong>，因此<strong>java程序员只需要会一套自己的API就好了</strong>，大大减少了学习成本~</p><img src="/2023/07/31/MySQL/image-20230811195028006.png" class title="image-20230811195028006"><p><strong>各厂商实现了接口</strong>后将其打包好并发布，如果<strong>Java程序员想要操作MySQL的话，只需要导入MySQL实现的jar包</strong>，然后在程序中调佣Java自己制定的API即可。其他如果数据库也同理，不过需要导入不同厂家的jar包。</p><h2 id="0x-01导入jar包"><a href="#0x-01导入jar包" class="headerlink" title="0x 01导入jar包"></a>0x 01导入jar包</h2><p>在使用Java操作数据库前需要先将下载好的jar包(可以去中央仓库下载)导入程序。</p><p><a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">Maven Repository: mysql » mysql-connector-java (mvnrepository.com)</a></p><img src="/2023/07/31/MySQL/image-20230811200839804.png" class title="image-20230811200839804"><p>然后就可以在程序中使用了。</p><h2 id="0x-02-使用JDBC"><a href="#0x-02-使用JDBC" class="headerlink" title="0x 02 使用JDBC"></a>0x 02 使用JDBC</h2><p><strong>1、创建DataSource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里我们可以看到，我们<strong>创建了一个dataSource</strong>，但是使用的时候却<strong>进行了向下转型</strong>，那<strong>为什么不直接创建一个MysqlDataSource的呢？</strong>这是因为要<strong>降低代码的耦合度</strong>，让MysqlDataSource这个类名不要扩散到代码的其他地方，如果后续要操作别的数据库了，代码的改动比较小。</p><p>那<strong>Url是什么</strong>呢？<strong>url表示网络上的资源位置通俗讲就是网址</strong>，因为服务器是cs模式，需要通过网络交互。</p><p><strong>127.0.0.1 表示IP地址</strong>，描述网络上一个主机所在的位置，不过这个IP地址是一个<strong>“环回IP”</strong>，即自己把数据发给自己。这是因为<strong>jdbc程序和mysql服务器都在我们自己的电脑上</strong>~</p><p><strong>3306 表示端口号，用来区分不同进程的。</strong></p><p>test 表示数据库名称。</p><p>？&amp; &#x2F;…… 这些符号是一些特殊符号。这里从？后面，表示访问资源的时候，需要哪些参数</p><p>useSSL&#x3D;false 表示是否要加密</p><p>这里dataSource光写url的话 只能找到mysql服务器，但还得登录认证，因此还需要设置账号，密码。</p><p><strong>2、和数据库服务器建立连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在创建的时候千万不要选错！！！</strong></p><img src="/2023/07/31/MySQL/image-20230811203528869.png" class><p><strong>3、构造sql语句并执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(1, &#x27;张三&#x27;)&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> statement.executeUpdate(); <span class="hljs-comment">//看看修改了几条</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过使<strong>用preparedStatement进行对sql语句的检查</strong>，在<strong>将sql发给服务器之前先看看有没有语法错误</strong>啥的，这样就能<strong>减小mysql服务器的开销</strong>。</p><p>如果要执<strong>查询操作</strong>的话，要<strong>使用executeQuery()方法</strong>，如果是<strong>改操作</strong>的话，<strong>使用executeUpdate()方法</strong>。</p><p><strong>4、执行完后关闭连接，释放资源</strong></p><p><strong>程序通过代码和服务器进行通信</strong>，是<strong>需要消耗一定的资源</strong>的。因此在程序结束后需要告知服务器，<strong>释放这些资源</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(1, &#x27;张三&#x27;)&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> statement.executeUpdate();<br><br>        statement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>后申请的先释放！</strong></p><h2 id="0x-03自定义sql语句"><a href="#0x-03自定义sql语句" class="headerlink" title="0x 03自定义sql语句"></a>0x 03自定义sql语句</h2><p>刚刚我们是为了演示总得流程，所以sql语句就在程序中写死了，如果我们要插入我们想要的数据该怎么办呢？</p><p>方案一：</p><p>创建变量让用户输入赋值修改就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into sutdent values (&quot;</span> + id + <span class="hljs-string">&quot;, &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>这样写，既不优雅，也不安全。这么多符号很容易出错，然后如果用户是高手，懂<strong>sql注入</strong>的话，那就危险了。name一栏不好好写，写成 删库 那就惨了。</p><p>方案二：</p><p>创建变量并<strong>使用占位符</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(?, ?)&quot;</span>;<br>statement.setInt(<span class="hljs-number">1</span>, id); <span class="hljs-comment">//当心第一个是从1位置开始计算的，而不是0</span><br>statement.setString(<span class="hljs-number">2</span>, name);<br></code></pre></td></tr></table></figure><p>这样就好多了~</p><h2 id="0x-04-输出查询结果"><a href="#0x-04-输出查询结果" class="headerlink" title="0x 04 输出查询结果"></a>0x 04 输出查询结果</h2><p>查询在数据库操作中是大头，怎么将查询结果输出呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from student&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span>  statement.executeQuery();<br>        <span class="hljs-keyword">while</span>(resultSet.next())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>            System.out.println(id + <span class="hljs-string">&quot;,&quot;</span> + name);<br>        &#125;<br><br>        resultSet.close();<br>        statement.close();<br>        connection.close();<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们的<strong>查询结果返回的是一张临时表</strong>，此时需要<strong>使用ResultSet类来接收结果集</strong>。然后要进行<strong>遍历ResultSet</strong>才能取出全部数据。</p><p>遍历ResultSet是<strong>通过调用next方法</strong>获取临时表中的每一行数据。这个next方法<strong>相当于在临时表中有一个“光标”，一开始的时候指向的是第一行的前一个位置，而每一次执行，就相当于将光标移到下一行。如果走到最后一行，将会放回false。</strong></p><p><strong>resultSet中提供了getXXX方法</strong>，里面的<strong>参数是列名</strong>，这样就可以拿到一行中的某一列数据了。</p><p>最后记得要释放result资源~</p><hr><p>以上就是一些mysql中高频常用的知识了~</p><p>完结，撒花~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包装类|认识泛型</title>
    <link href="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/"/>
    <url>/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、包装类"><a href="#一、包装类" class="headerlink" title="一、包装类"></a>一、包装类</h1><h2 id="0x-00为什么要有包装类？"><a href="#0x-00为什么要有包装类？" class="headerlink" title="0x 00为什么要有包装类？"></a>0x 00为什么要有包装类？</h2><p>众所周知，在java中，<strong>类的祖先是Object</strong>，但是基本数据类型，如int、float等并不是继承自Object，但是<strong>为了在泛型代码中可支持基本类型</strong>，Java给每个基本类型都对应了一个包装类型。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="0x-01装箱和拆箱"><a href="#0x-01装箱和拆箱" class="headerlink" title="0x 01装箱和拆箱"></a>0x 01装箱和拆箱</h2><p><strong>装箱</strong>：把一个 <strong>基本数据类型</strong> 转化为 <strong>包装类</strong></p><p><strong>拆箱</strong>：把一个 <strong>包装类</strong> 转化为 <strong>基本数据类型</strong></p><p><strong>装箱</strong>又分为 <strong>自动装箱</strong> 和 <strong>显示装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> n; <span class="hljs-comment">//自动装箱</span><br>    System.out.println(i1);<br>    <br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> Integer.valueOf(n); <span class="hljs-comment">//显示装箱</span><br>    System.out.println(i2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们可以通过javap进行反汇编，看看编译器偷偷隐藏了什么操作</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517200812580.png" class title="image-20230517200812580"><p><strong>拆箱</strong>也分 <strong>自动拆箱</strong> 和 <strong>显示拆箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n.intValue();<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517201347559.png" class title="image-20230517201347559"><p><strong>我们可以看到，就算我们没有显示调用intValue方法，编译器也在底层偷偷的调用了intValue方法</strong></p><h2 id="0x-02注意"><a href="#0x-02注意" class="headerlink" title="0x 02注意"></a>0x 02注意</h2><p>当写出如下代码时，需要注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    System.out.println(c == d);<br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    System.out.println(a == b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果为：true和false</strong></p><p><strong>因为在Integer底层，装箱的时候会调用valueOf方法，而这个方法，会根据数字给定的范围，返回的是不同的“结果”。</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517202210854.png" class title="image-20230517202210854"><p><strong>当i &gt;&#x3D; -128 &amp;&amp; i &lt;&#x3D; 127的时候，会返回一个static共享的数组，而不在这个范围的时候，就会返回一个新的对象！</strong></p><h1 id="二、认识泛型"><a href="#二、认识泛型" class="headerlink" title="二、认识泛型"></a>二、认识泛型</h1><h2 id="0x-00什么是泛型"><a href="#0x-00什么是泛型" class="headerlink" title="0x 00什么是泛型"></a>0x 00什么是泛型</h2><p>一般的类和方法，只能使用具体的类型，要么是基本类型，要么是自定义类型，如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。——《Java编程思想》</p><p><strong>泛型，通俗讲，就是适用于多种类型。从代码上讲，就是对类型实现了参数化</strong>。(当我们自己写一个冒泡排序的时候，我们用的是int，如果我们要排序别的类型，就得对代码改改，但通过泛型，我们可以一次编写，随便使用~)</p><h2 id="0x-01案例引入"><a href="#0x-01案例引入" class="headerlink" title="0x 01案例引入"></a>0x 01案例引入</h2><p>如果现在要实现一个类，类中包含一个数组成员，这个数组中可以存放任何类型的数据，也可以返回数组中的某个下标值。</p><p><strong>因为要放任何类型的数据，因此我们要类的祖先Object数组来存放。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span>&#123;<br>        <span class="hljs-keyword">return</span> array[pos];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, Object val)</span>&#123;<br>        array[pos] = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写，会有<strong>两个缺陷</strong>：</p><p><strong>1.数组想放啥类型的数据就放什么类型的数据，不便于管理。</strong></p><p><strong>2.当我们取出数据的时候，还需要强制类型转换，很麻烦。</strong></p><p>于是，就引出了泛型~</p><h2 id="0x-02泛型"><a href="#0x-02泛型" class="headerlink" title="0x 02泛型"></a>0x 02泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span>&#123;<br>        <span class="hljs-keyword">return</span> (T)array[pos];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, T val)</span>&#123;<br>        array[pos] = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当我们这样写，T就相当于参数，我们在使用的时候就可以传入所需要的类型，然后，一旦我们存数据的时候，如果类型不匹配，会报编译错误，然后我们在取数据的时候也不需要再强制类型转换了，解决了我们的痛点。</strong></p><p>如果我们把数组写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这样写是不对的,会报编译错误</span><br><span class="hljs-keyword">private</span> T[] arr = (T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这样写，也会有问题，因为泛型的编译机制。</span><br></code></pre></td></tr></table></figure><p>小结：</p><p>1.泛型是将数据类型参数化，进行传递的。因此程序员可以在编译时指定</p><p>2.使用<T>表示当前类是一个泛型类</T></p><h2 id="0x-03泛型的编译"><a href="#0x-03泛型的编译" class="headerlink" title="0x 03泛型的编译"></a>0x 03泛型的编译</h2><p>泛型是怎么编译的呢？简单来说，<strong>泛型会再编译的过程中，将所有的T替换为Object</strong>，我们称这种机制为 <strong>擦除机制</strong>。</p><p>现在我们来对这段代码进行解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T[] arr = (T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>如果我们这样写，尽管编译的时候能编译过，但是在Java中不允许你将数组类型强制转换为其他类型，在运行的时候会抛出异常！</p><p><strong>如下代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;bcd&quot;</span>;<br>String[] strs = (String[])arr;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230518162513603.png" class title="image-20230518162513603"><p><strong>原因是：将Object[]分配给String[]引用，程序报错。</strong></p><p><strong>通俗来讲，Object数组中可能存放任何类型的数据，运行时，直接转换，编译器认为是不安全的。</strong></p><p>因此，推荐如下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>底层源码也是这样写的~</p><h2 id="0x-04泛型的上界"><a href="#0x-04泛型的上界" class="headerlink" title="0x 04泛型的上界"></a>0x 04泛型的上界</h2><p>在定义泛型类的时候，有可能会对传入的类型进行一定的约束，可以通过类型边界来约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArr</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&gt;&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样写，就只能接受Base类和Base的子类类型了。因此我们可以通过这样的方式对类型进行约束。</p><p>当然，还可以”继承”接口，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFun</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt;<br></code></pre></td></tr></table></figure><p>如果这样写的话，那么传入的那个类型必须是实现了Compareable这个接口，也就是说这个类是可以比较的。</p><p>举个列子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFun</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">findMax</span><span class="hljs-params">(T[] arr)</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i].compareTo(ans) &gt; <span class="hljs-number">0</span>)&#123;<br>                ans = arr[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] integers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        MyFun&lt;Integer&gt; fun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFun</span>&lt;&gt;();<br>        System.out.println(fun.findMax(integers));<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样我们通过泛型，实现了一个可以得到任何类型的最大值的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象——简单工厂模式</title>
    <link href="/2023/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、案例引入"><a href="#一、案例引入" class="headerlink" title="一、案例引入"></a>一、案例引入</h1><p><strong>需求</strong>：写一个计算器，实现加减乘除基本功能。</p><p><strong>如果使用面向过程的思想来写</strong>，即用计算机的方式去思考，就会写出如下代码：</p><h2 id="面向过程代码"><a href="#面向过程代码" class="headerlink" title="面向过程代码"></a>面向过程代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                result = numA + numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                result = numA - numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                result = numA * numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result = numA / numB;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span> + numA + symbol + numB + <span class="hljs-string">&quot;=&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这样写，是可以满足需求，但是一旦需求发生改变，增加一个开根号功能，理论上你只需要在switch语句中增加一条，但是这样去写，会让加减乘除功能都来参与编译，万一你手贱，改动了别的功能呢？这就是面向过程所带来的一些弊端。</strong></p><p>举个例子：</p><blockquote><p>一个公司将所有员工的工资算法都放在了一起(就像上面计算器，将所有运算功能放在了一起)，哪天老板让你修改别人的工资，你一看自己工资比较低，还偷偷修改了自己工资的算法。</p><p>所以说这样的代码很危险，毕竟你无法保证每个人都不出错。</p></blockquote><p><strong>所以这时就要用到面向对象的编程思想了。</strong></p><h1 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h1><p>众所周知，面向对象有三大特性：封装，继承、多态。</p><p>我们可以先利用，<strong>封装。</strong></p><p><strong>先将整个程序分成两部分，一个是处理计算的，另一个是处理用户的输入。</strong></p><p>因此我们可以定义两个类，一个是用户类，即处理用户输入，另一个是计算类，用来计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Calculate.GetResult(numA, symbol, numB);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetResult</span><span class="hljs-params">(<span class="hljs-type">int</span> numA, <span class="hljs-type">char</span> symbol, <span class="hljs-type">int</span> numB)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                result = numA + numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                result = numA - numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                result = numA * numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result = numA / numB;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时还是解决不了会改动别的运算中的代码，因此我们还需要用到继承和多态</p><p><strong>我们将每个运算中相同的部分取出，即都需要两个操作数，和一个计算方法。而运算符号是特有的，我们稍后再处理</strong></p><p><strong>所以可以定一个一个父类，包含这些属性和行为。再运用重写，重写各自的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numA;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numB;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumA</span><span class="hljs-params">(<span class="hljs-type">int</span> numA)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numA = numA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumB</span><span class="hljs-params">(<span class="hljs-type">int</span> numB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numB = numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA + numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA - numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA * numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivOperation</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> numA / numB;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>这样来设计的话，当我要让你修改某一个功能的时候，我只需要把这个类给你，而不需要你再给你其他类，这样大大的降低了出错的可能性。</strong></p><p>代码写到这，还不能运行，因为还有符号部分没处理，不过我们可以通过去实例化对象，来处理运行相应的功能。即使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125;<br>        System.out.println(ret);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时代码看起来，<strong>有好多地方都是重复的，很臃肿</strong>，所以，此时我们可是使用<strong>”简单工厂模式</strong>“来帮我们解决。</p><h1 id="三、简单工厂模式"><a href="#三、简单工厂模式" class="headerlink" title="三、简单工厂模式"></a>三、简单工厂模式</h1><p><strong>简单工厂模式，就是通过创建一个类，来帮助你实例化对象，也就是你要实例化谁，直接通过这个“工厂”来创建。</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(<span class="hljs-type">char</span> symbol)</span>&#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在我们要进行加法运算就可以这样写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> OperationFactory.createOperation(symbol);<br>        op.setNumA(numA);<br>        op.setNumB(numB);<br>        ret = op.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样修改以后，就非常简洁了，使用的时候，直接调函数就行了，<strong>而且未来扩展功能的时候，只需要添加一个类，再在工厂类里的switch添加一下就行了。</strong></p><p>这才是面向对象的代码嘛~</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numA;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numB;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumA</span><span class="hljs-params">(<span class="hljs-type">int</span> numA)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numA = numA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumB</span><span class="hljs-params">(<span class="hljs-type">int</span> numB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numB = numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA + numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA - numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA * numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivOperation</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> numA / numB;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(<span class="hljs-type">char</span> symbol)</span>&#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//        if(symbol == &#x27;+&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new AddOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125;else if(symbol == &#x27;-&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new MinOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125; else if(symbol == &#x27;*&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new MulOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125; else if(symbol == &#x27;/&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new DivOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(ret);</span><br><br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> OperationFactory.createOperation(symbol);<br>        op.setNumA(numA);<br>        op.setNumB(numB);<br>        ret = op.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4_18深夜思考</title>
    <link href="/2023/04/19/4-18%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/"/>
    <url>/2023/04/19/4-18%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、为什么选择敲代码</h1><p>因为高考很糟糕，然后稀里糊涂的填了几个志愿，结果莫名其妙的来到了计科专业。不过，在我初中的时候，我也曾想过当一名程序员，可能那时候喜欢游戏吧~ 而到了高中呢，太过压抑，而且我对其他的专业也不懂，在学校只能看见老师，正巧我在b站上看到一个叫国家玮的老师，他讲课的风格颠覆了我对老师的印象，我想成为向他一样的老师，但是最终考的并不如意，或许冥冥之中自由安排…</p><h1>二、为什么选择java而不选择C++</h1><p>我现在(大二下)感觉这个问题其实很奇怪，我觉得大部分都被互联网搞的太焦虑了，大家都不看好java，觉得学java毕业就找不到工作了。我感觉，<strong>首先</strong>找工作不是一门简单的事情，哪有毕业就一定能找到的呢，而且大家都追求好公司，据说不是找不到，是找不到心仪的，有点高不成低不就的感觉；<strong>其次</strong>，难道学C++就一定能找到工作吗？一门语言而已，c++和java不都是擅长做后端开发吗？<strong>最后</strong>，在学c++的时候，我感受到的是语法的复杂，而学习java的时候，我感受到了面向对象的编程方式，还挺好玩，于是我选择了java。</p><p><strong>个人看法</strong>：其实选哪个都差不多，不过对于考研啥的，还是选C++好一点，毕竟考研书啥的资料大部分都是C++的。</p><h1>三、为什么骑行</h1><p>因为在b站上看到了一个博主，骑行了西藏，于是，我想我是否能试试骑行桂林呢？目前已经把桂林骑得差不多了，下个目标可能是柳州了？可能骑行会很累，但我不后悔，这是我自己选择的路~</p><h1>四、最后</h1><p>无论结果如何，我相信，人生没有那条路是白走的，可能会走错了路，但是你看到了别人看不到的风景，路上结识了一辈子的知己，收获了温暖的回忆和宝贵的经历。</p><p>也许，我现在所做的一切，看不到任何成果，但是水滴石穿，绳锯木断，不要迷茫，不要彷徨，我不是没有成长，而是在扎根，在打基础，所有的付出，都会有回报的。</p><p>也许，多年以后，当和家人、朋友坐在一起唠嗑时，打开自己尘封的记忆，那一幕幕，跳出来，依旧鲜活而富有生命力。这些美好的记忆不会随着年华的飘零而逝去，而是会被镌刻在岁月里，最美好的地方。</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数据类型|运算符(与C对比)</title>
    <link href="/2023/04/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%8EC%E5%AF%B9%E6%AF%94/"/>
    <url>/2023/04/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%8EC%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、Java中的数据类型</h1><h2 id="0x01-基本数据类型">0x01 基本数据类型</h2><p>在 Java 中数据类型主要分为两类：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p>基本数据类型有4类：<strong>整形、浮点型、字符型、布尔型</strong>。细分为8种。如下：</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1 字节</td><td>-128 ~ 127</td></tr><tr><td>短整型</td><td>short</td><td>2 字节</td><td>-32768 ~ 32767</td></tr><tr><td>整型</td><td>int</td><td>4 字节</td><td>-2^31 ~ 2^31 - 1</td></tr><tr><td>长整型</td><td>long</td><td>8 字节</td><td>-2^63 ~ 2^63 - 1</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4 字节</td><td>有范围，一般不关注</td></tr><tr><td>双精度浮点数</td><td>double</td><td>8 字节</td><td>有范围，一般不关注</td></tr><tr><td>字符型</td><td>char</td><td>2 字节</td><td>0 ~ 65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>没有明确规定</td><td>true 和 false</td></tr></tbody></table><p><strong>值得注意的是</strong>：这里数据的类型大小和C语言不同的是，<strong>不论是在16位系统还是32位系统下</strong>，都是上述的大小。</p><p><strong>字符型</strong>在这里成了<strong>无符号的数</strong>了，<strong>还扩大成了2个字节</strong>。</p><p><strong>在C语言中，我们知道0表示假，非0表示真，然而在 Java中是使用boolean类型来表示真假，并且boolean类型不能与int类型转化</strong>，因此代码就不能写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-comment">//本意是想循环10次，但java中的boolean不能与int转化。</span><br>&#125;<br><br><span class="hljs-comment">//只能这样写</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>因此， Java 程序员不会遇到下述麻烦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(x = <span class="hljs-number">0</span>) <span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure><h2 id="0x02-类型转换">0x02 类型转换</h2><p>Java 是一个强类型编程语言。<strong>当不同类型之间的变量相互赋值的时候</strong>, 会有教严格的校验</p><p>例如：<strong>当我们将一个高精度的数赋值给低精度的数，由于会发生截断，编译器认为不安全，会报错。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.0</span>;<br>a = d; <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><p>如果是将一个低精度赋值给高精度的数，会进行类型转换。</p><p>类型转换又分为两种：<strong>自动(隐式)类型转换</strong>、<strong>强制(显示)类型转换</strong>。</p><hr><p><strong>自动类型转换</strong></p><p><strong>代码不需要经过任何处理，在代码编译时，编译器会自动进行处理</strong>。特点：<strong>数据范围小的转为数<br>据范围大的时会自动进行</strong>  。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>l = n; <span class="hljs-comment">//发生自动类型转换</span><br></code></pre></td></tr></table></figure><p>自动类型转换路线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>-&gt;<span class="hljs-type">short</span>-&gt;<span class="hljs-type">int</span>-&gt;<span class="hljs-type">long</span>-&gt;<span class="hljs-type">float</span>-&gt;<span class="hljs-type">double</span><br><span class="hljs-type">char</span>-&gt;<span class="hljs-type">int</span>-&gt;<span class="hljs-type">long</span>-&gt;<span class="hljs-type">float</span>-&gt;<span class="hljs-type">double</span><br></code></pre></td></tr></table></figure><p>可以将左边类型的变量赋值给右边类型的变量。</p><p><strong>强制类型转换：</strong></p><p>当进行操作时，代码需要经过一定的格式处理，不能自动完成。特点：数据范围大的到数据范围小的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>n = (<span class="hljs-type">int</span>)l; <span class="hljs-comment">//强制类型转换。告诉编译器我对此次类型转换负责！</span><br></code></pre></td></tr></table></figure><p>但是对于byte、short、char类型有些特别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>理论上这些操作，编译器不能通过，但是有这样的一个规则：</p><p><strong>当把具体数赋值给byte、short、char时，会先判断该数是否在这个类型的范围内，如果在就可以.</strong></p><p>这里的<strong>具体数值指的是字面常量：不能是变量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//可以</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">//byte b2 = a //不可以</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//short s1 = b1 + s; //不可以  </span><br></code></pre></td></tr></table></figure><h2 id="0x03-类型提升">0x03 类型提升</h2><p>不同类型的数据之间相互运算时，数据类型小的会被提升到数据类型大的。</p><ol><li><strong>int</strong>与<strong>long</strong>之间：<strong>int</strong>会被提升为<strong>long</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 编译出错: a + b==&gt;int + long--&gt; long + long 赋值给int时会丢失数据</span><br><span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 编译成功：a + b==&gt;int + long---&gt;long + long 赋值给long</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>byte</strong>与<strong>byte</strong>的运算</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>System.out.println(c);<br><span class="hljs-comment">// 编译报错</span><br>Test.java:<span class="hljs-number">5</span>: 错误: 不兼容的类型: 从<span class="hljs-type">int</span>转换到<span class="hljs-type">byte</span>可能会有损失<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br></code></pre></td></tr></table></figure><p>原因：由于计算机的 CPU 通常是按照 4 个字节为单位从内存中读写数据. <strong>为了硬件上实现方便, 诸如 byte 和 short这种低于 4 个字节的类型, 会先提升成 int</strong>, 再参与计算</p><p>因此要想编译通过，需要进行强制类型转换。</p><h1>二、运算符</h1><p>Java中运算符可分为以下：算术运算符(+ - */)、关系运算符(&lt; &gt; ==)、逻辑运算符、位运算符、移位运算符以及条件运算符等 。</p><p><strong>C语言中只能对整数取模</strong>，<strong>但在 Java 中 % 不仅可以对整型取模，也可以对double类型取模</strong>，但是没有意义，一般都是对整型取模的 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">11.5</span> % <span class="hljs-number">2.0</span>);<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><p><strong>对于++和–：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>b = b + <span class="hljs-number">1</span>; <span class="hljs-comment">//报错</span><br>b++; <span class="hljs-comment">//可以 会优化为 b = (byte)(b + 1)</span><br></code></pre></td></tr></table></figure><p><strong>对于 &amp;&amp;</strong> , 如果<strong>左侧表达式值为</strong> <strong>false,</strong> <strong>则表达式结果一定是</strong> <strong>false,</strong> <strong>无需计算右侧表达式</strong>.</p><p><strong>对于 ||</strong>, 如果<strong>左侧表达式值为</strong> <strong>true,</strong> <strong>则表达式结果一定是</strong> <strong>true,</strong> <strong>无需计算右侧表达式</strong>.</p><p><strong>&amp; 和 |</strong> ，如果表达式结果为 boolean 时, 也表示逻辑运算. 但与 &amp;&amp; || 相比, 它们不支持短路求值 ，因此他会对两边的表达式对进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">10</span> &gt; <span class="hljs-number">20</span> &amp; <span class="hljs-number">10</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// 程序抛出异常</span><br>System.out.println(<span class="hljs-number">10</span> &lt; <span class="hljs-number">20</span> | <span class="hljs-number">10</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// 程序抛出异常</span><br></code></pre></td></tr></table></figure><p><strong>对于移位操作符，与C语言不同的是，还有无符号右移&gt;&gt;&gt;</strong></p><p>无符号右移 &gt;&gt;&gt;: <strong>最右侧位不要了, 最左侧补 0</strong></p><p>即不会关注一个数的二进制中的符号是啥，直接补0，所以一个负数将会变成很大的正数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识java|Java的发展史|环境变量|JDK</title>
    <link href="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/"/>
    <url>/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文将讲述什么是Java、Java的发展史、比较一下C&#x2F;C++和Java的区别、环境变量的作用以及JDK是什么。</p></blockquote><h1 id="一、认识Java"><a href="#一、认识Java" class="headerlink" title="一、认识Java"></a>一、认识Java</h1><h2 id="0x01-Java是什么"><a href="#0x01-Java是什么" class="headerlink" title="0x01 Java是什么"></a>0x01 Java是什么</h2><p>Java是一门优秀的<strong>程序设计语言</strong>，它具有令人赏心悦目的语法和易于理解的语义  。</p><p>Java凭借着<strong>友好的语法</strong>、<strong>面向对象</strong>、<strong>内存管理</strong>和<strong>最棒的跨平台可移植性</strong>来吸引程序员。</p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410201938465.png" class><p>（Java之父——詹姆斯·高斯林)</p><p>Java有这样一句口号：“Write once，run anywhere” 即 <strong>一次编译，到处运行</strong>。指的是你可以写一个Java程序，然后能够在你朋友所拥有的的任何设备上执行。</p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410202641113.png" class title="image-20230410202641113"><h2 id="0x02-Java发展史"><a href="#0x02-Java发展史" class="headerlink" title="0x02 Java发展史"></a>0x02 Java发展史</h2><blockquote><p>Java 语言源于 1991 年 4 月，Sun 公司 <strong>James Gosling</strong>博士 领导的绿色计划(Green Project) 开始启动，此计划最初的目标是开发一种能够在各种消费性电子产品(如机顶盒、冰箱、收音机等)上运行的程序架构。这个就是Java的前身： Oak (得名与Java创始人James Gosling办公室外的一棵橡树)，但由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着<strong>1995</strong>年代互联网的发展<strong>，Sun公司看见</strong>Oak<strong>在互联网上应用的前景，于是改造了</strong>Oak<strong>，于</strong>1995<strong>年</strong>5<strong>月以</strong>Java<strong>的名称正式发布，并提出</strong>“Write once, Run anywhere” <strong>的口号</strong>。  </p></blockquote><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410203130293.png" class title="image-20230410203130293"><h2 id="0x03-Java-VS-C"><a href="#0x03-Java-VS-C" class="headerlink" title="0x03 Java VS C++"></a>0x03 Java VS C++</h2><h3 id="1、简单性"><a href="#1、简单性" class="headerlink" title="1、简单性"></a>1、简单性</h3><p>在Java中剔除了C++中许多很少使用、难以理解、易混淆的特性。可以这样理解：Java语法是C++语法的一个”纯净”版本。<strong>例如：Java中没有头文件、指针语法、结构体、联合体、运算符重载。</strong></p><h3 id="2、健壮性"><a href="#2、健壮性" class="headerlink" title="2、健壮性"></a>2、健壮性</h3><p>Java投入了大量的精力进行早期的问题检测以及后期的动态检测。<strong>Java采用的指针模型(底层)可以消除重写内存和损坏数据的可能性。例如：C++的拷贝构造，当对象销毁自动调用析构函数，可能由于前面是写的浅拷贝，而导致同一块空间释放了两次。</strong></p><h3 id="3、可移植性"><a href="#3、可移植性" class="headerlink" title="3、可移植性"></a><strong>3、可移植性</strong></h3><p>与C和C++不同的，Java规范中没有“依赖具体实现”的地方。<strong>基本教据类型的大小以及有关运算都做了明确的说明</strong>  </p><p>例如：<strong>Java 中的 int 永远为 32 位的整数</strong>  ，<strong>而在 C&#x2F;C++ 中</strong>， <u>int 可能是 16 位整数、 32 位整数</u>， 也可能是编译器提供商指定的其他大小 。唯一的限制只是 int 类型的大小不能低于 short int, 并且不能高于 long int。  </p><p>在 Java 中， 数据类型具有固定的大小， 这消除了代码移植时令人头痛的主要问题。 二进制数据以固定的格式进行存储和传输， 消除了字节顺序的困扰  。<strong>例如：在C&#x2F;C++中还存在大小端字节序存储的问题。</strong></p><h2 id="4、动态性"><a href="#4、动态性" class="headerlink" title="4、动态性"></a>4、动态性</h2><p>Java 与 C 或 C++ 相比更加具有动态性。 它能够适应不断发展的环境库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响。  一个很好的例子是： 从 Internet 下载代码，然后在浏览器上运行。 如果使用 C 或 C++, 这确实难度很大，不过 Java 设计者很清楚动态语言可以很容易地实现运行程序的演进。  </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>语言没有优劣之分，这个世界不是非黑即白的，每个语言都可能在某些领域表现出比其他语言更出色</strong>。比如：Objective C 和后来的 Swift 在 iOS 设备上就有着无可取代的地位， 浏览器中的处理几乎完全由 JavaScript 掌控。 Windows 程序通常都用 C++ 或 C# 编写 。Java 在服务器端编程和跨平台客户端应用领域则很有优势 。</p><p><strong>Java 的成功源于其类库能够让人们轻松地完成原本有一定难度的事情</strong>。 例如：联网Web 应用和并发。Java 减少了指针错误， 这是一个额外的好处， 因此使用 Java 编程的效率更高。但这些并不是 Java 成功的全部原因。  </p><h1 id="二、环境变量"><a href="#二、环境变量" class="headerlink" title="二、环境变量"></a>二、环境变量</h1><p>有很多人在装Java时，上网查资料会发现，都装完JDK都会让你去配置一下环境变量。</p><p><strong>那这是为什么呢？</strong></p><p>举个例子：当我运行游戏的时候，如果不是用快捷打开方式，那我们就需要去游戏安装的目录下找到exe文件打开，但是如果我们配置了环境变量，那我们可以随便打开一个命令窗口，输入指令，即可打开游戏。</p><p><strong>类比到编程：</strong></p><p>相当于在函数A中，创建了一个局部变量，在函数B中无法使用这个变量，但当我们配置了环境变量后，这个局部变量升级成全局变量了，现在在函数B中可以使用这个变量。</p><h1 id="三、JDK"><a href="#三、JDK" class="headerlink" title="三、JDK"></a>三、JDK</h1><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230411215831748.png" class title="image-20230411215831748"><h2 id="0x01-JDK"><a href="#0x01-JDK" class="headerlink" title="0x01 JDK"></a>0x01 JDK</h2><p>JDK全称 Java Development Kit， 即Java开发工具包，包含了Javac编译工具，java，JRE等工具。</p><p>JDK &#x3D; JRE + 开发工具集(javac, javap, java…….)</p><h2 id="0x02-JRE"><a href="#0x02-JRE" class="headerlink" title="0x02 JRE"></a>0x02 JRE</h2><p>JRE全称 Java Runtime Environment, 即Java运行时环境，包含了 JVM，Java基础类库。</p><p>JRE &#x3D; JVM + JavaSE标准类库</p><h2 id="0x03-JVM"><a href="#0x03-JVM" class="headerlink" title="0x03 JVM"></a>0x03 JVM</h2><p>JVM全称 Java Virtual Machine，即Java虚拟机， 用来运行Java代码。</p><p><strong>JDK 、JRE 、JVM关系图：</strong></p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410212254607.png" class title="image-20230410212254607"><hr><blockquote><p>参考资料：</p><p>《Java核心技术卷》</p><p>《Head First Java》</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言文件操作</title>
    <link href="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、文件的分类</h1><h2 id="1-1程序文件">1.1程序文件</h2><blockquote><p>例如：源程序文件 即 .c文件</p><p>​可执行程序 即 .exe文件</p><p>​…</p></blockquote><h2 id="1-2数据文件">1.2数据文件</h2><blockquote><p>例如：PPT、word文档、Excel表格…</p></blockquote><h1>二、文件的打开与关闭</h1><p>对于不使用文件相关操作的时候，数据的输入输出都是以<strong>终端</strong>为对象，即从终端的键盘输入数据，将<strong>内存中的运行结果</strong>输出到<strong>终端</strong>上。如下：</p><img src="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20230403202819947.png" class><p><strong>注意：输入输出都是站在内存的角度来看待的！</strong></p><hr><p>但是如果是对文件操作，同理。</p><p>如下：</p><img src="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20230403203212563.png" class><h2 id="2-1文件指针">2.1文件指针</h2><p><strong>每个被使用的文件</strong>都在<strong>内存</strong>中开辟了一个相应的<strong>文件信息区</strong>，用来存放，文件的名字，文件当前的位置等信息。</p><p>这些信息是<strong>保存在一个结构体变量</strong>中，该结构体类型是由系统声明的，取名<strong>FILE</strong></p><p><strong>例如：在VS2013编译环境下，就有如下申明：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> &#123;</span><br>    <span class="hljs-type">char</span> *_ptr;<br>    <span class="hljs-type">int</span> _cnt;<br>    <span class="hljs-type">char</span> *_base;<br>    <span class="hljs-type">int</span> _flag;<br>    <span class="hljs-type">int</span> _file;<br>    <span class="hljs-type">int</span> _charbuf;<br>    <span class="hljs-type">int</span> _bufsiz;<br>    <span class="hljs-type">char</span> *_tmpfname;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> <span class="hljs-title">FILE</span>;</span><br></code></pre></td></tr></table></figure><p>因此我们可以通过<strong>创建一个文件指针</strong>来对文件完成相应的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE* pf<span class="hljs-comment">//文件指针</span><br></code></pre></td></tr></table></figure><p><strong>ANSIC 规定使用fopen函数来打开文件，fclose来关闭文件</strong></p><p>举例：对一个文件进行写的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//打开文件，&quot;w&quot;表示是以写的方式打开文件。</span><br>FILE* pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <br>    <span class="hljs-comment">//关闭文件</span><br>    fclose(pf);<br>    pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打开文件方式有许多，如下：</strong></p><table><thead><tr><th>文件使用方式</th><th>含义</th><th>如果指定文件不存在</th></tr></thead><tbody><tr><td>“r”（只读）</td><td>为了输入数据，打开一个已经存在的文本文件</td><td>出错</td></tr><tr><td>“w”（只写）</td><td>为了输出数据，打开一个文本文件</td><td>建立一个新的文件</td></tr><tr><td>“a”（追加）</td><td>向文本文件尾添加数据</td><td>建立一个新的文件</td></tr><tr><td>“rb”（只读）</td><td>为了输入数据，打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb”（只写）</td><td>为了输出数据，打开一个二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab”（追加）</td><td>向一个二进制文件尾添加数据</td><td>出错</td></tr><tr><td>“r+”（读写）</td><td>为了读和写，打开一个文本文件</td><td>出错</td></tr><tr><td>“w+”（读写）</td><td>为了读和写，建议一个新的文件</td><td>建立一个新的文件</td></tr><tr><td>“a+”（读写）</td><td>打开一个文件，在文件尾进行读写</td><td>建立一个新的文件</td></tr><tr><td>“rb+”（读写）</td><td>为了读和写打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb+”（读写）</td><td>为了读和写，新建一个新的二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab+”（读写）</td><td>打开一个二进制文件，在文件尾进行读和写</td><td>建立一个新的文件</td></tr></tbody></table><p>因此，当我们要写一个文件，可以使用fopen函数，但打开也要关闭，可以使用fclose函数，最后再将指针置空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//打开文件</span><br>FILE* pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-comment">//确保打开成功</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//写文件</span><br><br><span class="hljs-comment">//关闭文件</span><br>fclose(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>三、文件的读写</h1><p>文件的读写可以使用如下函数：</p><table><thead><tr><th>字符输入函数</th><th>fgetc</th><th>所有输入流</th></tr></thead><tbody><tr><td>字符输出函数</td><td>fputc</td><td>所有输出流</td></tr><tr><td>文本行输入函数</td><td>fgets</td><td>所有输入流</td></tr><tr><td>文本行输出函数</td><td>fputs</td><td>所有输出流</td></tr><tr><td>格式化输入函数</td><td>fscanf</td><td>所有输入流</td></tr><tr><td>格式化输出函数</td><td>fprintf</td><td>所有输出流</td></tr><tr><td>二进制输入</td><td>fread</td><td>文件</td></tr><tr><td>二进制输出</td><td>fwrite</td><td>文件</td></tr></tbody></table><p><strong>这里对所有输入输出流说明：</strong></p><p><strong>流是一种抽象出来的概念，程序员只需要关注将数据输出到流中或者从流中获取数据，而不用关注流怎么跟文件、屏幕、网络、外部设备怎么进行交互。</strong></p><p>我们一般使用的流：</p><table><thead><tr><th>读写文件</th><th>文件流</th></tr></thead><tbody><tr><td><strong>在终端屏幕上打印输出</strong></td><td><strong>标准输出流-stdout</strong></td></tr><tr><td><strong>键盘上输入数据</strong></td><td><strong>标准输入流-stdin</strong></td></tr></tbody></table><p>因此上面的函数，还可以将数据输入输出到屏幕上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>fputc(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码也可以起到printf函数的作用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>筛质数</title>
    <link href="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
    <url>/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>质数的定义</h1><p>质数又称素数。质数是指在大于1的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394?fromModule=lemma_inlink">自然数</a>中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111?fromModule=lemma_inlink">因数</a>的自然数。</p><h1>1-N的质数</h1><p><strong>题目描述：</strong></p><blockquote><p>寻找1-N之间的所有质数。</p><p>将其输出出来。</p></blockquote><h2 id="方法一：朴素法">方法一：朴素法</h2><p><strong>思路：</strong></p><blockquote><p>根据定义，只要循环2 - X-1 的数，看其是否是X的因数，如果都不是，那这个数就是素数。</p><p>可以优化，即找2 - 根号x的数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//循环2- sqrt(x)的数，看是否为其因数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(x); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//输入</span><br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//由于素数是从2开始的</span><br>    <span class="hljs-comment">//循环2-N的数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果是素数，输出即可</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(i))<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然效率是不够的高的。每次都要找2-sqrt(x)的数来判断是否为因数。</p><p><strong>假设找1-10000内的数，则要循环117527次。</strong></p><h2 id="方法二：埃氏筛法">方法二：埃氏筛法</h2><p><strong>思路：</strong></p><blockquote><p>埃氏筛法是通过先找到素数，然后筛选不是这些素数倍数的数。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>2是素数，然后直接排除4、6、8、10…</p><p>3由于不是2的倍数，所以没有被筛选，此时小于3的所有数就都筛选过了，此时3就是素数了。然后通过3，直接排除6、9、12…</p><p>4由于被筛掉了，所以不用看了。</p><p>5不是2、3的倍数，此时小于5的所有数也都被筛选了，5也就是素数。然后再排除其倍数。</p></blockquote><img src="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/image-20230328215621016.png" class title="image-20230328215621016"><p><strong>不过这种做法也是有一点缺陷的，即6被筛选了两次.</strong></p><hr><p><strong>将原理运用：</strong></p><blockquote><p>首先创建一个大小为N+1的数组。里面存放能表示真或者假两种状态的标记。</p><p>初始化数组，假设全为真，表示所有数为素数。</p><p>要特判下标为0、1的，因为其不符合素数定义。</p><p>然后循环2-N的数，如果这个数为素数，则去找其倍数，修改为非素数。即1变0，真变假。</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//创建一个数组来表示0-N的数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Prime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    <br>    <span class="hljs-comment">//不符合定义</span><br>Prime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>Prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">//循环2-N的数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果是素数就筛选其倍速</span><br><span class="hljs-keyword">if</span> (Prime[i])<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= N; j += i)<br>&#123;<br>Prime[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>埃氏筛法可快多了，当要找1-10000内的数，只要31841次。</strong></p><h2 id="方法三：欧拉筛法">方法三：欧拉筛法</h2><p><strong>介绍：</strong></p><blockquote><p>欧拉筛法，也称线性筛，是在埃氏筛的基础上的优化，因为埃氏筛会某一个合数进行多少筛选。本质上是通过合数的最小的质因子筛掉数字。</p><p>大致流程：收集素数，然后遍历每一个数，让其乘上收集到的素数，然后筛选这个数。注意，因为是通过最小质因子筛选，如果当前数的因数有收集到的素数，需要终止。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>2是素数，此时素数列表中只有2，让其 *2，筛选掉4</p><p>3没被筛选，此时将其加入素数列表，列表内容为2、3,让3 * 2, 3 * 3，筛选掉6、9</p><p>4被筛选掉了，不同于埃氏筛法，依旧要进行操作，让其成上2，筛选掉8，<strong>然后直接结束4的操作</strong>！<strong>因为欧拉筛的原理是通过最小质因子筛选。2是4的因子，不符合规则。所以不进行 4 * 3的操作。</strong></p><p>5没被筛选，加入素数列表，列表内容为2、3、5，然其乘上这些素数。</p><p>6被筛选掉了，让其乘上2, 2 * 6 = 12，然后直接结束6的操作！</p><p>…</p><p>这样就能保证对每个数只筛选一次了。</p></blockquote><img src="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/image-20230328222516619.png" class title="image-20230328222516619"><p><strong>这种筛选法，对于一个数只会筛掉一次。</strong></p><p><strong>思路：</strong></p><blockquote><p>首先我们需要一个数组，标记这些数是否为质数。因为我们每个数都要乘以之前的所有素数，因此我们需要一个数组来记录素数。</p><p>如果是素数就加入数组。</p><p>对每个数进行乘上素数的操作，然后筛选数</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//判定是否为素数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;<br>isPrime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//储存素数的数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Prime;<br>    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果为素数就加入数组</span><br><span class="hljs-keyword">if</span> (isPrime[i])<br>Prime.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-comment">//乘以素数进行筛选，需要注意是否会越界</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; Prime.<span class="hljs-built_in">size</span>() &amp;&amp; i * Prime[j] &lt;= N; j++)<br>&#123;<br>isPrime[i * Prime[j]] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (i % Prime[j] == <span class="hljs-number">0</span>) <span class="hljs-comment">//最关键的一步！因为欧拉筛的本质是通过最小质因子来筛的</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : Prime)<br>cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>欧拉筛是一种非常高效的算法，如果是找10000内的质数，只需要循环8770次，比埃氏还要快的多。</strong></p><p><strong>对比：</strong></p><table><thead><tr><th>方法：</th><th>1-10000的数</th></tr></thead><tbody><tr><td><strong>朴素筛法</strong></td><td>117527</td></tr><tr><td><strong>埃氏筛</strong></td><td>31841</td></tr><tr><td><strong>欧拉筛(线性筛)</strong></td><td>8770</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>案例引入：</h1><blockquote><p>有一个猜数字的游戏，即我讲选中1-100以内的某一个数，然后你来猜测，如果你猜的数比我选的数大，我会告诉你大了，反之亦然。</p></blockquote><p><strong>其实这个游戏就运用到了二分法/折半查找的思路。即每次筛选都排除掉一半的错误。</strong></p><p>二分查找是一个非常厉害的算法，它的<strong>时间复杂度在对数阶</strong>。</p><hr><h1>例题一：找个数</h1><h2 id="题目描述："><strong>题目描述：</strong></h2><blockquote><p>运用二分法的思想，寻找一个有序数组中的一个数的下标。这个数必定存在，数组中不存在重复元素项。</p></blockquote><h2 id="输入："><strong>输入</strong>：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span>&#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br></code></pre></td></tr></table></figure><h2 id="输出："><strong>输出：</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="思路："><strong>思路：</strong></h2><blockquote><p>定义一个左边界，定义一个右边界</p><p>然后每次比较区间中间的数和目标值</p><p>修改区间，就能删除一半的元素。</p></blockquote><h2 id="代码："><strong>代码：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = size - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//二分查找的细节</span><br><span class="hljs-keyword">while</span> (left &lt;= right) <span class="hljs-comment">//这里是小于等于呢？还是小于？ 这里先采用小于等于的写法，本质是取左闭右闭区间，[left, right]</span><br>&#123;<br>        <br><span class="hljs-comment">//计算中间的那个元素的下标</span><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//如果要找的数小于中间的那个数</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br><span class="hljs-comment">//怎么修改边界与上面的终止条件有关</span><br>right = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果找到了就直接返回这个元素的下标</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br><br><span class="hljs-comment">//计算数组中元素个数</span><br><span class="hljs-type">int</span> size = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br><span class="hljs-type">int</span> index = BinarySearch(arr, target, size);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了，这个数在数组中的下标为：%d&quot;</span>, index);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="细节："><strong>细节：</strong></h2><blockquote><p>如果自己去写，很有可能写错，因为根据你<strong>所选取的区间不同</strong>，就会有<strong>其他几种写法</strong>。</p><p>例如 : 假设选取[left, right)区间，即左闭右开区间(上面选取了左闭右闭区间)</p></blockquote><h2 id="代码如下："><strong>代码如下：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-type">int</span> right = size;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">while</span> (left &lt; right)<br>&#123;<br><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br>right = mid;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意："><strong>注意：</strong></h2><blockquote><p>我们要<strong>始终满足我们选取二分区间的定义</strong>，即左边界能不能取得到？右边界能不能取得到？</p><p>如果能取得到，那么修改的时候就要注意了。</p><p>很多人由于不注意细节，加上测试的数据不够多，很容易误以为自己写对了二分查找。</p></blockquote><h1>例题二：搜索插入位置</h1><h2 id="题目描述：-2"><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>提示:</p><p>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 为 <strong>无重复元素</strong> 的 升序 排列数组<br>-104 &lt;= target &lt;= 104</p></blockquote><h2 id="示例：">示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">2</span><br>    <br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">1</span><br>    <br>示例 <span class="hljs-number">3</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">7</span><br>输出: <span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><h2 id="思路：-2">思路：</h2><blockquote><p>读题，满足了二分法的条件，即数组有序。还告诉了请务必使用复杂度为O(log n) 的算法。</p><p>下面考虑两种情况：</p><p>1、如果数组中有这个元素，那么直接返回这个元素的下标即可。</p><p>2、如果数组中没有这个元素呢？我们通过一个叫做&quot;循环不变量的东西&quot;(下面会讲),可以得出最后所求的位置一定在left/right + 1上。</p></blockquote><h2 id="代码：-2">代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = target - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right -left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[mid])<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//或者right + 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>二分查找中的循环不变量：</h1><p><strong>所谓的循环不变量，其实就是二分的过程中会发现，left左边的数全部小于目标值，而right的右边全部大于目标值。</strong></p><h2 id="举例：">举例：</h2><p><strong>假设现在要插入一个47，那么肯定得在下标为4的位置插入。</strong></p><table><thead><tr><th>left</th><th></th><th></th><th>mid</th><th></th><th></th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left</th><th>mid</th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left、right、mid</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th>right</th><th>left</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><p><strong>所以返回left 或者 right+1</strong>。<strong>因为left左边都是小于目标值的，那么就应该插入在比目标值小的序列的后面。因为right右边都是大于目标值的，那么就应该插入在比目标值大的序列的前面。</strong>（以上都是对于没有重复项的序列）</p><hr><h1>例题三：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h1><h2 id="题目描述：-3"><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p>提示：</p><p>0 &lt;= nums.length &lt;= 105<br>-109 &lt;= nums[i] &lt;= 109<br>nums 是一个非递减数组<br>-109 &lt;= target &lt;= 109</p></blockquote><h2 id="示例：-2">示例：</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br>示例 3：<br>输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="思路：-3">思路：</h2><blockquote><p>注意：</p><p>此题给的有序序列是<strong>有重复项</strong>的，因此当我们的中间值等于目标值了，我们<strong>先不急着返回</strong>，因此循环中只有两个选择了，等于的情况可以<strong>合并</strong>到别的情况中去。</p><p>现假设合并到中间值大于目标值。</p><p>由于循环不变量的原理，<strong>left左边的数一定是小于目标值，right右边的数一定是大于等于目标值，那么元素的第一个出现的位置一定是在left或者right + 1的位置。</strong></p><p><strong>那么元素最后一个出现的位置呢？只要我们查找比目标值大1的元素的位置然后减1就行了。</strong></p></blockquote><h2 id="特殊情况的考虑：">特殊情况的考虑：</h2><blockquote><p>如果没有出现过目标值呢？依旧会返回一个值，但是这个值是 目标值插入这个位置后依旧是有序的时候的位置。因此判断一下这个位置上的数是否为目标值，就可以知道有没有出现过了。</p><p>如果序列中所有值都小于目标值呢？二分会返回一个我们不可访问的地方。需要判断处理。</p></blockquote><hr><h2 id="代码：-3">代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//用来寻找第一次出现的边界</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m_low_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        ans[<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-built_in">m_low_bound</span>(nums, target);<br>       <span class="hljs-comment">//需要注意的地方！</span><br>        <span class="hljs-keyword">if</span>(start &gt;= nums.<span class="hljs-built_in">size</span>() || target != nums[start])<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//记得减1</span><br>        <span class="hljs-type">int</span> end = <span class="hljs-built_in">m_low_bound</span>(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>        ans[<span class="hljs-number">0</span>] = start;<br>        ans[<span class="hljs-number">1</span>] = end;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1>拓展：lower_bound</h1><img src="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20230328211735342.png" class title="image-20230328211627216"><p>C++的库函数中有一个叫lower_bound()的函数。</p><p><strong>函数的功能：</strong></p><blockquote><p>1、如果数组中存在目标值，则返回第一个是目标值的下标。</p><p>2、如果数组中不存在，则返回这个数应该出现的位置。</p></blockquote><p><strong>使用如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos1 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos2 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos3 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;1 出现的位置：&quot;</span> &lt;&lt; pos1 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2 出现的位置：&quot;</span> &lt;&lt; pos2 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出3</span><br>cout &lt;&lt; <span class="hljs-string">&quot;3 出现的位置：&quot;</span> &lt;&lt; pos3 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出4</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷宫</title>
    <link href="/2023/03/27/%E8%BF%B7%E5%AE%AB/"/>
    <url>/2023/03/27/%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、迷宫问题</h1><h2 id="题目描述："><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc">https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc</a><br>来源：牛客网</p><p>定义一个二维数组 N*M ，如 5 × 5 数组下所示：</p><p>int maze[5][5]= {<br>0, 1, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 1, 0,<br>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。</p><p>数据范围： 2 &lt;= n,m &lt;= 10,  输入的内容只包含 0 &lt;= val &lt;= 1</p></blockquote><h2 id="输入描述："><strong>输入描述：</strong></h2><blockquote><p>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p></blockquote><h2 id="输出描述"><strong>输出描述:</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">左上角到右下角的最短路径，格式如样例所示。<br></code></pre></td></tr></table></figure><p><strong>示例1</strong></p><h2 id="输入">输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="输出">输出</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="求解：">求解：</h2><p><strong>第一步：</strong></p><blockquote><p>首先我们先把简单的输入做好，然后再专心写怎么去找。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步：</strong></p><blockquote><p>因为深度优先搜索(DFS)非常适用于找是否有解的题，正巧题目说了有且仅有一条通路，所以非常契合。</p><p>那DFS怎么实现呢？用栈这种数据结构呢？还是用递归——函数调用创建栈帧？ 为了精简就用递归吧。</p><p><strong>递归三要素：</strong></p><p>1、确定递归函数的参数和返回值</p><p>2、确定终止条件</p><p>3、确定单层递归逻辑</p></blockquote><p><strong>1、确定递归函数的参数和返回值</strong></p><p>首先我们肯定要<strong>传入这个二维矩阵</strong>，其次我们还要<strong>传入迷宫起点坐标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">DFS</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br></code></pre></td></tr></table></figure><blockquote><p>那要不要传迷宫的长宽呢？因为我们用了vector容器，可以通过调用接口函数，直接得出，因此不用</p></blockquote><p>最后我们确定返回值，因为我们<strong>只要求是否有解</strong>，<strong>如果有的话直接返回true, 没有的话返回false不就行啦，所以返回值定位bool</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>2、确定终止条件</strong></p><p>显然<strong>走到出口就停止</strong>呗。即坐标(N - 1, M - 1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>3、确定单层递归逻辑</strong></p><p>首先我们在迷宫中不知道哪里能走，因此只能“摸黑走”，随便走，但<strong>总要规定一个顺序</strong>，我们这里<strong>假设就用上下左右</strong>的顺序去“走迷宫”。</p><p>但是，我们总不能是墙也走吧，或者走出迷宫边界，因此我们还要<strong>判定是否能向那一个方向走。</strong></p><p>写一个函数用来判断能不能走isPass</p><p><strong>首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳。</span><br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>    <br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>至此，我们整个递归的逻辑已经写完了。但是这道题需要让你输出从起点到终点的路径坐标。</p><p>如果我们走到一个死胡同，此时我们记录了这个死胡同的所有坐标，这不是我们想要的，因此我们要删除这些坐标。仔细思考，会发现，我们<strong>所需要删除的是所有后面来的坐标</strong>，这不就是<strong>后进先出</strong>嘛，所以我们就想到了用栈来记录。</p><p>因为<strong>坐标是两个整形的组合</strong>，类似一个结构体，我们可以<strong>用pair来记录坐标</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br></code></pre></td></tr></table></figure><p>至此，我们能记录出所有坐标辣，但是<strong>坐标顺序是反的</strong>。<strong>因此还要借助一个栈来辅助逆置</strong>。最后输出这个辅助栈就ok了</p><h2 id="最终代码：">最终代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, y));<br><br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">//归的过程</span><br><span class="hljs-comment">//因为走不通，返回false，并且要输出错误路的坐标</span><br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>(maze, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; help_st;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>help_st.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">while</span> (!help_st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>help_st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二届程序设计大赛</title>
    <link href="/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"/>
    <url>/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-闰年"><strong>1.闰年</strong></h2><p>问题描述</p><p>给定一个年份，判断这一年是不是闰年。当以下情况之一满足时，这一年是闰年：</p><ol><li>年份是4的倍数而不是100的倍数；</li><li>年份是400的倍数。<br>其他的年份都不是闰年。</li></ol><p><strong>输入格式</strong><br>输入包含一个整数y，表示当前的年份。</p><p><strong>输出格式</strong><br>输出一行，如果给定的年份是闰年，则输出yes，否则输出no。</p><p>说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。</p><p><strong>思路：</strong></p><p>按照题目描述输出即可。<strong><u>四年一润且百年不润 或 四百年一润</u></strong></p><p>因此可以得出这样的表达式：</p><p><strong>(year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)</strong></p><p>之后结合if语句判断即可~</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;year);<br>    <br>    <span class="hljs-comment">//如果表达式为真，则执行输出yes</span><br>    <span class="hljs-keyword">if</span>((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-找素数"><strong>2.找素数</strong></h2><p>输入一个正整数n，计算输出小于n的最大素数</p><p><strong>思路：</strong></p><p>抓住核心：<strong>小于n，最大，素数</strong></p><p><u><strong>1.分析素数：大于1，只能被1和自身整除</strong></u></p><p><u><strong>2.循环找出大于1，小于n的数</strong></u></p><p><u><strong>3.检查循环所枚举出来的数是否为素数</strong></u></p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//检查它是不是素数,如果是则返回1，不是返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br><span class="hljs-comment">//循环2 - num-1 之间的数，看是否能被num整除，能整除则说明不是</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= num - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (num % j == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br><span class="hljs-comment">//先得到小于n的数</span><br><br><span class="hljs-comment">//因为要最大，所以从后往前找</span><br><span class="hljs-comment">//但是因为要得到素数，而最小的素数是2，所以循环到2就行</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">2</span>; i--)<br>&#123;<br><span class="hljs-comment">//判断是否为素数</span><br><span class="hljs-keyword">if</span> (is_Prime(i) == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//如果当前数为素数，则一定是小于n的最大素数了</span><br>            <span class="hljs-comment">//中止循环即可~</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-爬楼梯"><strong>6.爬楼梯</strong></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><p>由于<strong>每次只能爬一个台阶或者两个台阶</strong>，因此<strong>第n阶台阶只能由第n-1阶台阶和n-2阶台阶到达</strong>。</p><p>所以我们<strong>只要知道</strong>了爬到n-1阶台阶有多少中走法和n-2阶台阶有多少种走法，<strong>就能得到</strong>爬到n阶台阶有多少种走法。</p><p>现用函数的形式表示n阶台阶的不同方法数：</p><p>f(n) = f(n - 1) + f(n - 2)。</p><p>f(n - 1) = f(n - 1 - 1) +f(n - 1 - 2)</p><p>f(n - 2) = f(n - 2 - 1) + f(n - 2 - 2)</p><p>…</p><p>我们会发现，每次操作都差不多，因此我们可以用<strong>递归解决问题</strong>(循环当然也可以)。</p><p>但有<strong>两个特例</strong>：</p><p>f(1) = 1</p><p>f(2) = 2</p><p>因为用上面的公式不符合，哪有走0阶台阶的- -</p><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> fun(n - <span class="hljs-number">1</span>) + fun(n - <span class="hljs-number">2</span>);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, fun(n));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-逆序对"><strong>7.逆序对</strong></h2><p><code>逆序对</code></p><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。<br>如 <code>2 4 3 1 </code>中，<code> 2 1</code> ，<code>4 3</code> ，<code>4 1</code>，<code>3 1</code>是逆序，逆序数是 4 。给出一个整数序列，求该序列的逆序数。</p><p><strong>输入</strong></p><p>第 1 行： $N$ ， $N$为序列的长度（ $N≤10000$ ）<br>第 2∼N+1 行：序列中的元素（$ 1≤A[i]≤10000 $）</p><p><strong>输出</strong></p><p>输出逆序数</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>2<br>4<br>3<br>1<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>抓住最重要的，<strong>前面的数大于后面的数</strong>！</p><p>所以只要<strong>两个循环</strong>就可以解决了！</p><p><strong>外循环</strong>：固定当前等待比较的数</p><p><strong>内循环</strong>：去当前等待比较的数后面寻找有没有它还大的数</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <br>    <span class="hljs-comment">//创建数组存放这些数</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">100001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//读取这些数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">//用来计数</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//外循环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//内循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; Nl j++)<br>        &#123;<br>            <span class="hljs-comment">//开始判断,是否前面大于后面</span><br>            <span class="hljs-keyword">if</span>(arr[i] &gt; arr[j])<br>        count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-宫殿距离">9.宫殿距离</h2><p><code>搜索</code></p><p>nxn的格子宫殿，包含一个起始点<code>#</code>，一个终止点<code>$</code>，其它点为<code>.</code></p><p><strong>输入</strong></p><p>第 1 行，一个数n，中间用空格隔开。 ($2≤n≤1000$)</p><p>第 2~n+1行，每行n个字符。</p><p><strong>输出</strong></p><p>输出起点到终点的最短距离，距离只能从一个方格通过上下左右的方式走到与之相邻的方格，每个方格代表的距离为1。</p><p>距离不包含起始位置，包含终止位置。</p><p><strong>输入样例</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5<br><span class="hljs-code">.....</span><br><span class="hljs-code">.#...</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">....$</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>别看这题在后面，其实装的，吓人的</p><p><strong>不就是计算两点之间的距离嘛，只是不能斜着走</strong></p><p>只要在读入迷宫的时候，记下#、$的位置就行了</p><p>C语言的难度对于本体在于如何读取这个迷宫，需要注意缓存区中的换行符。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//存放迷宫</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br><span class="hljs-comment">//用来记录#的位置</span><br><span class="hljs-type">int</span> s_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> s_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//用来记录$的位置</span><br><span class="hljs-type">int</span> e_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> e_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//读入迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;arr[i][j]);<br><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>&#123;<br>s_i = i;<br>s_j = j;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;$&#x27;</span>)<br>&#123;<br>e_i = i;<br>e_j = j;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br>&#125;<br><br><span class="hljs-comment">//abs函数是用来取绝对值的</span><br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">abs</span>(s_i - e_i) + <span class="hljs-built_in">abs</span>(s_j - e_j);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-数列求值"><strong>4.数列求值</strong></h2><p>给定数列1,1,1,3,5,9,17,…，从第4项开始，每项都是前3项的和。求第20190324项的最后4位数字。</p><p><strong>思路：</strong></p><p>斐波那契数列的改版：因此依葫芦画瓢，使用递归来写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> Fib(n - <span class="hljs-number">1</span>) + Fib(n - <span class="hljs-number">2</span>) + Fib(n - <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是因为递归的太深，所以需要求解的时间很长，因此在比赛中肯定是不能过得，因此我们要考虑用空间换时间。</p><hr><p>利用一个数组存储前n项的和，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>arr[n] = arr[n - <span class="hljs-number">1</span>] + arr[n - <span class="hljs-number">2</span>] + arr[n - <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p><strong>但是</strong>！对于这道题依旧行不通，<u><strong>因为他要让你存储第20190324个数，需要巨大的空间</strong></u>，在main函数中创建这个数组，程序会崩溃。但你可以**<u>将这个数组写在main函数外，写成全局变量数组。</u>**</p><p>**但是！**就算你开辟了这个很大的数组，你依旧过不了这题，因为当你傻乎乎的求解时，<em><strong>斐波那契数列的增长很快</strong></em>，不一会就会超出整形的范围，就会得到意想不到的数。不过这题给你了提示，<strong>让你求最后4位数，所以你每次只要关注当前数的后4位</strong>。</p><p>**补充：**要得到一个数的后i位，就要对这个数取模% 10 ^ i</p><h3 id="最终代码如下：">最终代码如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h2 id="3-泡泡世界"><strong>3.泡泡世界</strong></h2><p>小鱼儿吐泡泡，嘟嘟嘟冒出来。小鱼儿会吐出两种泡泡：大泡泡&quot;O&quot;，小泡泡&quot;o&quot;。 两个相邻的小泡泡会融成一个大泡泡,两个相邻的大泡泡会爆掉。</p><p><strong>输入</strong></p><p>一行仅有’O’与’o’组成的字符串。</p><p>保证字符串的长度不超过100。</p><p><strong>输出</strong></p><p>输出一行字符串代表小鱼儿吐出的泡泡经过融合以后所剩余的泡泡。</p><p>合并顺序为自左向右合并。</p><p><strong>输入样例</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ooOOoooO</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">oO</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><blockquote><p>通过观察，我们可以发现，我们只需要关注当前泡泡的最右边的一个泡泡是什么，然后进行操作，符合栈的性质，因此可以用栈来做。</p><p>因为C语言没有自带栈，所以就使用C++来解决.</p></blockquote><p><strong>最终代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str;<br>cin &gt;&gt; str;<br><br>stack&lt;<span class="hljs-type">char</span>&gt; st;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-comment">//如果此时栈里没泡泡</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>())<br>st.<span class="hljs-built_in">push</span>(str[i]);<br><span class="hljs-comment">//有泡泡</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//如果与栈顶的泡泡相等</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">top</span>() == str[i])<br>&#123;<br><span class="hljs-comment">//如果栈顶是和当前都是&#x27;o&#x27;,则还需要判断栈顶下一个元素是否是&#x27;O&#x27;，</span><br><span class="hljs-comment">//如果是需要继续删除，如果不是直接插入</span><br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;o&#x27;</span>)<br>&#123;<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;O&#x27;</span>)<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;O&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-comment">//如果不相等</span><br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">push</span>(str[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//由于栈中的元素顺序与答案是反着的，需要逆置一遍</span><br><span class="hljs-comment">//栈没有迭代器，只能手动逆置</span><br>stack&lt;<span class="hljs-type">char</span>&gt; helpSt;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>helpSt.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-comment">//输出答案</span><br><span class="hljs-keyword">while</span> (!helpSt.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; helpSt.<span class="hljs-built_in">top</span>();<br>helpSt.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-机器人走方格">8.机器人走方格</h2><p><code>dp</code> <code>组合数</code> <code>递推</code></p><p>m×n 的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？</p><p>由于方法数量可能很大，只需要输出 $mod(10^9+7)$的结果。</p><p><strong>输入</strong></p><p>第 1 行，两个数m,n，中间用空格隔开。 ($2≤m,n≤10^6$)</p><p><strong>输出</strong></p><p>输出走法的数量$mod (10^9+7)$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><blockquote><p>非常简单一道动态规划。</p><p>动态规划三部曲：</p><p>1、确定dp数组以及下标的含义。</p><p>dp数组表示的是到第(i,j)位置有多少种走法。</p><p>2、确定递推公式</p><p>因为只能向右和向下走，所以只能从两个方向上走过来，相加即可.</p><p>dp[i][j] = dp[i - 1][j ] + dp[i][j - 1]</p><p>3、dp数组如何初始化</p><p>第一行只能从左走到右，所以只有1种走法</p><p>第一列只能从上走到下，所以只有1中走法</p></blockquote><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><br><span class="hljs-comment">//dp数组表示的是到第(i, j)位置有多少种走法。</span><br><span class="hljs-comment">//直接全部初始化1，反正后面的会被覆盖</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)<br><span class="hljs-comment">//确定递推公式</span><br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br><br>cout &lt;&lt; dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] % (<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写到这里，能拿大部分的分数，但是由于题目故意将数据放大了，这样还是会超时。</p><p>所以看看能不能优化。</p><p>通过观察发现，其实就是组合数。</p><p>从左上到右下，一共要走m - 1 + n - 1步，因为只能走两个方向，所以从m+n-2步中任选m-1步往下走。</p><p>即：</p></blockquote><p><strong>最终代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = n, y = <span class="hljs-number">1</span>; y &lt; m; ++x, ++y) <br>    &#123;<br>        ans = ans * x / y;<br>    &#125;<br>    cout &lt;&lt; ans % (<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯模拟题</title>
    <link href="/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/"/>
    <url>/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第一题</h1><p><strong>问题描述</strong><br>　　请找到一个大于 2022 的最小数，这个数转换成十六进制之后，所有的数位（不含前导 0）都为字母（A 到 F）。<br>　　请将这个数的十进制形式作为答案提交。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><hr><p><strong>方法一：</strong></p><blockquote><p>2022 转十六进制 7E6</p><p>这是一道填空题，最笨的方法，拿着计算器一个一个数出来，看哪一个数最先为AAA。</p></blockquote><p><strong>方法二：</strong></p><blockquote><p>通过编程来找。</p><p><strong>思路</strong>：循环2022以后的数，看哪一个最先 转为十六进制后就全为字母</p><p>如何一个十进制数转为十六进制呢？</p><p>使用短除法~</p><p>如：2022 % 16 = 6， 2022 / 16 =  126</p><p>​126 % 16 = E(14),  126 / 16 = 7</p><p>​7 % 16 = 7,  7 / 16 = 0</p><p>最后将取模的数从下当上写出来， 所以 2022转为十六进制就为7E6了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Full</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-comment">//如果满足每一位都是字母那就返回1，否则返回0</span><br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//检查每一位是否为字母，如果为数字直接结束</span><br><span class="hljs-type">int</span> tmp = n % <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; <span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>n /= <span class="hljs-number">16</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2023</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (is_Full(n))<br>&#123;<br><span class="hljs-comment">//一旦找到某一个满足全是字母的数，直接结束</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>n++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第二题</h1><p><strong>问题描述</strong><br>　　在 Excel 中，列的名称使用英文字母的组合。前 26 列用一个字母，依次为 A 到 Z，接下来 26*26 列使用两个字母的组合，依次为 AA 到 ZZ。<br>　　请问第 2022 列的名称是什么？<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个由大写字母组成的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。</p><blockquote><p>介不就一道二十六进制的题。</p><p>满Z就进位A。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2022</span>;<br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//%c打印字符，即后面可以跟一个数字，然后会输出相应ASCII值的字符</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, n % <span class="hljs-number">26</span> + (<span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">1</span>));<br>n /= <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为TYB，需要将结果反过来即BYT，因为每次都是先得到个位再十位…</p><h1>第三题</h1><p><strong>问题描述</strong><br>　　对于一个日期，我们可以计算出年份的各个数位上的数字之和，也可以分别计算月和日的各位数字之和。请问从 1900 年 1 月 1 日至 9999 年 12 月 31 日，总共有多少天，年份的数位数字之和等于月的数位数字之和加日的数位数字之和。<br>　　例如，2022年11月13日满足要求，因为 2+0+2+2=(1+1)+(1+3) 。<br>　　请提交满足条件的日期的总数量。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>这题就老老实实的编程算了~不然得数到结束</p><p>技巧：我们可以创建一个月份数组，存入每个对应的天数</p><p>思路：枚举每个日期，看是否满足咯，记得要判断是否为闰年</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_LeapYear</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//得到每位之和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (year)<br>&#123;<br>ans += year % <span class="hljs-number">10</span>;<br>year /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> month[<span class="hljs-number">13</span>] = &#123; <span class="hljs-number">0</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<br><span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br><span class="hljs-comment">//用来计数，得到结果</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1900</span>; i &lt;= <span class="hljs-number">9999</span>; i++)<br>&#123;<br><span class="hljs-comment">//先判断这年是不是闰年</span><br>month[<span class="hljs-number">2</span>] = is_LeapYear(i) ? <span class="hljs-number">29</span> : <span class="hljs-number">28</span>;<br><br><span class="hljs-comment">//得到这年上的数字之和</span><br><span class="hljs-type">int</span> year = getSum(i);<br><br><span class="hljs-comment">//得到月和日的数字之和</span><br><span class="hljs-type">int</span> Mon_Day = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">12</span>; j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= month[j]; k++)<br>&#123;<br><span class="hljs-comment">//计算月份和日每位数字之和~</span><br><span class="hljs-type">int</span> tmp = getSum(j) + getSum(k);<br><span class="hljs-keyword">if</span> (tmp == year)<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第四题</h1><p>问题描述<br>小蓝有 30 个数，分别为：99, 22, 51, 63, 72, 61, 20, 88, 40, 21, 63, 30, 11, 18, 99, 12, 93, 16, 7, 53, 64, 9, 28, 84, 34, 96, 52, 82, 51, 77 。<br>小蓝可以在这些数中取出两个序号不同的数，共有 30*29/2=435 种取法。<br>请问这 435 种取法中，有多少种取法取出的两个数的乘积大于等于 2022 。</p><p>答案提交<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>水题哦。直接上代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">99</span>, <span class="hljs-number">22</span>, <span class="hljs-number">51</span>, <span class="hljs-number">63</span>, <span class="hljs-number">72</span>, <span class="hljs-number">61</span>, <span class="hljs-number">20</span>,<br>     <span class="hljs-number">88</span>, <span class="hljs-number">40</span>, <span class="hljs-number">21</span>, <span class="hljs-number">63</span>, <span class="hljs-number">30</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">99</span>, <span class="hljs-number">12</span>,<br>      <span class="hljs-number">93</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">9</span>, <span class="hljs-number">28</span>, <span class="hljs-number">84</span>, <span class="hljs-number">34</span>, <br>      <span class="hljs-number">96</span>, <span class="hljs-number">52</span>, <span class="hljs-number">82</span>, <span class="hljs-number">51</span>, <span class="hljs-number">77</span>&#125;;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">30</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]*a[j]&gt;=<span class="hljs-number">2022</span>)<br>            &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><hr><h1>第六题</h1><p><strong>问题描述</strong><br>　　给定一天是一周中的哪天，请问 n 天后是一周中的哪天？<br><strong>输入格式</strong><br>　　输入第一行包含一个整数 w，表示给定的天是一周中的哪天，w 为 1 到 6 分别表示周一到周六，w 为 7 表示周日。<br>　　第二行包含一个整数 n。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示 n 天后是一周中的哪天，1 到 6 分别表示周一到周六，7 表示周日。<br><strong>样例输入</strong><br>6<br>10<br><strong>样例输出</strong><br>2<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000。</p><blockquote><p>思路：给定一个整数w表明是周几，那不就是第几天嘛。让你算n天之后，只需要(w + n) % 7</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;w, &amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (w + n) % <span class="hljs-number">7</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1>第七题</h1><p><strong>问题描述</strong><br>　　小蓝负责一块区域的信号塔安装，整块区域是一个长方形区域，建立坐标轴后，西南角坐标为 (0, 0)， 东南角坐标为 (W, 0)， 西北角坐标为 (0, H)， 东北角坐标为 (W, H)。其中 W, H 都是整数。<br>　　他在 n 个位置设置了信号塔，每个信号塔可以覆盖以自己为圆心，半径为 R 的圆形（包括边缘）。<br>　　为了对信号覆盖的情况进行检查，小蓝打算在区域内的所有横纵坐标为整数的点进行测试，检查信号状态。其中横坐标范围为 0 到 W，纵坐标范围为 0 到 H，总共测试 (W+1) * (H+1) 个点。<br>　　给定信号塔的位置，请问这 (W+1)*(H+1) 个点中有多少个点被信号覆盖。<br><strong>输入格式</strong><br>　　输入第一行包含四个整数 W, H, n, R，相邻整数之间使用一个空格分隔。<br>　　接下来 n 行，每行包含两个整数 x, y，表示一个信号塔的坐标。信号塔可能重合，表示两个信号发射器装在了同一个位置。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示答案。<br><strong>样例输入</strong><br>10 10 2 5<br>0 0<br>7 0<br><strong>样例输出</strong><br>57<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= W, H &lt;= 100，1 &lt;= n &lt;= 100, 1 &lt;= R &lt;= 100, 0 &lt;= x &lt;= W, 0 &lt;= y &lt;= H。</p><blockquote><p>题目挺长的，但是细读会发现也就那样。</p><p>思路：</p><p>创建一个二维数组全部初始化为0，然后对每一个信号塔进行预处理，将这个点到信号塔的距离算出来(x - a)^2 + (y - b)^2.如果在信号塔的范围内</p><p>就将其对应二维数组的值改为1。最后再统计1的个数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> W, H, n, R;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;W, &amp;H, &amp;n, &amp;R);<br><span class="hljs-comment">//创建一个二维数组</span><br><span class="hljs-comment">//因为不知道支不支持边长数组，就将数组开到最大</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//对于每个信号塔进行预处理</span><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br><br><span class="hljs-comment">//这里是&lt;=哦~</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= H; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= W; j++)<br>&#123;<br><span class="hljs-comment">//两点距离公式</span><br><span class="hljs-comment">//一个点的坐标:(j,i)</span><br><span class="hljs-comment">//信号塔坐标:  (y,x)</span><br><span class="hljs-keyword">if</span> ((x - i) * (x - i) + (y - j) * (y - j) &lt;= (R * R))<br>&#123;<br><span class="hljs-comment">//懒得再遍历一遍数组了，直接记录下有多少个1不就完事了~</span><br><span class="hljs-comment">//注意！如果被两个信号塔覆盖，应该只能算1次</span><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-number">0</span>)<br>count++;<br><br>arr[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1>第八题</h1><p><strong>问题描述</strong><br>　　小蓝有一个 n * m 大小的矩形水域，小蓝将这个水域划分为 n 行 m 列，行数从 1 到 n 标号，列数从 1 到 m 标号。每行和每列的宽度都是单位 1 。<br>　　现在，这个水域长满了水草，小蓝要清理水草。<br>　　每次，小蓝可以清理一块矩形的区域，从第 r1 行（含）到第 r2 行（含）的第 c1 列（含）到 c2 列（含）。<br>　　经过一段时间清理后，请问还有多少地方没有被清理过。<br><strong>输入格式</strong><br>　　输入第一行包含两个整数 n, m，用一个空格分隔。<br>　　第二行包含一个整数 t ，表示清理的次数。<br>　　接下来 t 行，每行四个整数 r1, c1, r2, c2，相邻整数之间用一个空格分隔，表示一次清理。请注意输入的顺序。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示没有被清理过的面积。<br><strong>样例输入</strong><br>2 3<br>2<br>1 1 1 3<br>1 2 2 2<br><strong>样例输出</strong><br>2<br><strong>样例输入</strong><br>30 20<br>2<br>5 5 10 15<br>6 7 15 9<br><strong>样例输出</strong><br>519<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= r1 &lt;= r2 &lt;= n &lt;= 100, 1 &lt;= c1 &lt;= c2 &lt;= m &lt;= 100, 0 &lt;= t &lt;= 100。</p><blockquote><p>感觉水题一样的，跟上题差不多思路，依旧是创建一个二维数组，去找里面有多少个0——代表没被清理过的地方。</p><p>搞懂上题这题打个哈哈就过~</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n, m, t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;t);<br>    <span class="hljs-type">int</span> r1, c1, r2, c2;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);<br>        <span class="hljs-keyword">for</span> (i = r1; i &lt;= r2; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (j = c1; j &lt;= c2; j++)<br>            &#123;<br>                a[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
