<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaEE初阶1</title>
    <link href="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/"/>
    <url>/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、计算机的组成</h1><p><strong>1、CPU</strong>：中央处理器，一台电脑最核心的部分，通过指令来完成各种算术运算和逻辑判断，是人类科技巅峰之作</p><p><strong>补充</strong>：</p><p><strong>cpu虽然技术门槛非常高</strong>，但是很<strong>便宜</strong>，这是因为<strong>cpu每年都在更新换代</strong>，并且<strong>每一代cpu的提升幅度都比较大</strong>，因此并不保值。intel的创始人之一提出了一个<strong>摩尔定律</strong>：集成电路上可容纳的晶体管数量每隔大约18至24个月就会翻倍，从而导致芯片性提升接近一倍，同时成本也下降一半。</p><p>在cpu中还有<strong>寄存器</strong>，用于<strong>暂时存储指令，操作数和中间结果</strong>，寄存器的<strong>存储空间更小</strong>，<strong>访问速度更快</strong>(相比于内存)，大概相差3-4个数量级，因此为了协调工作，cpu又引入了“缓存”来协调 寄存器 和 内存 之间的速度。</p><p><strong>2、存储器</strong>：分为内存和外存。</p><p><strong>内存：速度快，空间小，成本高，不能持久保存</strong></p><p><strong>外存：速度慢，空间大，成本小，可持久保存</strong></p><p>这里说的快和慢是内存和外存相对而言的~</p><p><strong>3、输入设备</strong>：键盘、鼠标、摄像头…</p><p><strong>4、输出设备</strong>：显示器、打印机、扬声器…</p><h1>二、操作系统</h1><h2 id="0x00-什么是操作系统">0x00 什么是操作系统</h2><p>市面上存在着许多的操作系统，如：<strong>Windows11，linux，mac os， android，ios</strong>…</p><p>这些操作系统，需要<strong>对下管理硬件设备，对上提供稳定的运行环境</strong></p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815091501568.png" class title="image-20230815091501568"><p>由于操作系统毕竟只是一个软件，不可能识别所有硬件设备，不过硬件设备就这么几个大类，因此操作系统只要知道每个大类中有什么功能，然后硬件产商在开发硬件的同时开发一个驱动程序(软件)，让操作系统通过这个驱动程序完成对硬件设备的控制。可以这么理解：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815091420684.png" class title="image-20230815091420684"><h2 id="0x01-进程-任务">0x01 进程/任务</h2><p>一个运行起来的程序就叫做进程。每个进程要想运行，就需要消耗一定的系统资源。因此<strong>进程是系统资源分配的基本单位。</strong></p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815092300478.png" class title="image-20230815092300478"><h2 id="0x02-管理进程">0x02 管理进程</h2><p>一个操作系统上可能跑了很多进程，那如何对这些进程管理呢？两方面：描述、组织</p><p>1、<strong>使用类来描述一个进程</strong>，把管理的每个对象都用属性表示出来</p><p>2、<strong>使用数据结构组织这些进程对象</strong>，类似于双向链表，方便创建、销毁</p><p>在系统中专门有一个结构体(操作系统内核是c/c++写的，java中结构体相当于类)来描述进程的属性，这个结构体叫做**“进程控制块”PCB**。</p><hr><p>PCB时一个非常庞大的结构体，包含很多的属性，在这就讨论一些比较重要的属性。</p><p><strong>1、pid：</strong></p><p><strong>进程的身份标识</strong>，每一个进程都会有一个pid，同一时刻，不同进程之间的pid是不同的。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815093901192.png" class title="image-20230815093901192"><p><strong>2、内存指针</strong></p><p><strong>描述了进程持有的“内存资源“</strong>，每个进程运行的时候，都会分配一定的内存空间。这个进程的内存空间，具体在哪，分配的内存空间有哪些部分，每个部分是干啥的，有这么一组指针来进行区分。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815093901192.png" class title="image-20230815095135867"><p><strong>3、文件描述符</strong></p><p><strong>描述了进程持有的“硬盘资源”</strong>，类似于顺序表这样的数据结构，有很多元素。如果一个进程涉及到了文件操作，保存数据啥的，就需要与硬盘挂钩，于是需要通过文件读写的方式来操作，将硬盘上的数据修改/读取。</p><hr><p>我们都知道一个程序的运行离不开cpu的运转，也就是说<strong>每个进程都需要消耗cpu资源</strong>，那<strong>怎么体现cpu资源</strong>呢？答案：<strong>进程的调度</strong>。</p><p>早期的操作系统，是一个“<strong>单任务操作系统</strong>”，<strong>同一时刻只有一个进程能运行</strong>，运行下一个进程就会退出当前进程，此时就不需要考虑调度问题，但随着发展，后面都支持<strong>多任务</strong>了，那如何运行这多个进程呢？——<strong>分时复用</strong>！</p><p>假设<strong>cpu是单核</strong>，如果使用分时复用的方法，就是<strong>将1s分成许多份，每个进程获取其中的一份或者多份，cpu在这一份的时间内执行这个进程</strong>。这样的执行方式叫作<strong>并发执行</strong>，只要我们时间<strong>轮转的够快</strong>(分成的份数够多)，此时看起来就像是同时执行一样(<strong>宏观上是同时执行的，微观上是分时复用</strong>)。</p><p>现代的<strong>cpu都是多个核心</strong>了，此时我们可以在同一时刻使用两个核心执行进程，这种执行方式叫做并行执行，也就是说<strong>在微观上也是同时执行的</strong>。</p><p>不过在应用层，我们感知不到是并发还是并行，其内部都是通过系统调度来选择的。平时普通的程序员也不会去具体区分是并发还是并行，因此<strong>常常使用“并发”来代指并行和并发</strong>。</p><p>那<strong>操作系统如何进行进程调度呢</strong>？通过如下属性~</p><hr><p><strong>4、进程的状态</strong></p><p>表示进程的状态，如就绪、运行、阻塞等，以指导操作系统的调度决策。</p><p><strong>就绪状态</strong>：进程准备好运行，只等待操作系统分配处理器时间。</p><p><strong>阻塞状态</strong>：进程某种执行条件不具备，导致这个进程暂时无法参与cpu的调度执行。例如：进程等待用户输入…</p><p><strong>运行状态</strong>：进程当前正在cpu上执行其指令，正在占用cpu资源，以完成其所需的计算和任务。</p><p><strong>5、进程的优先级</strong></p><p>操作系统在调度多个进程的时候并非一视同仁，有的进程会给更高的优先级，优先执行。例如：接受QQ消息，晚个几秒钟也没啥关系。</p><p><strong>6、进程的上下文</strong></p><p>进程从cpu离开之前，需要保存当前数据，把当前cpu中寄存器的状态都记录到内存中，等到下次进程回到cpu上执行的时候，再把保存的值恢复回去，进程就沿着上次执行到的位置继续执行，类似于游戏打了一半，然后去吃饭了，等下次继续的时候，读取数据恢复到上次的关卡。</p><p><strong>补充：</strong></p><p>CPU中有些寄存器没有特殊含义，只是用来保存运算的中间结果，还有些寄存器是有特定含义的。</p><p><strong>1、程序计数器</strong></p><p>存储的是一个内存地址，用来保存当前执行到哪个指令(可以理解为指针)。一个进程在运行的时候，操作系统会将里面的指令和数据加载到内存中并形成地址，然后CPU就会从内存中通过查询地址的方式找到指令并执行指令。</p><p><strong>2、维护栈相关的寄存器</strong></p><p>程序在调用函数的时候会创建栈帧，而栈是一块空间，通过维护头和尾就可以知道个空间的位置，大小。如：ebp寄存器是存储的地址是栈底，esp寄存器存储的是栈顶，通过修改esp的值就可以实现“入栈”，”出栈“操作。</p><p><strong>3、其他的通用寄存器</strong></p><p>一般是用来保存计算的中间结果。如：当前有一个表达式, 10+20+30+40,假设现在算完了前面两项的和，但还没来得及算后面的，此时进程调度走了，就需要将保存计算的前面两项的和的寄存器的值备份到上下文中。</p><p><strong>7、进程的记账信息</strong></p><p>通过优先级的机制，对不同的进程分配了不同权重的资源，不过有可能会出现极端的情况，将所有资源都分配给了某个进程，其他进程没有分配到，通过记账信息记录当前进程在cpu的执行情况(执行时间)，然后<strong>操作系统可以参考记账信息来进行下一次的调度进程</strong>。</p><h2 id="0x03-虚拟内存空间">0x03 虚拟内存空间</h2><p><strong>早期的操作系统，程序运行时分配的内存就是“物理内存”</strong>，这样就会导致，我的A程序通过某种方式访问到B程序的内存空间，然后进行修改，这就有可能会使B程序崩溃，为了防止这种情况，就<strong>引入了“虚拟内存空间”</strong>。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815095135867.png" class title="image-20230816211910788"><p>操作系统通过使用“虚拟内存地址”，不直接分配物理内存，而是分配虚拟的内存空间，类似哈希的思想，通过某个key来寻找value。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230816211910788.png" class title="image-20230816212757122"><p>此时进程A想要操作某个内存中的数据，先通过虚拟内存地址告诉操作系统，然后操作系统将虚拟内存翻译成物理内存地址，进行修改，在翻译的过程中，操作系统就可以进行校验操作，如果是非法访问就可以处理，不会危害到别的进程了，保持了进程的独立性，为进程提供稳定的运行环境。</p><h1>三、线程</h1><p>当今时代大部分电脑的cpu都已经是多核心的了，因此我们可以充分利用这个特点，进行并发执行多个任务，从而提高程序的执行效率。</p><p>进行并发编程可以从两个方面：<strong>多进程、多线程</strong>。</p><h2 id="0x00-多进程">0x00 多进程</h2><p>通过多进程实现并发编程效果非常理想，但是多进程模型会有明显的缺点：<strong>太重量、效率不高</strong>。(相比多线程)</p><p>这是因为<strong>进程是资源分配的基本单位</strong>，每个进程都有自己的内存空间和系统资源，这就导致<strong>创建一个进程需要去申请资源，销毁一个进程需要去释放资源</strong>。如果频繁的进行创建/销毁进程，这个时候，开销就不能忽视了~</p><h2 id="0x01-多线程">0x01 多线程</h2><p>在Java中，更加鼓励使用多线程编程，这样就能很好的解决上述问题。这是因为<strong>线程是“轻量级进程”</strong>，<strong>创建/销毁比进程更快</strong>。</p><p><strong>线程不能独立存在，而是依附于进程。一个进程可以包含一个线程，也可以包含多个线程</strong>。一个进程在最开始的时候，至少要有一个进程，也可以根据需要创建多个线程，从而实现并发编程。</p><p>一个进程中，可以有多个线程，<strong>每个线程都是可以独立的进行调度的</strong>，而调度是根据pcb属性来进行的，因此<strong>一个拥有多个线程的进程需要使用多个pcb</strong>(pid、内存指针、文件描述符表共用一份)来进行维护。</p><p>同<strong>一个进程的多个线程</strong>之间，由于<strong>共用一份内存空间和文件资源</strong>，创建线程的时候，<strong>不需要再重新申请资源了</strong>，直接复用之前操作系统分配给进程的资源，省去了<strong>资源分配的开销，提高了效率</strong>。</p><p><strong>总得来说就是：</strong></p><p>1、一个进程拥有一个或多个线程</p><p>2、每个线程使用一个pcb来表示，每个线程都可以独立的去CPU上调度执行，所以pcb中的状态、上下文、优先级、记账信息是独立的，线程是调度执行的基本单位。</p><p>3、pcb中的pid、内存指针、文件描述符表共用一份，所以创建线程的时候不需要再申请资源，创建的效率更高。</p><h2 id="0x-02-多线程的问题">0x 02 多线程的问题</h2><p>1、我们知道可以通过创建额外的线程来帮我们提升效率，假设我们的线程创建的非常多，此时还能进一步提高效率吗？肯定是不能的，反而会因为要调度的线程太多了，导致调度的开销太大，进而降低了效率。</p><p>2、如果两个线程同时去争抢某个资源，这就会引起冲突，导致线程不安全。</p><p>3、如果某个线程生气了，出现了异常，此时如果没有妥善的处理，就容易使整个进程崩溃。例如：在程序中越界了，你却没有catch。</p><h2 id="0x-03-进程与线程的区别">0x 03 进程与线程的区别</h2><p>1、进程包含线程，一个进程可以有一个或多个线程。</p><p>2、同一个进程的线程之间共用一份资源，不用再申请资源。</p><p>3、线程是资源分配的基本单位，进程是调度执行的基本单位。</p><p>4、进程和线程都是用来实现并发编程的，但是线程比进程更轻量、高效。</p><p>5、进程拥有独立性，一个进程挂了不会影响到别的进程。但一个进程内的线程挂了可能会影响到其他线程。</p><h1>四、多线程编程</h1><p>如何使用Java进行多线程编程？</p><p>线程是操作系统的概念，操作系统提供了一些API，可以用来操作线程，Java针对操作系统的API进行了封装，因此Java程序员只需要掌握一套API就可以到处运行了~~</p><h2 id="0x00-如何创建线程">0x00 如何创建线程</h2><p>在Java中通过创建Thread类对象，来进行多线程操作。如果我们要想自定义一个线程的话，我们需要继承Thread。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个<strong>线程跑起来，是从它的入口方法，也就是从run方法开始执行的</strong>，类似于一个<strong>Java程序的入口是main方法</strong>一样，只不过运行一个Java进程，会创建一个主线程，而<strong>主线程的入口是main方法</strong>。</p><p>我们观察源码会发现，Thread类实现了Runnable接口，而这个接口内部就定义了一个抽象的run方法。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822083331688.png" class title="image-20230822083331688"><p>所以，我们只需要重写一下run方法，在里面写线程的代码逻辑。不过重写了run方法只是定义了方法，要想真正<strong>启动一个线程，我们还需要调用start方法</strong>(在Thread类中定义了)。</p><p>线程，启动！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//当前线程执行的入口</span><br>        System.out.println(<span class="hljs-string">&quot;线程 启动！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结：</strong></p><p>start、run方法都是Thread的成员方法。run方法只是描述了线程的入口，该执行什么代码。start方法则是真正的调用了系统API，在系统中创建了线程，再让线程调用run方法。</p><h2 id="0x01-线程如何执行">0x01 线程如何执行</h2><p>现有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//当前线程执行的入口</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;myThread线程在执行&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;main线程在执行&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822085201024.png" class title="image-20230822085201024"><p>通过观察，我们发现，<strong>在主线程开启一个线程的时候，主线程并不过阻塞</strong>，依旧会往下执行，而且线程执行的顺序也不是完全按照线程调用顺序，而是根据调度来决定。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822085820615.png" class title="image-20230822085820615"><hr><p>如果<strong>将调用start方法，改成调用run方法</strong>呢？</p><p>由于没有使用start方法，<strong>程序不会创建一个线程</strong>，而是直接去调用run方法，直到<strong>调用完run方法后，才会回来继续往下执行main方法</strong>。</p><hr><p>多线程运行的时候，可以使用<strong>jconsole</strong>来观察到进程里的多线程情况。jconsole是jdk中的一个工具。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822090753214.png" class title="image-20230822090753214"><h2 id="0x02-线程的创建方式">0x02 线程的创建方式</h2><p>创建一个线程其实很简单，<strong>只需要你重写run方法(写自己的代码逻辑)，和调用start方法</strong>。而重写run方法可以通过继承Thread、实现Runnable接口、通过匿名内部类、使用lambda表达式…</p><p><strong>1、继承Thread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、实现Runnable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-comment">//由于Runnable接口没有start方法，所以得通过Thread的构造方法来创建。</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myThread);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、通过匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//程序代码</span><br>            &#125;<br>        &#125;;<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、基于lambda表达式</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Thread thread =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//程序代码</span><br>        &#125;);<br>        thread.<span class="hljs-built_in">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>五、Thread类及常用的方法</h1><h2 id="0x00-Thread类的构造方法">0x00 Thread类的构造方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Thread()</td><td>创建线程对象</td></tr><tr><td>Thread(Runnable target)</td><td>使用Runnable对象创建线程对象</td></tr><tr><td>Thread(String name)</td><td>创建线程对象，并命名</td></tr><tr><td>Thread(Runnable target, String name)</td><td>使用Runnable对象创建线程对象，并命名</td></tr><tr><td>Thread(ThreadGroup grop, Runnable target)</td><td>将线程分组管理</td></tr></tbody></table><h2 id="0x01-Thread的几个常用的属性">0x01 Thread的几个常用的属性</h2><table><thead><tr><th>属性</th><th>获取方法</th><th>说明</th></tr></thead><tbody><tr><td>ID</td><td>getId()</td><td>获取线程的身份标识符ID</td></tr><tr><td>名称</td><td>getName()</td><td>获取线程的名称</td></tr><tr><td>状态</td><td>getState()</td><td>获取线程的状态</td></tr><tr><td>优先级</td><td>getPriority()</td><td>获取线程的优先级</td></tr><tr><td>是否是后台线程</td><td>isDaemoin()</td><td>判断是否是后台线程</td></tr><tr><td>是否存活</td><td>isAlive()</td><td>判断是否存活</td></tr><tr><td>是否被中断</td><td>isInterrupte()</td><td>判断是否中断</td></tr></tbody></table><p><strong>补充</strong>：</p><p>1、<strong>ID是线程的身份标识</strong>，标识一个进程中的唯一线程，这个ID是Java给你分配的，并不是系统api提供的线程ID。</p><p>2、优先级，在理论上可以使优先级高的线程更容易被调度到，但站在应用程序的角度，很难察觉到。</p><p>3、后台线程，也叫做守护线程，与之对应的是前台线程。</p><p><strong>前台线程：当所有的前台线程执行结束后，进程才会结束执行</strong></p><p><strong>后台线程：后台线程的结束与否不会影响进程的结束。</strong></p><p>4、判<strong>断是否存活，是判断内核线程中是否还有，而不是判断Thread对象</strong>。Thread对象的生命周期往往比线程长，线程没了，Thread对象还在。</p><h2 id="0x02-中断一个线程">0x02 中断一个线程</h2><p>在C++中可以直接终止一个正在运行的线程，但是在Java中是不可以的，因此设计思路就是<strong>让这个线程中的run方法尽快的结束</strong>。如下：</p><p><strong>1、通过共享的标记，让线程退出</strong></p><p><strong>2、通过interrupt来中断线程</strong></p><p><strong>示例1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">Quit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(Quit)&#123;<br>                <span class="hljs-keyword">return</span><br>            &#125;<br>        &#125;);<br>        <br>        thread.start();<br>        <br>        <span class="hljs-comment">//手动设置退出</span><br>        Quit = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述方式是通过<strong>修改一个共享的变量，进行控制线程的运行的</strong>。但有如下缺点：</p><p>1、需要手动创建变量，比较麻烦。</p><p>2、当修改了变量，理应让线程立马去执行完剩下的代码，但如果线程此时sleep了，会到导致这个线程还要再睡一会，不符合我们的设计初衷(让线程尽快的执行结束)。</p><hr><p><strong>示例2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-comment">//currentThread() 返回的是 哪个线程调用，就返回哪个线程对象</span><br>           <span class="hljs-comment">//isInterrupted() 判断是否中断</span><br>           <span class="hljs-keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;<br>               System.out.println(<span class="hljs-string">&quot;线程正在工作&quot;</span>);<br>               <span class="hljs-keyword">try</span> &#123;<br>                   Thread.sleep(<span class="hljs-number">600</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>               &#125;<br>           &#125;<br>        &#125;);<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">//让线程中断</span><br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230823113549767.png" class title="image-20230823113549767"><p>抛出了一个异常，这是因为这个线程在sleep，然后interrupt()唤醒了线程，这就触发了sleep的异常。</p><p>但我明明是<strong>让线程中断的，但是线程依然在工作</strong>，这是为什么呢？</p><p><strong>解释：</strong></p><p>sleep的线程被interrupt唤醒后，此时sleep方法会抛出异常，同时**将&quot;终止标识符&quot;清除(**在Thread对象内部有一个终止标识符，interrupt方法本质是使用过设置终止标识符来退出程序的)。</p><p>为什么要这样设定？是因为<strong>Java期望当线程收到终止信号的时候，能够自己决定接下来如何处理</strong>。也就是说如果在catch中捕获到异常，程序员可以自己决定接下来要干嘛，如果没有捕获到，run方法尽快结束就行。</p><h2 id="0x03-线程等待">0x03 线程等待</h2><p>用来控制线程结束的顺序，让一个线程等待另一个线程执行结束，再继续执行。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>join()</td><td>等待线程结束</td></tr><tr><td>join(long millis)</td><td>等待线程结束，最多等 millis 毫秒</td></tr><tr><td>join(long millis, int nanos)</td><td>等待线程结束，精度可以达到纳秒</td></tr></tbody></table><p><strong>说明：</strong></p><p>thread.join() 工作过程：<strong>如果thread线程正在运行，那调用join的线程就会阻塞，一直阻塞到thread线程执行结束，如果thread线程已经执行结束了，调用join的线程就不会阻塞，直接继续执行</strong>。</p><h2 id="0x04-线程状态">0x04 线程状态</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>Thread对象创建了，但还没调用start方法</td></tr><tr><td>TERMINATED</td><td>Thread对象还在，但内核中的线程已经没了</td></tr><tr><td>RUNNABLE</td><td>可运行的，线程已经在cpu上执行了/线程正在排队等待上cpu执行</td></tr><tr><td>TIME_WAITING</td><td>阻塞，由于sleep这种固定时间的方式产生阻塞</td></tr><tr><td>WAITING</td><td>阻塞， 由于wait这种不固定时间的方式成的阻塞</td></tr><tr><td>BLOCKED</td><td>阻塞，由于锁竞争导致的阻塞</td></tr></tbody></table><h2 id="0x05-线程安全">0x05 线程安全</h2><p>线程安全是多线程中最重要最复杂的部分。可能用一份代码在单线程的环境下执行是正确的，但在多线程环境中就不一定了。</p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>                count++;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>                count++;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br><br>        t1.join();<br>        t2.join();<br><br>        System.out.println(<span class="hljs-string">&quot;count: &quot;</span> + count);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在逻辑上，count应该自增了2w次，最终count的值应该为2w，然而结果却不是2w，而且<strong>几乎每次运行的结果都不相同</strong>。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230823154800674.png" class title="image-20230823154800674"><p><strong>解释：</strong></p><p>这是因为count++ 操作，<strong>本质上是分成三步的</strong>：</p><p>1、load 把数据从内存中读到cpu寄存器中</p><p>2、add 把寄存器中的数据进行+1</p><p>3、save 把寄存器中的数据，保存到内存中。</p><p><strong>如果是多个线程执行的话，由于线程之间的调度顺序是随机的，并不确定，就会导致出现问题</strong>。</p><p>如：当第一个线程正在进行第一个操作的load的时候，第二个线程已经完成了第二、三、四的操作，此时第一个线程再进行第一个操作的add的时候，从寄存器中读取到的数据是0，而非3，因此就会出现错误。</p><p><strong>总结：</strong></p><p>产生线程安全问题的原因：</p><p>1、操作系统中，线程的调度顺序是随机的(抢占式执行)</p><p>2、不同线程，最对同一个变量进行修改</p><p>3、修改操作，不是原子的，即某个操作必须一起全部完成。</p><p>4、内存可见性问题</p><p>5、指令重排序问题</p><hr><p>那要如何保证代码一定准确呢？答案是<strong>加锁</strong>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象名)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>() 中需要表示一个用来加锁的对象，这个对象是啥不重要，重要的是通过这个对象来区分两个线程是否在竞争同一个锁。如果两个线程是在针对同一个对象加锁，就会有锁竞争，如果不是针对同一对象加锁，就不会有锁竞争，而此时的并发程度最高，但是不能保证正确。</p><p>{}内的代码就是要执行的内容了。</p><p>当一个线程拿到了这把对象锁之后，另外一个线程就得阻塞，等待上一个线程释放锁，之后再进行竞争这把锁。</p>]]></content>
    
    
    
    <tags>
      
      <tag>javaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/07/31/MySQL/"/>
    <url>/2023/07/31/MySQL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>本文说明</strong>：2023的暑假中mysql的学习~ 学习的内容的侧重点不同于学校的理论，而是工作、面试中可能经常出现的内容~ 本文是针对小白和稍微有一些了解的用户所讲解的~</p><h1 id="一、数据库介绍"><a href="#一、数据库介绍" class="headerlink" title="一、数据库介绍"></a>一、数据库介绍</h1><h2 id="0x00-什么是数据库"><a href="#0x00-什么是数据库" class="headerlink" title="0x00 什么是数据库"></a>0x00 什么是数据库</h2><p>数据库是一个广义的概念：</p><ol><li><p>表示 “数据库” 这一门学科。研究如何设计实现一个数据库(造轮子)</p></li><li><p>表示一类软件，用来有效管理数据</p><p>……</p></li></ol><p>我们这里介绍的是mysql数据库管理软件。学科啥的太抽象了~</p><h2 id="0x01-数据库软件"><a href="#0x01-数据库软件" class="headerlink" title="0x01 数据库软件"></a>0x01 数据库软件</h2><p>数据库的软件大致可以分为下面几种：</p><ol><li><strong>Oracle</strong> ： 数据库软件中的大哥。但是因为软件要收费，而且Oracle数据库在使用的时候，必须搭配IBM的小型机(不是一般我们用的电脑)，才能发挥出十成功力， 但是小型机很贵，所以使用Oracle数据库的<strong>成本太高</strong>了，<strong>一般都是银行这种不差钱，且要保存非常重要的数据的公司才会使用</strong>。</li><li><strong>MySQ</strong>L：<strong>开源&amp;免费</strong>的数据库(白嫖能不香嘛)！不过已经被Oracle公司收购了~ 钞能力的强大 ~</li><li><strong>SQLSever</strong>：微软做的数据库，但是最初的时候，由于只支持Windows系统，而且还收费，而使用数据库的场景一般是服务器开发，用到的系统大多是Linux，所以到现在用的公司不是很多~</li><li><strong>SQLite</strong>：主打一个轻便。运行速度快，占用内存小，经常在嵌入式设备(智能冰箱、洗衣机、空调……)中使用~</li><li><strong>redis</strong>：与上面的数据库不同的是，redis是“<strong>非关系型数据库</strong>”。</li></ol><p><strong>补充</strong>：</p><p><strong>关系型数据库(比较传统的数据库)<strong>，是</strong>使用“表”</strong>这样的结构来组织数据的，<strong>对数据的格式要求较高</strong>，也就是说每一行的每一列都得与设置的含义匹配上。举个例子：我们创建一个int的二维数组， 里面就只能存放int型的数据，而非关系型，就类似创建一个object的二维数组，里面可以存放不止一种类型的数据。</p><p><strong>非关系型数据库</strong>，更加<strong>灵活</strong>，通常<strong>使用“文档”、“键值对”</strong>这样的结构来组织数据，也就是说<strong>一行&#x2F;条数据差异可以很大</strong>~</p><h2 id="0x02-MySQL结构"><a href="#0x02-MySQL结构" class="headerlink" title="0x02 MySQL结构"></a>0x02 MySQL结构</h2><p><strong>MySQL</strong>使用的是cs的结构，就是“<strong>客户端-服务器”</strong>结构。</p><p><strong>客户端</strong>：<strong>主动</strong>发起<strong>请求</strong>的一方</p><p><strong>服务器</strong>：<strong>被动响应</strong>客户端请求的一方。由于服务器不知道客户端什么时候请求，因此服务器需要一直等待~</p><p><strong>补充</strong>：</p><p>当客户端的数量越来越多的时候，那么他们对服务器的请求也越来越多，这就要求服务器要增加性能来应对这些请求，但是往后增加性能的成本会越来越高，因此，就出现了<strong>“分布式系统”</strong>，也就是说一台机器，<strong>既可以是服务器，也可以是客户端</strong>。当机器A想要请求资源的时候，可以对机器B发起，然后B可以看看自己有没有资源，没有的话就向其他机器请求，在这里面每一个就是一个对等体，所以也可以叫做<strong>peer to peer</strong>的模式。</p><p>虽然MySQL是客户端-服务器的结构，但是我们<strong>真实的数据是存储在硬盘上</strong>的，而<strong>服务器才是MySQL的本体，负责存储和管理数据</strong>~</p><h1 id="二、数据库操作"><a href="#二、数据库操作" class="headerlink" title="二、数据库操作"></a>二、数据库操作</h1><h2 id="0x00-创建数据库"><a href="#0x00-创建数据库" class="headerlink" title="0x00 创建数据库"></a>0x00 创建数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database [if not exists] 数据库名 charset 字符集名字;<br><br>#说明<br>#[]里面的内容是可加可不加的~<br>#if not exists 可以用来避免报错，使用场景是当我们要执行一系列的SQL语句时，如果存在了同名数据库，此时依旧会执行后面的SQL语句<br>#charset 也可以写成 character set 可以指定当前数据库使用什么编码方式<br>#在写完SQL语句后要加;号，表示此行语句写完了，因为mysql客户端允许你输入的时候换行<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p>不同的字符集，会产生不同的编码方式，也就是说在不同的字符集下，一个汉字占用几个字节是不同的。例如：<strong>gbk编码</strong>，一个<strong>汉字占用2个字节</strong>，<strong>utf8编码</strong>，一个<strong>汉字占3个字节</strong>。</p><h2 id="0x01-查看所有数据库"><a href="#0x01-查看所有数据库" class="headerlink" title="0x01 查看所有数据库"></a>0x01 查看所有数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br><br>#列出当前mysql服务器上一共有哪些数据库<br></code></pre></td></tr></table></figure><h2 id="0x02-选中数据库"><a href="#0x02-选中数据库" class="headerlink" title="0x02 选中数据库"></a>0x02 选中数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据库名;<br><br>#当我们想要对数据进行操作的时候，我们首先要选中数据库，可以理解为指向性技能~<br></code></pre></td></tr></table></figure><h2 id="0x03-删除数据库"><a href="#0x03-删除数据库" class="headerlink" title="0x03 删除数据库"></a>0x03 删除数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database 数据库名;<br><br>#删除一个数据库，会删除里面的所有内容，非常危险(从删库到跑路~)<br>#当年炉石服务器就发生了严重的数据问题，服务器选择了回档，但还好补偿够给力，玩家选择了集体失忆~<br></code></pre></td></tr></table></figure><h1 id="三、表操作"><a href="#三、表操作" class="headerlink" title="三、表操作"></a>三、表操作</h1><h2 id="0x-00-字段类型"><a href="#0x-00-字段类型" class="headerlink" title="0x 00 字段类型"></a>0x 00 字段类型</h2><p>一些常用的类型。</p><table><thead><tr><th>数据类型</th><th>大小</th><th>说明</th><th>对应java类型</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td></td><td>Integer</td></tr><tr><td>bigint</td><td>8字节</td><td></td><td>Long</td></tr><tr><td>double</td><td>8字节</td><td></td><td>Double</td></tr><tr><td>decimal(M,D)</td><td>M&#x2F;D最大值+2</td><td>M指定数的长度，D表示小数点显示到D位数</td><td>BigDecimal</td></tr><tr><td>varchar(N)</td><td>0-65535字节</td><td>可变长度字符串，N表示字符串长度</td><td>String</td></tr><tr><td>datetime</td><td>8字节</td><td>插入格式：“YY-MM-DD 00:00:00”</td><td>java.util.Date</td></tr></tbody></table><p>有了这些类型，那么就可以开始创建一张表，开始存储数据了~</p><h2 id="0x-01-创建表"><a href="#0x-01-创建表" class="headerlink" title="0x 01 创建表"></a>0x 01 创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(列名 类型, 列名 类型......);<br><br>#创建一张表，指定列的属性<br></code></pre></td></tr></table></figure><h2 id="0x-02-查看所有表"><a href="#0x-02-查看所有表" class="headerlink" title="0x 02 查看所有表"></a>0x 02 查看所有表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br><br>#查看当前数据库中所有的表<br></code></pre></td></tr></table></figure><h2 id="0x-03-查看表结构"><a href="#0x-03-查看表结构" class="headerlink" title="0x 03 查看表结构"></a>0x 03 查看表结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc 表名;<br><br>#查看指定表的结构<br>#desc 的全称是 describe 描述<br></code></pre></td></tr></table></figure><h2 id="0x-04-删除表"><a href="#0x-04-删除表" class="headerlink" title="0x 04 删除表"></a>0x 04 删除表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table 表名;<br><br>#删除指定表，比较危险需要慎重<br></code></pre></td></tr></table></figure><h1 id="四、SQL的增删改查"><a href="#四、SQL的增删改查" class="headerlink" title="四、SQL的增删改查"></a>四、SQL的增删改查</h1><p>增删改查也称crud，全称create、read、update、delete，是数据库非常基础的部分，也是后端开发工作中主要的一部分。</p><h2 id="0x-00-插入数据"><a href="#0x-00-插入数据" class="headerlink" title="0x 00 插入数据"></a>0x 00 插入数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values (值, 值......);<br><br>#此处的值需要和表的列进行一一对应， 也就是值的个数和类型要匹配<br><br>insert into 表名 (列名, 列名......) values (值, 值......);<br><br>#此处的值需要和前面的列名匹配，如果有的列没有赋值，会进行赋默认值<br><br>insert into 表名 values (值, 值......), (值, 值......);<br><br>#一次插入多个数据，相比于分多次插入会有性能的提升。因为每次一次操作客户端都要向服务器请求，服务器要响应，这一定会影响性能。<br></code></pre></td></tr></table></figure><h2 id="0x-01-删除数据"><a href="#0x-01-删除数据" class="headerlink" title="0x 01 删除数据"></a>0x 01 删除数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from 表名 where 条件;<br><br>#删除表中某一行数据<br>#如果不加where的话，将会删除表中所有数据！<br></code></pre></td></tr></table></figure><h2 id="0x-02-修改数据"><a href="#0x-02-修改数据" class="headerlink" title="0x 02 修改数据"></a>0x 02 修改数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名 set 列名 = 值 where 条件;<br><br>#将表中某一列的值修改<br>#如果不加where的话，将会修改表中所有数据！<br></code></pre></td></tr></table></figure><h2 id="0x-03-查询数据"><a href="#0x-03-查询数据" class="headerlink" title="0x 03 查询数据"></a>0x 03 查询数据</h2><h3 id="3-1-全列查询"><a href="#3-1-全列查询" class="headerlink" title="3.1 全列查询"></a>3.1 全列查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名;<br><br>#把表中所有行所有列的数据查询出来<br># * 表示通配符，代指所有列<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p><strong>select * 是一个危险操作</strong>。如果当前这个表的数据特别多，可能会把<strong>硬盘的IO跑满</strong>， 此时其他程序想要访问硬盘，会非常慢。而且由于是客户端-服务器的结构，我们是通过客户端发起请求，然后服务器通过网络将查询的结构返回给客户端，此时数据太多的话， 可能会<strong>把网卡的带宽跑满</strong>，其他客户端通过网络访问服务器将非常慢~</p><h3 id="3-2-指定列查询"><a href="#3-2-指定列查询" class="headerlink" title="3.2 指定列查询"></a>3.2 指定列查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名, 列名...... from 表名 ;<br><br>#指定查询表中指定列的数据<br></code></pre></td></tr></table></figure><h3 id="3-3-查询字段为表达式"><a href="#3-3-查询字段为表达式" class="headerlink" title="3.3 查询字段为表达式"></a>3.3 查询字段为表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 +-*/ 数字 from 表名;<br><br>#一边查询，一边进行计算<br>#这里的操作不会对真正的数据库中的数据进行修改，相当于临时的<br></code></pre></td></tr></table></figure><h3 id="3-4-别名"><a href="#3-4-别名" class="headerlink" title="3.4 别名"></a>3.4 别名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 as 别名 from 表名;<br><br>#将某一列查询后面改个名字，一般配套表达式使用<br>#这里的as可以省略也可以不省略(通常建议不省略，防止看花眼)~<br></code></pre></td></tr></table></figure><h3 id="3-5-去重"><a href="#3-5-去重" class="headerlink" title="3.5 去重"></a>3.5 去重</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct 列名, 列名...... from 表名;<br><br># distinct 修饰某个列/多个列, 此时查询的结果中相同的数据只会保留一个<br></code></pre></td></tr></table></figure><h3 id="3-6-排序"><a href="#3-6-排序" class="headerlink" title="3.6 排序"></a>3.6 排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名, 列名...... from 表名 order by 列名 desc/asc;<br><br>#以某一列的数值为准，进行排序操作<br>#如果写了desc 那就是降序，如果不写或者写了asc 那就是升序<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p>如果order by 列1, 列2, 列3  写了多个字段，那么会先按照字段的顺序进行排序，比如，现在回先按照列1进行排序，如果列1的值相同，那么再比较列2 ，以此往复~</p><h3 id="3-7-条件查询"><a href="#3-7-条件查询" class="headerlink" title="3.7 条件查询"></a>3.7 条件查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 where 条件;<br></code></pre></td></tr></table></figure><p>条件中存在着一些运算符，我们来认识一下~</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;</td><td>大于，大于等于，小于，小于等于</td></tr><tr><td>&#x3D;</td><td>等于，NULL 不安全，例如 NULL &#x3D; NULL 的结果是 NULL</td></tr><tr><td>&lt;&#x3D;&gt;</td><td>等于，NULL 安全，例如 NULL &lt;&#x3D;&gt; NULL 的结果是 TRUE(1)</td></tr><tr><td>!&#x3D;, &lt;&gt;</td><td>不等于，推荐写成 !&#x3D;</td></tr><tr><td>between a0 and a1</td><td>范围匹配，[a0, a1] 都是闭区间，如果 a0 &lt;&#x3D; value &lt;&#x3D; a1，返回 TRUE(1)</td></tr><tr><td>in (n1, n2, …..)</td><td>离散化，如果是 (n1, n2, ……) 中的任意一个，返回 TRUE(1)</td></tr><tr><td>is null</td><td>是 null</td></tr><tr><td>is not null</td><td>不是null</td></tr><tr><td>like</td><td>模糊匹配。后面可以接通配符类似于癞子，或者%表示大于等于0个字符，_表示一个字符</td></tr></tbody></table><p>还有一些逻辑运算符~</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>多个条件必须都为 TRUE(1)，结果才是 TRUE(</td></tr><tr><td>OR</td><td>任意一个条件为 TRUE(1), 结果为 TRUE(1)</td></tr><tr><td>NOT</td><td>条件为 TRUE(1)，结果为 FALSE(0)</td></tr></tbody></table><p><strong>注意</strong>：</p><p><strong>where 条件可以使用表达式，但不能使用别名。</strong></p><p>因为<strong>select 条件查询的执行顺序</strong>：</p><ol><li>遍历表中每个记录</li><li>根据记录的值带入条件，根据条件进行筛选</li><li>如果这个记录条件成立，则保留当前记录，然后进行列上的表达式计算(或者重命名啥的)</li><li>如果有order by， 再进行排序</li></ol><p>所以，在条件筛选的优先级高于列上的表达式计算，因此使用别名的话，sql服务器就不认识了~</p><h3 id="3-8-分页查询"><a href="#3-8-分页查询" class="headerlink" title="3.8 分页查询"></a>3.8 分页查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 limit n offset x;<br><br>#从索引为x的记录(第一条记录的索引为0)开始， 查询出 n 条记录<br></code></pre></td></tr></table></figure><p>以上都是基础的SQL查询语句，不过很实用~</p><h1 id="五、约束"><a href="#五、约束" class="headerlink" title="五、约束"></a>五、约束</h1><p>有时候，数据库中数据是有约束的，比如 性别列，你不能填一些奇奇怪怪的数据~</p><p>如果靠人为的来对数据进行检索约束的话，肯定是不行的，人肯定会犯错~因此就需要让计算机对插入的数据进行约束要求！</p><p><strong>约束的使用语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create 表名 (列名 类型 约束);<br><br>#在创建表的时候对某一列数据进行约束操作<br></code></pre></td></tr></table></figure><p><strong>在mysql中提供了如下约束</strong>：</p><table><thead><tr><th>约束</th><th>说明</th></tr></thead><tbody><tr><td>not null</td><td>某一列的数据不能为null值</td></tr><tr><td>unique</td><td>某一列中的值唯一</td></tr><tr><td>default</td><td>规定没有给某列赋值时为默认值</td></tr><tr><td>primary key</td><td>not null 和 unique 的结合。记录身份的标识，一般配合自增主键使用</td></tr><tr><td>foreign key</td><td>保证一个表中的数据匹配另一个表中的值的参照完整性</td></tr><tr><td>check</td><td>保证列中的值符合指定条件</td></tr></tbody></table><p>注意：使用约束的话，一定会数据库的效率有影响！</p><p>由于not null、 unique、default、check比较容易，这里就对主键(primary key)和外键(foreign key) 进行解释。</p><h2 id="主键primary-key"><a href="#主键primary-key" class="headerlink" title="主键primary key"></a>主键primary key</h2><p>主键可以理解为记录的身份标识，就像身份证一样是我们每个人的身份标识，既不能为空，又不能重复。</p><p><strong>一张表里只能有一个主键</strong>，毕竟是身份标识嘛，存在多个了，以谁为准???</p><p>虽然主键只能有一个，但是<strong>主键不一定是一列</strong>，可以用<strong>多个列共同构成主键</strong>(联合主键)。</p><p>由于主键具有unique属性，因此我们一般<strong>配合mysql中 ”自增主键”</strong> 来使用，也就是会自动分配一个逐个增长的值~</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名 (列名 类型 primary key auto_increment);<br></code></pre></td></tr></table></figure><p>如果手动插入一个数据，此时<strong>数据库会与主键最高的值进行比较</strong>，如果高了就更新，<strong>此后自动分配的值也会从这个最高值进行增长</strong>！</p><p><strong>拓展</strong>：</p><p>如果是<strong>分布式系统</strong>，在<strong>同一时间插入了一个数据</strong>，此时<strong>自增主键就会出错</strong>，那么如何处理这种并发场景呢？</p><p><strong>一般会使用一个公式来形成主键</strong>：</p><p>分布式主键值 &#x3D;  时间戳 + 机房编号&#x2F;主机号 + 随机因子   此处使用的是字符串拼接操作!!!</p><p>前面两个可以<strong>防止在同一时间不同机器的的主键冲突</strong>，后面的<strong>随机因子</strong>可以<strong>防止同一时间同一机器的主键冲突</strong>，但是理论上还是有可能存在冲突的~</p><h2 id="外键foreign-key"><a href="#外键foreign-key" class="headerlink" title="外键foreign key"></a>外键foreign key</h2><p>案例引入： </p><p>现在我们有两张表，一张是学生表，里面有学号、姓名、班级号字段，另一张表示班级表，里面有班级号、班级名字段。</p><img src="/2023/07/31/MySQL/image-20230803084857974.png" class title="image-20230803084857974"><img src="/2023/07/31/MySQL/image-20230803085241442.png" class title="image-20230803085241442"><p>我们细细观察，可以发现，肯定是先有班级表，学生的班级号才能确定，但是现在突然冒出了一个classId 为 300的学生，但是在我们的班级表中不存在这个班级号，为了防止这种情况发生，我们可以使用外键约束~</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名 (列名 类型, 列名 类型, ......, foreign key (列名) references 主表名(列名));<br><br>#我们创建学生表的时候可以这样写：<br>#create table student (id int, name varchar(20), classId int, foreign key （classId） references class(classId));<br>#student表的classId 的所有数据都要出自于class表的classId这一列，也就是说如果class表中没有这个班级号，那么我们插入的学生信息将会报错~<br></code></pre></td></tr></table></figure><p><strong>使用外键</strong>之后，<strong>被约束的表就称为子表</strong>， <strong>另一张表相对的就是父表</strong>，<strong>子表</strong>中的那一个字段的<strong>数据</strong>都要<strong>出自父表</strong>。当然，力的作用是相互的，约束也不例外，当我们想要<strong>删除&#x2F;修改父表的约束子表的那个字段</strong>，如果子表<strong>已经引用</strong>过了，那么我们将会<strong>删除&#x2F;修改失败</strong></p><p><strong>注意</strong>：</p><p><strong>父表中约束子表的字段必须为主键或者unique！！！</strong></p><h1 id="六、表的设计"><a href="#六、表的设计" class="headerlink" title="六、表的设计"></a>六、表的设计</h1><p> 在实际的场景中，有大量的数据，我们需要明确当前要创建几个表，每个表有什么字段，这些表中是否存在一定的联系。</p><p>因此根据实际开发就整理出了三大范式~</p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>例如：<strong>一个学生只有一个账号，一个账号只属于一个学生</strong>。</p><p>此时我们设计两张表，让其中的一张表存储另一张表的<strong>唯一</strong>属性，这样我们可以通过这个属性就能找到想要的值了。或者也可以将两张表整合，成为一张表。</p><img src="/2023/07/31/MySQL/image-20230813092055975.png" class title="image-20230813092055975"><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>例如：<strong>一个学生只能属于一个班级，一个班级可以拥有多个学生。</strong></p><p>此时我们设计两张表，<strong>将那个“一”的表中添加上“多”的表中的唯一的字段</strong>。</p><p><strong>补充</strong>：如果是redis这种能够支持数组类型的数据库，我们可以不这样设计，可以使用一个数组类型，用来存储多个学生。如下图：</p><img src="/2023/07/31/MySQL/image-20230813093004691.png" class title="image-20230813093004691"><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>例如：一个学生可以选多门课程，一个课程可以被多名学生选择。</p><p>此时我们需要再<strong>创建一张表来描述这两张表之间的关系</strong>。</p><img src="/2023/07/31/MySQL/image-20230813093735349.png" class title="image-20230813093735349"><h1 id="七、查询增强-进阶"><a href="#七、查询增强-进阶" class="headerlink" title="七、查询增强(进阶)"></a>七、查询增强(进阶)</h1><p><strong>查询操作有很多的花样，但一般实际开发中最最最常使用的还是前面基础的crud操作。</strong></p><h2 id="0x-00-聚合查询"><a href="#0x-00-聚合查询" class="headerlink" title="0x 00 聚合查询"></a>0x 00 聚合查询</h2><p>之前的<strong>表达式查询</strong>是对于一条记录上的<strong>列与列</strong>之间进行运算的，如果要针对<strong>行与行之间进行运算</strong>呢？这时候就要用到<strong>聚合查询</strong>了~</p><p>首先来了解一些聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>count()</td><td>返回查询数据的个数</td></tr><tr><td>sum()</td><td>返回查询数据的总和，不是数字没意义</td></tr><tr><td>avg()</td><td>返回查询数据的平均值，不是数字没意义</td></tr><tr><td>max()</td><td>返回查询数据的最大值，不是数字没意义</td></tr><tr><td>min()</td><td>返回查询数据的最小值，不是数字没意义</td></tr></tbody></table><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count([distinct]表达式) from 表名;<br>select sum([distinct]表达式) from 表名;<br>select avg([distinct]表达式) from 表名;<br>select max([distinct]表达式) from 表名;<br>select min([distinct]表达式) from 表名;<br><br>#注意：<br>#count(*) 和 count(列名)的区别，count(*)会把一条为null的数据也统计进去，而count(列名)则不会<br>#如果计算字符串的值，需要字符串合法，因为mysql会尝试转成double<br></code></pre></td></tr></table></figure><h2 id="0x-01-分组查询"><a href="#0x-01-分组查询" class="headerlink" title="0x 01 分组查询"></a>0x 01 分组查询</h2><p>分组查询一般会配合聚合查询，因为分组查询会把几行数据看做是一行，如果不使用聚合查询，那么显示的结果为一组中某一个数据。</p><p><strong>举例：</strong></p><p><strong>求各班的平均成绩：</strong></p><img src="/2023/07/31/MySQL/image-20230808091752885.png" class title="image-20230808091752885"><p>那么我们的代码得这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(socre) from class group by class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808091927650.png" class title="image-20230808091927650"><p><strong>使用group by的时候，还可以搭配条件。此时我们需要区分该条件是分组前的，还是分组之后的？</strong></p><p>如果是分组前，使用where条件查询</p><p>如果是分组后，使用having条件查询</p><p>举例：</p><p><strong>查询各班平均分，但是学生成绩不能超过100</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(socre) from class where socre &lt;= 100 group by class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808092930270.png" class title="image-20230808092930270"><p><strong>查询平均分大于100分的班级</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(score) from class group by class_id having avg(score) &gt; 100;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808093239831.png" class title="image-20230808093239831"><h2 id="0x-02-联合查询"><a href="#0x-02-联合查询" class="headerlink" title="0x 02 联合查询"></a>0x 02 联合查询</h2><p>联合查询也就是多表查询，就是在多张表上进行查询。但是联合查询也会有<strong>一些问题</strong>……</p><p><strong>联合查询会产生笛卡尔积</strong>，也就是说表A中的每一条数据都会与表B中每一条数据进行组合，如果A表中的数据个数为100，表B中的数据个数为100，那么最终会产生100<em>100条数据。但是仔细观察，会发现有一些数据是“非法”的。*<em>笛卡尔积是简单的排列组合，穷举所有情况，因此你我们需要筛选数据~</em></em></p><p><strong>如果要联合n张表进行查询，那么我们需要使用n-1个连接条件，才不会出现笛卡尔积的现象~</strong></p><img src="/2023/07/31/MySQL/image-20230808094213698.png" class title="image-20230808094213698"><p><strong>此时就出现了笛卡尔积，但是仔细观察，会发现class_id 不同的数据都组合到了一起，因此我们需要一个连接条件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select student.class_id, student.name, class.socre from student, class where student.class_id = class.class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808094523104.png" class title="image-20230808094523104"><hr><p><strong>由于多表查询一般比较复杂，我们可以按照如下的步骤来写：</strong></p><p>1、先进行指定哪个几个表，进行笛卡尔积</p><p>2、指定连接条件，去除笛卡尔积</p><p>3、精简列数据</p><p>以上查询都是基于“内连接“的操作，然而mysql还提供了”外连接“(左外连接，右外连接)</p><hr><p><strong>案例引入</strong>：</p><p>现有如下表<img src="/2023/07/31/MySQL/image-20230808095817918.png" class title="image-20230808095817918"></p><p>此时<strong>student的每一条记录都可以在score表中找到对应，每一个score中记录也可以在student表中找到对应。</strong></p><p>此时我们使用外内接或者内连接查询的结果是一样。</p><img src="/2023/07/31/MySQL/image-20230808100511716.png" class title="image-20230808100511716"><p><strong>但是如果不存在记录，那么内连接与外连接就会天差地别~</strong></p><img src="/2023/07/31/MySQL/image-20230808100806990.png" class title="image-20230808100806990"><p>外连接分为左外连接和右外连接。</p><p><strong>左外连接：</strong>以左表为基准，保证左侧表的每个数据都会出现在最终的结果集里，如果右表没有与之对应的记录则显示null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名1 left join 表2 on 连接条件<br></code></pre></td></tr></table></figure><p><strong>右外连接：</strong>以右表为基准，保证右侧表的每个数据都会出现在最终的结果集里，如果左表没有与之对应的记录则显示null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名1 right join 表2 on 连接条件<br></code></pre></td></tr></table></figure><p>我们还可以用集合图来表示这些连接的关系：</p><img src="/2023/07/31/MySQL/image-20230809090138583.png" class title="image-20230809090138583"><p><strong>补充</strong>：</p><p>以上我们都是针对于两个表进行联合查询的，但我们甚至还可以<strong>将一个表当做两个表来进行联合查询</strong>，这样我们就能在一张表中进行 <strong>行与行的比较</strong>~这种连接方式一般被称为<strong>“内连接”</strong>。</p><p>自连接的查询跟上面的联合查询基本没什么区别，需要注意将两张表进行别名操作~</p><h2 id="0x-03-子查询"><a href="#0x-03-子查询" class="headerlink" title="0x 03 子查询"></a>0x 03 子查询</h2><p><strong>子查询是将多个简单的SQL语句拼成一个复杂的SQL, 也就是说将某一个查询的结果看做是一张表，然后进行操作，但本质是在套娃</strong>。因此我们实际也是可以用简单的查询完成子查询的操作的~ (合成2048？合成复杂SQL！)</p><p>语法形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 where 列名 = (select 列名 from 表名 where 列名 = (套娃下去....));<br></code></pre></td></tr></table></figure><h2 id="0x-04-合并查询"><a href="#0x-04-合并查询" class="headerlink" title="0x 04 合并查询"></a>0x 04 合并查询</h2><p>合并查询就是<strong>将多个sql的查询结果集 合并在一起</strong>。合并的两个sql结果集的列，需要<strong>匹配，列的个数和类型得是一致的</strong>！<strong>合并的时候是会进行去重的，如果不想要去重，得使用 union all</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名1 列名2 from 表1 union [all] select 列名3 列名4 from 表2;<br></code></pre></td></tr></table></figure><p><strong>最终结果</strong>：</p><img src="/2023/07/31/MySQL/image-20230809092917129.png" class title="image-20230809092917129"><h1 id="八、索引"><a href="#八、索引" class="headerlink" title="八、索引"></a>八、索引</h1><p>由于我们在使用数据库的时候，<strong>大部分操作的都是查询操作</strong>，但是我们<strong>每一次进行查询都需要遍历一遍表</strong>中所有数据，这会花费O(n)的时间，因此数据<strong>引入了“索引”</strong> 也就是在底层使用了数据结构来进行<strong>优化查询</strong>的操作，但是可能会<strong>造成插入&#x2F;删除操作变慢</strong>和<strong>消耗空间</strong>。</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show index from 表名;<br><br>#查看表中哪一列有索引<br><br>create index 索引名字 on 表名(列名);<br><br>#对某一列创建索引<br><br>drop index 索引名 on 表名;<br><br>#删除索引<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>一个索引是针对列来指定的。<strong>只有针对这一列进行查询时</strong>，查询速度才能被索引优化~如果进行全列查询的话，那还是需要遍历表的。</p><p><strong>如果某一列被primary key、foreign key、unique所约束的话，会自动创建索引</strong>。</p><p><strong>创建索引</strong>也是一个相当<strong>危险的操作</strong>，因为创建索引是需要对现有的数据进行大规模的整理，如果数据非常多，很容易就把服务器卡住，一般来说创建索引的时候都是在创建完表后立马操作，一旦使用久了的话， 需要慎重操作。不过也可以采用分治的思想，一点一点将数据写入到创建好的表中~</p><hr><p><strong>以上内容都是基础的知识，但是面试常考查的是索引的底层~~</strong></p><p>(由于本人水平有限，在此先简单介绍简单的内容知识~)</p><p>索引的底层使用的是<strong>一种类似二叉搜索树</strong>(在极端情况下，<strong>二叉搜索树的时间复杂度为O(n)，AVL树，红黑树能达到O(logn)</strong>)的树 ，也就是<strong>一棵改进的树形结构：B+树</strong>。可能会好奇，为啥不用哈希表呢？时间复杂度可以O(1),这是因为<strong>在查询的过程中我们往往会进行范围查询，而哈希表只能进行精确的查询</strong>，因此我们不使用哈希表。</p><img src="/2023/07/31/MySQL/f070fdfc8e4b40dda2ebee96c3c6170a.jpeg" class title="img"><p>B+树顾名思义是在B树的基础上改进的。那啥是B树呢？</p><p>B树：是一棵<strong>N叉搜索树</strong>，每个节点的度不确定，一个节点上保存N个数据的值，划分出N + 1个区间，每个区间衍生出一棵子树。</p><p><strong>逻辑上存储结果如下</strong>：</p><img src="/2023/07/31/MySQL/image-20230810085349816.png" class title="image-20230810085349816"><p>而B+树则是对B树的改进，感觉像是针对数据库进行量身定做。</p><p>如果使用B树会有遇到什么问题呢？假如我们现在要使用范围查询去查询10-40之间的数。我们在如下图中进行观察：</p><img src="/2023/07/31/MySQL/image-20230810093232881.png" class title="image-20230810093232881"><p><strong>搜索过程大致如下</strong>：</p><p>我们先要进行小于20区间的搜索，然后再进行20-40区间的搜索，里面<strong>包含大量“向下递”(需要开辟内存空间)，”回溯“的操作</strong>，如果一棵区间子树的高度较高，我们需要花费较多时间进行这个子树的搜索，恰巧另一些范围内的数据在另一棵子树上，那么我们又要花费较多时间进行搜索。<strong>总的来说，由于范围查询，我们有时要搜索多棵子树，这会导致效率的下降。</strong></p><p>基于这些缺点，B+树进行了优化。首先，<strong>B+数在每个非叶子节点上存储的是索引</strong>(B树上就是实际的值)，<strong>所有数据都是存储在叶子节点上</strong>，<strong>B+树再使用了一个链表</strong>，将所有叶子节点连了起来，这就导致了<strong>范围查询更加高效</strong>，因为只要找到了一个符合要求的叶子节点，我们就直接对链表进行遍历，省去了再搜索其他子树的操作。</p><hr><p><strong>B+树的优点(相比B树、哈希、红黑树)：</strong></p><p>1、<strong>是一棵N叉搜索树，因此树的高度比较小</strong>。</p><p>2、<strong>磁盘IO次数更少，效率更高</strong>。</p><p>红黑树是一棵平衡二叉搜索树，为了平衡需要进行旋转操作，而<strong>旋转操作时针对于整棵树</strong>的，但是因为数据库中可能存储着大量的数据，我们往往<strong>不能将所有的数据读取到内存中，因此需要部分多次读取</strong>，这就导致了旋转可能会有问题且效率不高，而且也<strong>无法利用磁盘预读</strong>(存储器某一个位置被访问了，那么其附近位置也会被访问)。</p><p>在B树中，<strong>每一个节点是在一个硬盘区域中</strong>，可以利用磁盘预读，<strong>一次读硬盘就能取出整个节点(<strong>多个键值对)。而</strong>读取硬盘的时间远大于内存比较的时间</strong>，近似于 读一次硬盘 &#x3D; 内存1w次比较。</p><p>在B+树中，<strong>非叶子节点上是存的索引信息</strong>，而对应数据库中一行数据可能内容比较多，但是单单某一行的<strong>某一列(索引)所占空间往往只有几个字节</strong>，因此我们能够<strong>将所有的索引信息读取到内存中进行比较</strong>，然后找到叶子节点上的值，再通过链表遍历的方式进行搜索，从而大大减少了IO次数。</p><p>3、所有的查询最终要落实到叶子节点，因此整体的<strong>查询效率比较稳定</strong>，而B树中可能在前面的节点就能找到，复杂度为O(1), 不稳定。</p><p>4、<strong>非常擅长范围查询</strong></p><h1 id="九、事务"><a href="#九、事务" class="headerlink" title="九、事务"></a>九、事务</h1><p>事务：一组数据库的操作语句，这些操作将会被视为一个整体，保证要么这些语句全部执行，要么“一个都不执行”。</p><h2 id="0x-00-案例引入"><a href="#0x-00-案例引入" class="headerlink" title="0x 00 案例引入"></a>0x 00 案例引入</h2><img src="/2023/07/31/MySQL/image-20230806090729717.png" class title="image-20230806090729717"><p>现在，SQL语句执行完了第一条但是还没执行第二条的时候，突然电脑关机&#x2F;程序崩溃了…….</p><p>张三一看已经扣了钱，但是李四却没有收到，这就很尴尬了。此时我们需要引入“事务”，来帮助我们解决这个问题，也就是要么张三扣了钱，李四收到了钱，要么就无事发生~ <strong>我们将这种“要么全部执行，要么相当于没有执行”这个特殊的性质称为“原子性”</strong></p><h2 id="0x-01-事务的特性ACID"><a href="#0x-01-事务的特性ACID" class="headerlink" title="0x 01 事务的特性ACID"></a>0x 01 事务的特性ACID</h2><p>1、<strong>原子性(Atomicity)</strong> ：<strong>事务出现的原因</strong>。将一系列sql语句看成一个整体，要么全部执行，要么通过回滚的方式，恢复如初。</p><p>2、 <strong>一致性(Consistency)</strong> ：事务执行之前和之后，数据都不能出现非法的情况。</p><p>3、 <strong>持久性(Durability)</strong> ：事务做出的修改，都是在硬盘上持久保存的，即使在系统故障或者崩溃的情况下，事务执行的修改都是有效的。</p><p>4、<strong>隔离性(Isolation)</strong> ：<strong>由于mysql是客户端-服务器的模式，会存在并发的情况，即多个用户在同一时间请求服务器。</strong>事务的执行是相互隔离的，一个事务的操作不应该影响其他事务的操作。</p><p><strong>补充</strong>：</p><p><strong>并发操作往往能提高效率，但是会降低准确性</strong>。mysql数据库在并发执行的时候，会遇到如下问题：</p><p><strong>1、脏读：</strong></p><p>事务A在**改变(修改，增加，删除) **数据</p><p>事务B在事务A未提交的时候就来读取数据</p><p>后来事物A可能在事物B读完了数据后又修改了或者回滚了，此时事务B读到数据就是“脏”的，即无效的。</p><p><strong>脏读也就是在写的过程中进行读操作。 <strong>解决脏读问题，思路是</strong>对写操作进行加锁</strong>，告诉事务B在我写的时候，不要来读取数据。此时并发性降低了，隔离性提高了，效率降低了，准确性提高了~</p><p><strong>2、不可重复读：</strong></p><p>事务B在读取数据</p><p>事务A<strong>修改或删除了数据</strong>然后提交事务</p><p>事务B第二次读数据的时候，发现两次读到的数据不相同，也就是事务A在事物B两次读取的时候进行了修改。</p><p><strong>不可重复读也就是在读的过程中进行了写操作</strong>。解决不可重复读问题，思路是<strong>对读操作进行加锁</strong>，告诉事务A在我读的时候，不要来修改数据。</p><p><strong>3、幻读：</strong></p><p>事务B在读数据</p><p>事务A此时<strong>插入了数据</strong>然后提交了事务</p><p>事务B第二次读数据，然后读到了与第一不一样的结果集。</p><p><strong>幻读与不可重复读类似，区别在于幻读是强调插入操作，不可重读是修改操作。</strong>解决幻读的问题，思路是<strong>引入串行化的方式</strong>，保证绝对的串行执行事务，此时完全没有并发了。</p><p>针对以上的问题，mysql提供了4种隔离级别，可以在mysql配置文件中修改~</p><table><thead><tr><th>隔离级别</th><th>解决问题</th></tr></thead><tbody><tr><td>read uncommitted(读未提交)</td><td>隔离性最低，但效率最高</td></tr><tr><td>read committed(读已提交)</td><td>给写加锁，解决脏读</td></tr><tr><td>repeatable read(可重复读)</td><td>给读、写加锁，解决脏读、不可重复读</td></tr><tr><td>serializable(串行化)</td><td>严格按照串行的方式，一个一个执行事务，解决脏读、不可重复读、幻读</td></tr></tbody></table><h2 id="0x-02-操作语句"><a href="#0x-02-操作语句" class="headerlink" title="0x 02 操作语句"></a>0x 02 操作语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction; #开启事务<br><br>进行一些列sql语句......<br><br>rollback;   #回滚事务，恢复到未执行事务前<br><br>commit;   #提交事务<br><br><br>#事务的使用很简单，但需要关注事务背后的一些原理性质的内容<br></code></pre></td></tr></table></figure><h1 id="十、JDBC"><a href="#十、JDBC" class="headerlink" title="十、JDBC"></a>十、JDBC</h1><h2 id="0x-00-什么是JDBC"><a href="#0x-00-什么是JDBC" class="headerlink" title="0x 00 什么是JDBC"></a>0x 00 什么是JDBC</h2><p>JDBC代表Java连接数据库，也就是<strong>通过Java代码操作数据库</strong>。</p><p>在初期，市面上有着许多的数据库，如：MySQL, Oracle, SQL Sever…….但是<strong>不同的数据库</strong>大概率是<strong>由不同的程序员所开发</strong>出来的，因此在使用方面<strong>存在差异(如：方法名，类名，功能不同)<strong>，这就大大的增加了程序员的难度，苦不堪言~这时候就需要一个真正有分量的大佬来一统江湖！！！于是</strong>Java就自己设计出一套API的规范</strong>，让各种各样的<strong>数据库都要遵守</strong>，因此<strong>java程序员只需要会一套自己的API就好了</strong>，大大减少了学习成本~</p><img src="/2023/07/31/MySQL/image-20230811195028006.png" class title="image-20230811195028006"><p><strong>各厂商实现了接口</strong>后将其打包好并发布，如果<strong>Java程序员想要操作MySQL的话，只需要导入MySQL实现的jar包</strong>，然后在程序中调佣Java自己制定的API即可。其他如果数据库也同理，不过需要导入不同厂家的jar包。</p><h2 id="0x-01导入jar包"><a href="#0x-01导入jar包" class="headerlink" title="0x 01导入jar包"></a>0x 01导入jar包</h2><p>在使用Java操作数据库前需要先将下载好的jar包(可以去中央仓库下载)导入程序。</p><p><a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">Maven Repository: mysql » mysql-connector-java (mvnrepository.com)</a></p><img src="/2023/07/31/MySQL/image-20230811200839804.png" class title="image-20230811200839804"><p>然后就可以在程序中使用了。</p><h2 id="0x-02-使用JDBC"><a href="#0x-02-使用JDBC" class="headerlink" title="0x 02 使用JDBC"></a>0x 02 使用JDBC</h2><p><strong>1、创建DataSource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里我们可以看到，我们<strong>创建了一个dataSource</strong>，但是使用的时候却<strong>进行了向下转型</strong>，那<strong>为什么不直接创建一个MysqlDataSource的呢？</strong>这是因为要<strong>降低代码的耦合度</strong>，让MysqlDataSource这个类名不要扩散到代码的其他地方，如果后续要操作别的数据库了，代码的改动比较小。</p><p>那<strong>Url是什么</strong>呢？<strong>url表示网络上的资源位置通俗讲就是网址</strong>，因为服务器是cs模式，需要通过网络交互。</p><p><strong>127.0.0.1 表示IP地址</strong>，描述网络上一个主机所在的位置，不过这个IP地址是一个<strong>“环回IP”</strong>，即自己把数据发给自己。这是因为<strong>jdbc程序和mysql服务器都在我们自己的电脑上</strong>~</p><p><strong>3306 表示端口号，用来区分不同进程的。</strong></p><p>test 表示数据库名称。</p><p>？&amp; &#x2F;…… 这些符号是一些特殊符号。这里从？后面，表示访问资源的时候，需要哪些参数</p><p>useSSL&#x3D;false 表示是否要加密</p><p>这里dataSource光写url的话 只能找到mysql服务器，但还得登录认证，因此还需要设置账号，密码。</p><p><strong>2、和数据库服务器建立连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在创建的时候千万不要选错！！！</strong></p><img src="/2023/07/31/MySQL/image-20230811203528869.png" class><p><strong>3、构造sql语句并执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(1, &#x27;张三&#x27;)&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> statement.executeUpdate(); <span class="hljs-comment">//看看修改了几条</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过使<strong>用preparedStatement进行对sql语句的检查</strong>，在<strong>将sql发给服务器之前先看看有没有语法错误</strong>啥的，这样就能<strong>减小mysql服务器的开销</strong>。</p><p>如果要执<strong>查询操作</strong>的话，要<strong>使用executeQuery()方法</strong>，如果是<strong>改操作</strong>的话，<strong>使用executeUpdate()方法</strong>。</p><p><strong>4、执行完后关闭连接，释放资源</strong></p><p><strong>程序通过代码和服务器进行通信</strong>，是<strong>需要消耗一定的资源</strong>的。因此在程序结束后需要告知服务器，<strong>释放这些资源</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(1, &#x27;张三&#x27;)&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> statement.executeUpdate();<br><br>        statement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>后申请的先释放！</strong></p><h2 id="0x-03自定义sql语句"><a href="#0x-03自定义sql语句" class="headerlink" title="0x 03自定义sql语句"></a>0x 03自定义sql语句</h2><p>刚刚我们是为了演示总得流程，所以sql语句就在程序中写死了，如果我们要插入我们想要的数据该怎么办呢？</p><p>方案一：</p><p>创建变量让用户输入赋值修改就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into sutdent values (&quot;</span> + id + <span class="hljs-string">&quot;, &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>这样写，既不优雅，也不安全。这么多符号很容易出错，然后如果用户是高手，懂<strong>sql注入</strong>的话，那就危险了。name一栏不好好写，写成 删库 那就惨了。</p><p>方案二：</p><p>创建变量并<strong>使用占位符</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(?, ?)&quot;</span>;<br>statement.setInt(<span class="hljs-number">1</span>, id); <span class="hljs-comment">//当心第一个是从1位置开始计算的，而不是0</span><br>statement.setString(<span class="hljs-number">2</span>, name);<br></code></pre></td></tr></table></figure><p>这样就好多了~</p><h2 id="0x-04-输出查询结果"><a href="#0x-04-输出查询结果" class="headerlink" title="0x 04 输出查询结果"></a>0x 04 输出查询结果</h2><p>查询在数据库操作中是大头，怎么将查询结果输出呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from student&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span>  statement.executeQuery();<br>        <span class="hljs-keyword">while</span>(resultSet.next())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>            System.out.println(id + <span class="hljs-string">&quot;,&quot;</span> + name);<br>        &#125;<br><br>        resultSet.close();<br>        statement.close();<br>        connection.close();<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们的<strong>查询结果返回的是一张临时表</strong>，此时需要<strong>使用ResultSet类来接收结果集</strong>。然后要进行<strong>遍历ResultSet</strong>才能取出全部数据。</p><p>遍历ResultSet是<strong>通过调用next方法</strong>获取临时表中的每一行数据。这个next方法<strong>相当于在临时表中有一个“光标”，一开始的时候指向的是第一行的前一个位置，而每一次执行，就相当于将光标移到下一行。如果走到最后一行，将会放回false。</strong></p><p><strong>resultSet中提供了getXXX方法</strong>，里面的<strong>参数是列名</strong>，这样就可以拿到一行中的某一列数据了。</p><p>最后记得要释放result资源~</p><hr><p>以上就是一些mysql中高频常用的知识了~</p><p>完结，撒花~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包装类|认识泛型</title>
    <link href="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/"/>
    <url>/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、包装类"><a href="#一、包装类" class="headerlink" title="一、包装类"></a>一、包装类</h1><h2 id="0x-00为什么要有包装类？"><a href="#0x-00为什么要有包装类？" class="headerlink" title="0x 00为什么要有包装类？"></a>0x 00为什么要有包装类？</h2><p>众所周知，在java中，<strong>类的祖先是Object</strong>，但是基本数据类型，如int、float等并不是继承自Object，但是<strong>为了在泛型代码中可支持基本类型</strong>，Java给每个基本类型都对应了一个包装类型。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="0x-01装箱和拆箱"><a href="#0x-01装箱和拆箱" class="headerlink" title="0x 01装箱和拆箱"></a>0x 01装箱和拆箱</h2><p><strong>装箱</strong>：把一个 <strong>基本数据类型</strong> 转化为 <strong>包装类</strong></p><p><strong>拆箱</strong>：把一个 <strong>包装类</strong> 转化为 <strong>基本数据类型</strong></p><p><strong>装箱</strong>又分为 <strong>自动装箱</strong> 和 <strong>显示装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> n; <span class="hljs-comment">//自动装箱</span><br>    System.out.println(i1);<br>    <br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> Integer.valueOf(n); <span class="hljs-comment">//显示装箱</span><br>    System.out.println(i2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们可以通过javap进行反汇编，看看编译器偷偷隐藏了什么操作</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517200812580.png" class title="image-20230517200812580"><p><strong>拆箱</strong>也分 <strong>自动拆箱</strong> 和 <strong>显示拆箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n.intValue();<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517201347559.png" class title="image-20230517201347559"><p><strong>我们可以看到，就算我们没有显示调用intValue方法，编译器也在底层偷偷的调用了intValue方法</strong></p><h2 id="0x-02注意"><a href="#0x-02注意" class="headerlink" title="0x 02注意"></a>0x 02注意</h2><p>当写出如下代码时，需要注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    System.out.println(c == d);<br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    System.out.println(a == b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果为：true和false</strong></p><p><strong>因为在Integer底层，装箱的时候会调用valueOf方法，而这个方法，会根据数字给定的范围，返回的是不同的“结果”。</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517202210854.png" class title="image-20230517202210854"><p><strong>当i &gt;&#x3D; -128 &amp;&amp; i &lt;&#x3D; 127的时候，会返回一个static共享的数组，而不在这个范围的时候，就会返回一个新的对象！</strong></p><h1 id="二、认识泛型"><a href="#二、认识泛型" class="headerlink" title="二、认识泛型"></a>二、认识泛型</h1><h2 id="0x-00什么是泛型"><a href="#0x-00什么是泛型" class="headerlink" title="0x 00什么是泛型"></a>0x 00什么是泛型</h2><p>一般的类和方法，只能使用具体的类型，要么是基本类型，要么是自定义类型，如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。——《Java编程思想》</p><p><strong>泛型，通俗讲，就是适用于多种类型。从代码上讲，就是对类型实现了参数化</strong>。(当我们自己写一个冒泡排序的时候，我们用的是int，如果我们要排序别的类型，就得对代码改改，但通过泛型，我们可以一次编写，随便使用~)</p><h2 id="0x-01案例引入"><a href="#0x-01案例引入" class="headerlink" title="0x 01案例引入"></a>0x 01案例引入</h2><p>如果现在要实现一个类，类中包含一个数组成员，这个数组中可以存放任何类型的数据，也可以返回数组中的某个下标值。</p><p><strong>因为要放任何类型的数据，因此我们要类的祖先Object数组来存放。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span>&#123;<br>        <span class="hljs-keyword">return</span> array[pos];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, Object val)</span>&#123;<br>        array[pos] = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写，会有<strong>两个缺陷</strong>：</p><p><strong>1.数组想放啥类型的数据就放什么类型的数据，不便于管理。</strong></p><p><strong>2.当我们取出数据的时候，还需要强制类型转换，很麻烦。</strong></p><p>于是，就引出了泛型~</p><h2 id="0x-02泛型"><a href="#0x-02泛型" class="headerlink" title="0x 02泛型"></a>0x 02泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span>&#123;<br>        <span class="hljs-keyword">return</span> (T)array[pos];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, T val)</span>&#123;<br>        array[pos] = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当我们这样写，T就相当于参数，我们在使用的时候就可以传入所需要的类型，然后，一旦我们存数据的时候，如果类型不匹配，会报编译错误，然后我们在取数据的时候也不需要再强制类型转换了，解决了我们的痛点。</strong></p><p>如果我们把数组写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这样写是不对的,会报编译错误</span><br><span class="hljs-keyword">private</span> T[] arr = (T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这样写，也会有问题，因为泛型的编译机制。</span><br></code></pre></td></tr></table></figure><p>小结：</p><p>1.泛型是将数据类型参数化，进行传递的。因此程序员可以在编译时指定</p><p>2.使用<T>表示当前类是一个泛型类</T></p><h2 id="0x-03泛型的编译"><a href="#0x-03泛型的编译" class="headerlink" title="0x 03泛型的编译"></a>0x 03泛型的编译</h2><p>泛型是怎么编译的呢？简单来说，<strong>泛型会再编译的过程中，将所有的T替换为Object</strong>，我们称这种机制为 <strong>擦除机制</strong>。</p><p>现在我们来对这段代码进行解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T[] arr = (T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>如果我们这样写，尽管编译的时候能编译过，但是在Java中不允许你将数组类型强制转换为其他类型，在运行的时候会抛出异常！</p><p><strong>如下代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;bcd&quot;</span>;<br>String[] strs = (String[])arr;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230518162513603.png" class title="image-20230518162513603"><p><strong>原因是：将Object[]分配给String[]引用，程序报错。</strong></p><p><strong>通俗来讲，Object数组中可能存放任何类型的数据，运行时，直接转换，编译器认为是不安全的。</strong></p><p>因此，推荐如下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>底层源码也是这样写的~</p><h2 id="0x-04泛型的上界"><a href="#0x-04泛型的上界" class="headerlink" title="0x 04泛型的上界"></a>0x 04泛型的上界</h2><p>在定义泛型类的时候，有可能会对传入的类型进行一定的约束，可以通过类型边界来约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArr</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&gt;&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样写，就只能接受Base类和Base的子类类型了。因此我们可以通过这样的方式对类型进行约束。</p><p>当然，还可以”继承”接口，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFun</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt;<br></code></pre></td></tr></table></figure><p>如果这样写的话，那么传入的那个类型必须是实现了Compareable这个接口，也就是说这个类是可以比较的。</p><p>举个列子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFun</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">findMax</span><span class="hljs-params">(T[] arr)</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i].compareTo(ans) &gt; <span class="hljs-number">0</span>)&#123;<br>                ans = arr[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] integers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        MyFun&lt;Integer&gt; fun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFun</span>&lt;&gt;();<br>        System.out.println(fun.findMax(integers));<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样我们通过泛型，实现了一个可以得到任何类型的最大值的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象——简单工厂模式</title>
    <link href="/2023/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、案例引入"><a href="#一、案例引入" class="headerlink" title="一、案例引入"></a>一、案例引入</h1><p><strong>需求</strong>：写一个计算器，实现加减乘除基本功能。</p><p><strong>如果使用面向过程的思想来写</strong>，即用计算机的方式去思考，就会写出如下代码：</p><h2 id="面向过程代码"><a href="#面向过程代码" class="headerlink" title="面向过程代码"></a>面向过程代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                result = numA + numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                result = numA - numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                result = numA * numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result = numA / numB;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span> + numA + symbol + numB + <span class="hljs-string">&quot;=&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这样写，是可以满足需求，但是一旦需求发生改变，增加一个开根号功能，理论上你只需要在switch语句中增加一条，但是这样去写，会让加减乘除功能都来参与编译，万一你手贱，改动了别的功能呢？这就是面向过程所带来的一些弊端。</strong></p><p>举个例子：</p><blockquote><p>一个公司将所有员工的工资算法都放在了一起(就像上面计算器，将所有运算功能放在了一起)，哪天老板让你修改别人的工资，你一看自己工资比较低，还偷偷修改了自己工资的算法。</p><p>所以说这样的代码很危险，毕竟你无法保证每个人都不出错。</p></blockquote><p><strong>所以这时就要用到面向对象的编程思想了。</strong></p><h1 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h1><p>众所周知，面向对象有三大特性：封装，继承、多态。</p><p>我们可以先利用，<strong>封装。</strong></p><p><strong>先将整个程序分成两部分，一个是处理计算的，另一个是处理用户的输入。</strong></p><p>因此我们可以定义两个类，一个是用户类，即处理用户输入，另一个是计算类，用来计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Calculate.GetResult(numA, symbol, numB);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetResult</span><span class="hljs-params">(<span class="hljs-type">int</span> numA, <span class="hljs-type">char</span> symbol, <span class="hljs-type">int</span> numB)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                result = numA + numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                result = numA - numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                result = numA * numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result = numA / numB;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时还是解决不了会改动别的运算中的代码，因此我们还需要用到继承和多态</p><p><strong>我们将每个运算中相同的部分取出，即都需要两个操作数，和一个计算方法。而运算符号是特有的，我们稍后再处理</strong></p><p><strong>所以可以定一个一个父类，包含这些属性和行为。再运用重写，重写各自的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numA;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numB;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumA</span><span class="hljs-params">(<span class="hljs-type">int</span> numA)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numA = numA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumB</span><span class="hljs-params">(<span class="hljs-type">int</span> numB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numB = numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA + numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA - numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA * numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivOperation</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> numA / numB;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>这样来设计的话，当我要让你修改某一个功能的时候，我只需要把这个类给你，而不需要你再给你其他类，这样大大的降低了出错的可能性。</strong></p><p>代码写到这，还不能运行，因为还有符号部分没处理，不过我们可以通过去实例化对象，来处理运行相应的功能。即使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125;<br>        System.out.println(ret);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时代码看起来，<strong>有好多地方都是重复的，很臃肿</strong>，所以，此时我们可是使用<strong>”简单工厂模式</strong>“来帮我们解决。</p><h1 id="三、简单工厂模式"><a href="#三、简单工厂模式" class="headerlink" title="三、简单工厂模式"></a>三、简单工厂模式</h1><p><strong>简单工厂模式，就是通过创建一个类，来帮助你实例化对象，也就是你要实例化谁，直接通过这个“工厂”来创建。</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(<span class="hljs-type">char</span> symbol)</span>&#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在我们要进行加法运算就可以这样写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> OperationFactory.createOperation(symbol);<br>        op.setNumA(numA);<br>        op.setNumB(numB);<br>        ret = op.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样修改以后，就非常简洁了，使用的时候，直接调函数就行了，<strong>而且未来扩展功能的时候，只需要添加一个类，再在工厂类里的switch添加一下就行了。</strong></p><p>这才是面向对象的代码嘛~</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numA;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numB;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumA</span><span class="hljs-params">(<span class="hljs-type">int</span> numA)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numA = numA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumB</span><span class="hljs-params">(<span class="hljs-type">int</span> numB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numB = numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA + numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA - numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA * numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivOperation</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> numA / numB;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(<span class="hljs-type">char</span> symbol)</span>&#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//        if(symbol == &#x27;+&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new AddOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125;else if(symbol == &#x27;-&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new MinOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125; else if(symbol == &#x27;*&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new MulOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125; else if(symbol == &#x27;/&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new DivOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(ret);</span><br><br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> OperationFactory.createOperation(symbol);<br>        op.setNumA(numA);<br>        op.setNumB(numB);<br>        ret = op.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4_18深夜思考</title>
    <link href="/2023/04/19/4-18%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/"/>
    <url>/2023/04/19/4-18%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、为什么选择敲代码</h1><p>因为高考很糟糕，然后稀里糊涂的填了几个志愿，结果莫名其妙的来到了计科专业。不过，在我初中的时候，我也曾想过当一名程序员，可能那时候喜欢游戏吧~ 而到了高中呢，太过压抑，而且我对其他的专业也不懂，在学校只能看见老师，正巧我在b站上看到一个叫国家玮的老师，他讲课的风格颠覆了我对老师的印象，我想成为向他一样的老师，但是最终考的并不如意，或许冥冥之中自由安排…</p><h1>二、为什么选择java而不选择C++</h1><p>我现在(大二下)感觉这个问题其实很奇怪，我觉得大部分都被互联网搞的太焦虑了，大家都不看好java，觉得学java毕业就找不到工作了。我感觉，<strong>首先</strong>找工作不是一门简单的事情，哪有毕业就一定能找到的呢，而且大家都追求好公司，据说不是找不到，是找不到心仪的，有点高不成低不就的感觉；<strong>其次</strong>，难道学C++就一定能找到工作吗？一门语言而已，c++和java不都是擅长做后端开发吗？<strong>最后</strong>，在学c++的时候，我感受到的是语法的复杂，而学习java的时候，我感受到了面向对象的编程方式，还挺好玩，于是我选择了java。</p><p><strong>个人看法</strong>：其实选哪个都差不多，不过对于考研啥的，还是选C++好一点，毕竟考研书啥的资料大部分都是C++的。</p><h1>三、为什么骑行</h1><p>因为在b站上看到了一个博主，骑行了西藏，于是，我想我是否能试试骑行桂林呢？目前已经把桂林骑得差不多了，下个目标可能是柳州了？可能骑行会很累，但我不后悔，这是我自己选择的路~</p><h1>四、最后</h1><p>无论结果如何，我相信，人生没有那条路是白走的，可能会走错了路，但是你看到了别人看不到的风景，路上结识了一辈子的知己，收获了温暖的回忆和宝贵的经历。</p><p>也许，我现在所做的一切，看不到任何成果，但是水滴石穿，绳锯木断，不要迷茫，不要彷徨，我不是没有成长，而是在扎根，在打基础，所有的付出，都会有回报的。</p><p>也许，多年以后，当和家人、朋友坐在一起唠嗑时，打开自己尘封的记忆，那一幕幕，跳出来，依旧鲜活而富有生命力。这些美好的记忆不会随着年华的飘零而逝去，而是会被镌刻在岁月里，最美好的地方。</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数据类型|运算符(与C对比)</title>
    <link href="/2023/04/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%8EC%E5%AF%B9%E6%AF%94/"/>
    <url>/2023/04/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%8EC%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、Java中的数据类型</h1><h2 id="0x01-基本数据类型">0x01 基本数据类型</h2><p>在 Java 中数据类型主要分为两类：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p>基本数据类型有4类：<strong>整形、浮点型、字符型、布尔型</strong>。细分为8种。如下：</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1 字节</td><td>-128 ~ 127</td></tr><tr><td>短整型</td><td>short</td><td>2 字节</td><td>-32768 ~ 32767</td></tr><tr><td>整型</td><td>int</td><td>4 字节</td><td>-2^31 ~ 2^31 - 1</td></tr><tr><td>长整型</td><td>long</td><td>8 字节</td><td>-2^63 ~ 2^63 - 1</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4 字节</td><td>有范围，一般不关注</td></tr><tr><td>双精度浮点数</td><td>double</td><td>8 字节</td><td>有范围，一般不关注</td></tr><tr><td>字符型</td><td>char</td><td>2 字节</td><td>0 ~ 65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>没有明确规定</td><td>true 和 false</td></tr></tbody></table><p><strong>值得注意的是</strong>：这里数据的类型大小和C语言不同的是，<strong>不论是在16位系统还是32位系统下</strong>，都是上述的大小。</p><p><strong>字符型</strong>在这里成了<strong>无符号的数</strong>了，<strong>还扩大成了2个字节</strong>。</p><p><strong>在C语言中，我们知道0表示假，非0表示真，然而在 Java中是使用boolean类型来表示真假，并且boolean类型不能与int类型转化</strong>，因此代码就不能写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-comment">//本意是想循环10次，但java中的boolean不能与int转化。</span><br>&#125;<br><br><span class="hljs-comment">//只能这样写</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>因此， Java 程序员不会遇到下述麻烦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(x = <span class="hljs-number">0</span>) <span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure><h2 id="0x02-类型转换">0x02 类型转换</h2><p>Java 是一个强类型编程语言。<strong>当不同类型之间的变量相互赋值的时候</strong>, 会有教严格的校验</p><p>例如：<strong>当我们将一个高精度的数赋值给低精度的数，由于会发生截断，编译器认为不安全，会报错。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.0</span>;<br>a = d; <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><p>如果是将一个低精度赋值给高精度的数，会进行类型转换。</p><p>类型转换又分为两种：<strong>自动(隐式)类型转换</strong>、<strong>强制(显示)类型转换</strong>。</p><hr><p><strong>自动类型转换</strong></p><p><strong>代码不需要经过任何处理，在代码编译时，编译器会自动进行处理</strong>。特点：<strong>数据范围小的转为数<br>据范围大的时会自动进行</strong>  。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>l = n; <span class="hljs-comment">//发生自动类型转换</span><br></code></pre></td></tr></table></figure><p>自动类型转换路线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>-&gt;<span class="hljs-type">short</span>-&gt;<span class="hljs-type">int</span>-&gt;<span class="hljs-type">long</span>-&gt;<span class="hljs-type">float</span>-&gt;<span class="hljs-type">double</span><br><span class="hljs-type">char</span>-&gt;<span class="hljs-type">int</span>-&gt;<span class="hljs-type">long</span>-&gt;<span class="hljs-type">float</span>-&gt;<span class="hljs-type">double</span><br></code></pre></td></tr></table></figure><p>可以将左边类型的变量赋值给右边类型的变量。</p><p><strong>强制类型转换：</strong></p><p>当进行操作时，代码需要经过一定的格式处理，不能自动完成。特点：数据范围大的到数据范围小的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>n = (<span class="hljs-type">int</span>)l; <span class="hljs-comment">//强制类型转换。告诉编译器我对此次类型转换负责！</span><br></code></pre></td></tr></table></figure><p>但是对于byte、short、char类型有些特别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>理论上这些操作，编译器不能通过，但是有这样的一个规则：</p><p><strong>当把具体数赋值给byte、short、char时，会先判断该数是否在这个类型的范围内，如果在就可以.</strong></p><p>这里的<strong>具体数值指的是字面常量：不能是变量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//可以</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">//byte b2 = a //不可以</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//short s1 = b1 + s; //不可以  </span><br></code></pre></td></tr></table></figure><h2 id="0x03-类型提升">0x03 类型提升</h2><p>不同类型的数据之间相互运算时，数据类型小的会被提升到数据类型大的。</p><ol><li><strong>int</strong>与<strong>long</strong>之间：<strong>int</strong>会被提升为<strong>long</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 编译出错: a + b==&gt;int + long--&gt; long + long 赋值给int时会丢失数据</span><br><span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 编译成功：a + b==&gt;int + long---&gt;long + long 赋值给long</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>byte</strong>与<strong>byte</strong>的运算</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>System.out.println(c);<br><span class="hljs-comment">// 编译报错</span><br>Test.java:<span class="hljs-number">5</span>: 错误: 不兼容的类型: 从<span class="hljs-type">int</span>转换到<span class="hljs-type">byte</span>可能会有损失<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br></code></pre></td></tr></table></figure><p>原因：由于计算机的 CPU 通常是按照 4 个字节为单位从内存中读写数据. <strong>为了硬件上实现方便, 诸如 byte 和 short这种低于 4 个字节的类型, 会先提升成 int</strong>, 再参与计算</p><p>因此要想编译通过，需要进行强制类型转换。</p><h1>二、运算符</h1><p>Java中运算符可分为以下：算术运算符(+ - */)、关系运算符(&lt; &gt; ==)、逻辑运算符、位运算符、移位运算符以及条件运算符等 。</p><p><strong>C语言中只能对整数取模</strong>，<strong>但在 Java 中 % 不仅可以对整型取模，也可以对double类型取模</strong>，但是没有意义，一般都是对整型取模的 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">11.5</span> % <span class="hljs-number">2.0</span>);<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><p><strong>对于++和–：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>b = b + <span class="hljs-number">1</span>; <span class="hljs-comment">//报错</span><br>b++; <span class="hljs-comment">//可以 会优化为 b = (byte)(b + 1)</span><br></code></pre></td></tr></table></figure><p><strong>对于 &amp;&amp;</strong> , 如果<strong>左侧表达式值为</strong> <strong>false,</strong> <strong>则表达式结果一定是</strong> <strong>false,</strong> <strong>无需计算右侧表达式</strong>.</p><p><strong>对于 ||</strong>, 如果<strong>左侧表达式值为</strong> <strong>true,</strong> <strong>则表达式结果一定是</strong> <strong>true,</strong> <strong>无需计算右侧表达式</strong>.</p><p><strong>&amp; 和 |</strong> ，如果表达式结果为 boolean 时, 也表示逻辑运算. 但与 &amp;&amp; || 相比, 它们不支持短路求值 ，因此他会对两边的表达式对进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">10</span> &gt; <span class="hljs-number">20</span> &amp; <span class="hljs-number">10</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// 程序抛出异常</span><br>System.out.println(<span class="hljs-number">10</span> &lt; <span class="hljs-number">20</span> | <span class="hljs-number">10</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// 程序抛出异常</span><br></code></pre></td></tr></table></figure><p><strong>对于移位操作符，与C语言不同的是，还有无符号右移&gt;&gt;&gt;</strong></p><p>无符号右移 &gt;&gt;&gt;: <strong>最右侧位不要了, 最左侧补 0</strong></p><p>即不会关注一个数的二进制中的符号是啥，直接补0，所以一个负数将会变成很大的正数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识java|Java的发展史|环境变量|JDK</title>
    <link href="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/"/>
    <url>/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文将讲述什么是Java、Java的发展史、比较一下C&#x2F;C++和Java的区别、环境变量的作用以及JDK是什么。</p></blockquote><h1 id="一、认识Java"><a href="#一、认识Java" class="headerlink" title="一、认识Java"></a>一、认识Java</h1><h2 id="0x01-Java是什么"><a href="#0x01-Java是什么" class="headerlink" title="0x01 Java是什么"></a>0x01 Java是什么</h2><p>Java是一门优秀的<strong>程序设计语言</strong>，它具有令人赏心悦目的语法和易于理解的语义  。</p><p>Java凭借着<strong>友好的语法</strong>、<strong>面向对象</strong>、<strong>内存管理</strong>和<strong>最棒的跨平台可移植性</strong>来吸引程序员。</p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410201938465.png" class><p>（Java之父——詹姆斯·高斯林)</p><p>Java有这样一句口号：“Write once，run anywhere” 即 <strong>一次编译，到处运行</strong>。指的是你可以写一个Java程序，然后能够在你朋友所拥有的的任何设备上执行。</p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410202641113.png" class title="image-20230410202641113"><h2 id="0x02-Java发展史"><a href="#0x02-Java发展史" class="headerlink" title="0x02 Java发展史"></a>0x02 Java发展史</h2><blockquote><p>Java 语言源于 1991 年 4 月，Sun 公司 <strong>James Gosling</strong>博士 领导的绿色计划(Green Project) 开始启动，此计划最初的目标是开发一种能够在各种消费性电子产品(如机顶盒、冰箱、收音机等)上运行的程序架构。这个就是Java的前身： Oak (得名与Java创始人James Gosling办公室外的一棵橡树)，但由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着<strong>1995</strong>年代互联网的发展<strong>，Sun公司看见</strong>Oak<strong>在互联网上应用的前景，于是改造了</strong>Oak<strong>，于</strong>1995<strong>年</strong>5<strong>月以</strong>Java<strong>的名称正式发布，并提出</strong>“Write once, Run anywhere” <strong>的口号</strong>。  </p></blockquote><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410203130293.png" class title="image-20230410203130293"><h2 id="0x03-Java-VS-C"><a href="#0x03-Java-VS-C" class="headerlink" title="0x03 Java VS C++"></a>0x03 Java VS C++</h2><h3 id="1、简单性"><a href="#1、简单性" class="headerlink" title="1、简单性"></a>1、简单性</h3><p>在Java中剔除了C++中许多很少使用、难以理解、易混淆的特性。可以这样理解：Java语法是C++语法的一个”纯净”版本。<strong>例如：Java中没有头文件、指针语法、结构体、联合体、运算符重载。</strong></p><h3 id="2、健壮性"><a href="#2、健壮性" class="headerlink" title="2、健壮性"></a>2、健壮性</h3><p>Java投入了大量的精力进行早期的问题检测以及后期的动态检测。<strong>Java采用的指针模型(底层)可以消除重写内存和损坏数据的可能性。例如：C++的拷贝构造，当对象销毁自动调用析构函数，可能由于前面是写的浅拷贝，而导致同一块空间释放了两次。</strong></p><h3 id="3、可移植性"><a href="#3、可移植性" class="headerlink" title="3、可移植性"></a><strong>3、可移植性</strong></h3><p>与C和C++不同的，Java规范中没有“依赖具体实现”的地方。<strong>基本教据类型的大小以及有关运算都做了明确的说明</strong>  </p><p>例如：<strong>Java 中的 int 永远为 32 位的整数</strong>  ，<strong>而在 C&#x2F;C++ 中</strong>， <u>int 可能是 16 位整数、 32 位整数</u>， 也可能是编译器提供商指定的其他大小 。唯一的限制只是 int 类型的大小不能低于 short int, 并且不能高于 long int。  </p><p>在 Java 中， 数据类型具有固定的大小， 这消除了代码移植时令人头痛的主要问题。 二进制数据以固定的格式进行存储和传输， 消除了字节顺序的困扰  。<strong>例如：在C&#x2F;C++中还存在大小端字节序存储的问题。</strong></p><h2 id="4、动态性"><a href="#4、动态性" class="headerlink" title="4、动态性"></a>4、动态性</h2><p>Java 与 C 或 C++ 相比更加具有动态性。 它能够适应不断发展的环境库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响。  一个很好的例子是： 从 Internet 下载代码，然后在浏览器上运行。 如果使用 C 或 C++, 这确实难度很大，不过 Java 设计者很清楚动态语言可以很容易地实现运行程序的演进。  </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>语言没有优劣之分，这个世界不是非黑即白的，每个语言都可能在某些领域表现出比其他语言更出色</strong>。比如：Objective C 和后来的 Swift 在 iOS 设备上就有着无可取代的地位， 浏览器中的处理几乎完全由 JavaScript 掌控。 Windows 程序通常都用 C++ 或 C# 编写 。Java 在服务器端编程和跨平台客户端应用领域则很有优势 。</p><p><strong>Java 的成功源于其类库能够让人们轻松地完成原本有一定难度的事情</strong>。 例如：联网Web 应用和并发。Java 减少了指针错误， 这是一个额外的好处， 因此使用 Java 编程的效率更高。但这些并不是 Java 成功的全部原因。  </p><h1 id="二、环境变量"><a href="#二、环境变量" class="headerlink" title="二、环境变量"></a>二、环境变量</h1><p>有很多人在装Java时，上网查资料会发现，都装完JDK都会让你去配置一下环境变量。</p><p><strong>那这是为什么呢？</strong></p><p>举个例子：当我运行游戏的时候，如果不是用快捷打开方式，那我们就需要去游戏安装的目录下找到exe文件打开，但是如果我们配置了环境变量，那我们可以随便打开一个命令窗口，输入指令，即可打开游戏。</p><p><strong>类比到编程：</strong></p><p>相当于在函数A中，创建了一个局部变量，在函数B中无法使用这个变量，但当我们配置了环境变量后，这个局部变量升级成全局变量了，现在在函数B中可以使用这个变量。</p><h1 id="三、JDK"><a href="#三、JDK" class="headerlink" title="三、JDK"></a>三、JDK</h1><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230411215831748.png" class title="image-20230411215831748"><h2 id="0x01-JDK"><a href="#0x01-JDK" class="headerlink" title="0x01 JDK"></a>0x01 JDK</h2><p>JDK全称 Java Development Kit， 即Java开发工具包，包含了Javac编译工具，java，JRE等工具。</p><p>JDK &#x3D; JRE + 开发工具集(javac, javap, java…….)</p><h2 id="0x02-JRE"><a href="#0x02-JRE" class="headerlink" title="0x02 JRE"></a>0x02 JRE</h2><p>JRE全称 Java Runtime Environment, 即Java运行时环境，包含了 JVM，Java基础类库。</p><p>JRE &#x3D; JVM + JavaSE标准类库</p><h2 id="0x03-JVM"><a href="#0x03-JVM" class="headerlink" title="0x03 JVM"></a>0x03 JVM</h2><p>JVM全称 Java Virtual Machine，即Java虚拟机， 用来运行Java代码。</p><p><strong>JDK 、JRE 、JVM关系图：</strong></p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410212254607.png" class title="image-20230410212254607"><hr><blockquote><p>参考资料：</p><p>《Java核心技术卷》</p><p>《Head First Java》</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言文件操作</title>
    <link href="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、文件的分类</h1><h2 id="1-1程序文件">1.1程序文件</h2><blockquote><p>例如：源程序文件 即 .c文件</p><p>​可执行程序 即 .exe文件</p><p>​…</p></blockquote><h2 id="1-2数据文件">1.2数据文件</h2><blockquote><p>例如：PPT、word文档、Excel表格…</p></blockquote><h1>二、文件的打开与关闭</h1><p>对于不使用文件相关操作的时候，数据的输入输出都是以<strong>终端</strong>为对象，即从终端的键盘输入数据，将<strong>内存中的运行结果</strong>输出到<strong>终端</strong>上。如下：</p><img src="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20230403202819947.png" class><p><strong>注意：输入输出都是站在内存的角度来看待的！</strong></p><hr><p>但是如果是对文件操作，同理。</p><p>如下：</p><img src="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20230403203212563.png" class><h2 id="2-1文件指针">2.1文件指针</h2><p><strong>每个被使用的文件</strong>都在<strong>内存</strong>中开辟了一个相应的<strong>文件信息区</strong>，用来存放，文件的名字，文件当前的位置等信息。</p><p>这些信息是<strong>保存在一个结构体变量</strong>中，该结构体类型是由系统声明的，取名<strong>FILE</strong></p><p><strong>例如：在VS2013编译环境下，就有如下申明：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> &#123;</span><br>    <span class="hljs-type">char</span> *_ptr;<br>    <span class="hljs-type">int</span> _cnt;<br>    <span class="hljs-type">char</span> *_base;<br>    <span class="hljs-type">int</span> _flag;<br>    <span class="hljs-type">int</span> _file;<br>    <span class="hljs-type">int</span> _charbuf;<br>    <span class="hljs-type">int</span> _bufsiz;<br>    <span class="hljs-type">char</span> *_tmpfname;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> <span class="hljs-title">FILE</span>;</span><br></code></pre></td></tr></table></figure><p>因此我们可以通过<strong>创建一个文件指针</strong>来对文件完成相应的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE* pf<span class="hljs-comment">//文件指针</span><br></code></pre></td></tr></table></figure><p><strong>ANSIC 规定使用fopen函数来打开文件，fclose来关闭文件</strong></p><p>举例：对一个文件进行写的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//打开文件，&quot;w&quot;表示是以写的方式打开文件。</span><br>FILE* pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <br>    <span class="hljs-comment">//关闭文件</span><br>    fclose(pf);<br>    pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打开文件方式有许多，如下：</strong></p><table><thead><tr><th>文件使用方式</th><th>含义</th><th>如果指定文件不存在</th></tr></thead><tbody><tr><td>“r”（只读）</td><td>为了输入数据，打开一个已经存在的文本文件</td><td>出错</td></tr><tr><td>“w”（只写）</td><td>为了输出数据，打开一个文本文件</td><td>建立一个新的文件</td></tr><tr><td>“a”（追加）</td><td>向文本文件尾添加数据</td><td>建立一个新的文件</td></tr><tr><td>“rb”（只读）</td><td>为了输入数据，打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb”（只写）</td><td>为了输出数据，打开一个二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab”（追加）</td><td>向一个二进制文件尾添加数据</td><td>出错</td></tr><tr><td>“r+”（读写）</td><td>为了读和写，打开一个文本文件</td><td>出错</td></tr><tr><td>“w+”（读写）</td><td>为了读和写，建议一个新的文件</td><td>建立一个新的文件</td></tr><tr><td>“a+”（读写）</td><td>打开一个文件，在文件尾进行读写</td><td>建立一个新的文件</td></tr><tr><td>“rb+”（读写）</td><td>为了读和写打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb+”（读写）</td><td>为了读和写，新建一个新的二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab+”（读写）</td><td>打开一个二进制文件，在文件尾进行读和写</td><td>建立一个新的文件</td></tr></tbody></table><p>因此，当我们要写一个文件，可以使用fopen函数，但打开也要关闭，可以使用fclose函数，最后再将指针置空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//打开文件</span><br>FILE* pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-comment">//确保打开成功</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//写文件</span><br><br><span class="hljs-comment">//关闭文件</span><br>fclose(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>三、文件的读写</h1><p>文件的读写可以使用如下函数：</p><table><thead><tr><th>字符输入函数</th><th>fgetc</th><th>所有输入流</th></tr></thead><tbody><tr><td>字符输出函数</td><td>fputc</td><td>所有输出流</td></tr><tr><td>文本行输入函数</td><td>fgets</td><td>所有输入流</td></tr><tr><td>文本行输出函数</td><td>fputs</td><td>所有输出流</td></tr><tr><td>格式化输入函数</td><td>fscanf</td><td>所有输入流</td></tr><tr><td>格式化输出函数</td><td>fprintf</td><td>所有输出流</td></tr><tr><td>二进制输入</td><td>fread</td><td>文件</td></tr><tr><td>二进制输出</td><td>fwrite</td><td>文件</td></tr></tbody></table><p><strong>这里对所有输入输出流说明：</strong></p><p><strong>流是一种抽象出来的概念，程序员只需要关注将数据输出到流中或者从流中获取数据，而不用关注流怎么跟文件、屏幕、网络、外部设备怎么进行交互。</strong></p><p>我们一般使用的流：</p><table><thead><tr><th>读写文件</th><th>文件流</th></tr></thead><tbody><tr><td><strong>在终端屏幕上打印输出</strong></td><td><strong>标准输出流-stdout</strong></td></tr><tr><td><strong>键盘上输入数据</strong></td><td><strong>标准输入流-stdin</strong></td></tr></tbody></table><p>因此上面的函数，还可以将数据输入输出到屏幕上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>fputc(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码也可以起到printf函数的作用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>筛质数</title>
    <link href="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
    <url>/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>质数的定义</h1><p>质数又称素数。质数是指在大于1的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394?fromModule=lemma_inlink">自然数</a>中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111?fromModule=lemma_inlink">因数</a>的自然数。</p><h1>1-N的质数</h1><p><strong>题目描述：</strong></p><blockquote><p>寻找1-N之间的所有质数。</p><p>将其输出出来。</p></blockquote><h2 id="方法一：朴素法">方法一：朴素法</h2><p><strong>思路：</strong></p><blockquote><p>根据定义，只要循环2 - X-1 的数，看其是否是X的因数，如果都不是，那这个数就是素数。</p><p>可以优化，即找2 - 根号x的数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//循环2- sqrt(x)的数，看是否为其因数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(x); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//输入</span><br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//由于素数是从2开始的</span><br>    <span class="hljs-comment">//循环2-N的数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果是素数，输出即可</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(i))<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然效率是不够的高的。每次都要找2-sqrt(x)的数来判断是否为因数。</p><p><strong>假设找1-10000内的数，则要循环117527次。</strong></p><h2 id="方法二：埃氏筛法">方法二：埃氏筛法</h2><p><strong>思路：</strong></p><blockquote><p>埃氏筛法是通过先找到素数，然后筛选不是这些素数倍数的数。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>2是素数，然后直接排除4、6、8、10…</p><p>3由于不是2的倍数，所以没有被筛选，此时小于3的所有数就都筛选过了，此时3就是素数了。然后通过3，直接排除6、9、12…</p><p>4由于被筛掉了，所以不用看了。</p><p>5不是2、3的倍数，此时小于5的所有数也都被筛选了，5也就是素数。然后再排除其倍数。</p></blockquote><img src="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/image-20230328215621016.png" class title="image-20230328215621016"><p><strong>不过这种做法也是有一点缺陷的，即6被筛选了两次.</strong></p><hr><p><strong>将原理运用：</strong></p><blockquote><p>首先创建一个大小为N+1的数组。里面存放能表示真或者假两种状态的标记。</p><p>初始化数组，假设全为真，表示所有数为素数。</p><p>要特判下标为0、1的，因为其不符合素数定义。</p><p>然后循环2-N的数，如果这个数为素数，则去找其倍数，修改为非素数。即1变0，真变假。</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//创建一个数组来表示0-N的数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Prime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    <br>    <span class="hljs-comment">//不符合定义</span><br>Prime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>Prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">//循环2-N的数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果是素数就筛选其倍速</span><br><span class="hljs-keyword">if</span> (Prime[i])<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= N; j += i)<br>&#123;<br>Prime[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>埃氏筛法可快多了，当要找1-10000内的数，只要31841次。</strong></p><h2 id="方法三：欧拉筛法">方法三：欧拉筛法</h2><p><strong>介绍：</strong></p><blockquote><p>欧拉筛法，也称线性筛，是在埃氏筛的基础上的优化，因为埃氏筛会某一个合数进行多少筛选。本质上是通过合数的最小的质因子筛掉数字。</p><p>大致流程：收集素数，然后遍历每一个数，让其乘上收集到的素数，然后筛选这个数。注意，因为是通过最小质因子筛选，如果当前数的因数有收集到的素数，需要终止。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>2是素数，此时素数列表中只有2，让其 *2，筛选掉4</p><p>3没被筛选，此时将其加入素数列表，列表内容为2、3,让3 * 2, 3 * 3，筛选掉6、9</p><p>4被筛选掉了，不同于埃氏筛法，依旧要进行操作，让其成上2，筛选掉8，<strong>然后直接结束4的操作</strong>！<strong>因为欧拉筛的原理是通过最小质因子筛选。2是4的因子，不符合规则。所以不进行 4 * 3的操作。</strong></p><p>5没被筛选，加入素数列表，列表内容为2、3、5，然其乘上这些素数。</p><p>6被筛选掉了，让其乘上2, 2 * 6 = 12，然后直接结束6的操作！</p><p>…</p><p>这样就能保证对每个数只筛选一次了。</p></blockquote><img src="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/image-20230328222516619.png" class title="image-20230328222516619"><p><strong>这种筛选法，对于一个数只会筛掉一次。</strong></p><p><strong>思路：</strong></p><blockquote><p>首先我们需要一个数组，标记这些数是否为质数。因为我们每个数都要乘以之前的所有素数，因此我们需要一个数组来记录素数。</p><p>如果是素数就加入数组。</p><p>对每个数进行乘上素数的操作，然后筛选数</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//判定是否为素数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;<br>isPrime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//储存素数的数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Prime;<br>    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果为素数就加入数组</span><br><span class="hljs-keyword">if</span> (isPrime[i])<br>Prime.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-comment">//乘以素数进行筛选，需要注意是否会越界</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; Prime.<span class="hljs-built_in">size</span>() &amp;&amp; i * Prime[j] &lt;= N; j++)<br>&#123;<br>isPrime[i * Prime[j]] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (i % Prime[j] == <span class="hljs-number">0</span>) <span class="hljs-comment">//最关键的一步！因为欧拉筛的本质是通过最小质因子来筛的</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : Prime)<br>cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>欧拉筛是一种非常高效的算法，如果是找10000内的质数，只需要循环8770次，比埃氏还要快的多。</strong></p><p><strong>对比：</strong></p><table><thead><tr><th>方法：</th><th>1-10000的数</th></tr></thead><tbody><tr><td><strong>朴素筛法</strong></td><td>117527</td></tr><tr><td><strong>埃氏筛</strong></td><td>31841</td></tr><tr><td><strong>欧拉筛(线性筛)</strong></td><td>8770</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>案例引入：</h1><blockquote><p>有一个猜数字的游戏，即我讲选中1-100以内的某一个数，然后你来猜测，如果你猜的数比我选的数大，我会告诉你大了，反之亦然。</p></blockquote><p><strong>其实这个游戏就运用到了二分法/折半查找的思路。即每次筛选都排除掉一半的错误。</strong></p><p>二分查找是一个非常厉害的算法，它的<strong>时间复杂度在对数阶</strong>。</p><hr><h1>例题一：找个数</h1><h2 id="题目描述："><strong>题目描述：</strong></h2><blockquote><p>运用二分法的思想，寻找一个有序数组中的一个数的下标。这个数必定存在，数组中不存在重复元素项。</p></blockquote><h2 id="输入："><strong>输入</strong>：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span>&#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br></code></pre></td></tr></table></figure><h2 id="输出："><strong>输出：</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="思路："><strong>思路：</strong></h2><blockquote><p>定义一个左边界，定义一个右边界</p><p>然后每次比较区间中间的数和目标值</p><p>修改区间，就能删除一半的元素。</p></blockquote><h2 id="代码："><strong>代码：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = size - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//二分查找的细节</span><br><span class="hljs-keyword">while</span> (left &lt;= right) <span class="hljs-comment">//这里是小于等于呢？还是小于？ 这里先采用小于等于的写法，本质是取左闭右闭区间，[left, right]</span><br>&#123;<br>        <br><span class="hljs-comment">//计算中间的那个元素的下标</span><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//如果要找的数小于中间的那个数</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br><span class="hljs-comment">//怎么修改边界与上面的终止条件有关</span><br>right = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果找到了就直接返回这个元素的下标</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br><br><span class="hljs-comment">//计算数组中元素个数</span><br><span class="hljs-type">int</span> size = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br><span class="hljs-type">int</span> index = BinarySearch(arr, target, size);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了，这个数在数组中的下标为：%d&quot;</span>, index);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="细节："><strong>细节：</strong></h2><blockquote><p>如果自己去写，很有可能写错，因为根据你<strong>所选取的区间不同</strong>，就会有<strong>其他几种写法</strong>。</p><p>例如 : 假设选取[left, right)区间，即左闭右开区间(上面选取了左闭右闭区间)</p></blockquote><h2 id="代码如下："><strong>代码如下：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-type">int</span> right = size;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">while</span> (left &lt; right)<br>&#123;<br><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br>right = mid;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意："><strong>注意：</strong></h2><blockquote><p>我们要<strong>始终满足我们选取二分区间的定义</strong>，即左边界能不能取得到？右边界能不能取得到？</p><p>如果能取得到，那么修改的时候就要注意了。</p><p>很多人由于不注意细节，加上测试的数据不够多，很容易误以为自己写对了二分查找。</p></blockquote><h1>例题二：搜索插入位置</h1><h2 id="题目描述：-2"><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>提示:</p><p>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 为 <strong>无重复元素</strong> 的 升序 排列数组<br>-104 &lt;= target &lt;= 104</p></blockquote><h2 id="示例：">示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">2</span><br>    <br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">1</span><br>    <br>示例 <span class="hljs-number">3</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">7</span><br>输出: <span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><h2 id="思路：-2">思路：</h2><blockquote><p>读题，满足了二分法的条件，即数组有序。还告诉了请务必使用复杂度为O(log n) 的算法。</p><p>下面考虑两种情况：</p><p>1、如果数组中有这个元素，那么直接返回这个元素的下标即可。</p><p>2、如果数组中没有这个元素呢？我们通过一个叫做&quot;循环不变量的东西&quot;(下面会讲),可以得出最后所求的位置一定在left/right + 1上。</p></blockquote><h2 id="代码：-2">代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = target - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right -left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[mid])<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//或者right + 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>二分查找中的循环不变量：</h1><p><strong>所谓的循环不变量，其实就是二分的过程中会发现，left左边的数全部小于目标值，而right的右边全部大于目标值。</strong></p><h2 id="举例：">举例：</h2><p><strong>假设现在要插入一个47，那么肯定得在下标为4的位置插入。</strong></p><table><thead><tr><th>left</th><th></th><th></th><th>mid</th><th></th><th></th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left</th><th>mid</th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left、right、mid</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th>right</th><th>left</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><p><strong>所以返回left 或者 right+1</strong>。<strong>因为left左边都是小于目标值的，那么就应该插入在比目标值小的序列的后面。因为right右边都是大于目标值的，那么就应该插入在比目标值大的序列的前面。</strong>（以上都是对于没有重复项的序列）</p><hr><h1>例题三：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h1><h2 id="题目描述：-3"><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p>提示：</p><p>0 &lt;= nums.length &lt;= 105<br>-109 &lt;= nums[i] &lt;= 109<br>nums 是一个非递减数组<br>-109 &lt;= target &lt;= 109</p></blockquote><h2 id="示例：-2">示例：</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br>示例 3：<br>输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="思路：-3">思路：</h2><blockquote><p>注意：</p><p>此题给的有序序列是<strong>有重复项</strong>的，因此当我们的中间值等于目标值了，我们<strong>先不急着返回</strong>，因此循环中只有两个选择了，等于的情况可以<strong>合并</strong>到别的情况中去。</p><p>现假设合并到中间值大于目标值。</p><p>由于循环不变量的原理，<strong>left左边的数一定是小于目标值，right右边的数一定是大于等于目标值，那么元素的第一个出现的位置一定是在left或者right + 1的位置。</strong></p><p><strong>那么元素最后一个出现的位置呢？只要我们查找比目标值大1的元素的位置然后减1就行了。</strong></p></blockquote><h2 id="特殊情况的考虑：">特殊情况的考虑：</h2><blockquote><p>如果没有出现过目标值呢？依旧会返回一个值，但是这个值是 目标值插入这个位置后依旧是有序的时候的位置。因此判断一下这个位置上的数是否为目标值，就可以知道有没有出现过了。</p><p>如果序列中所有值都小于目标值呢？二分会返回一个我们不可访问的地方。需要判断处理。</p></blockquote><hr><h2 id="代码：-3">代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//用来寻找第一次出现的边界</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m_low_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        ans[<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-built_in">m_low_bound</span>(nums, target);<br>       <span class="hljs-comment">//需要注意的地方！</span><br>        <span class="hljs-keyword">if</span>(start &gt;= nums.<span class="hljs-built_in">size</span>() || target != nums[start])<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//记得减1</span><br>        <span class="hljs-type">int</span> end = <span class="hljs-built_in">m_low_bound</span>(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>        ans[<span class="hljs-number">0</span>] = start;<br>        ans[<span class="hljs-number">1</span>] = end;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1>拓展：lower_bound</h1><img src="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20230328211735342.png" class title="image-20230328211627216"><p>C++的库函数中有一个叫lower_bound()的函数。</p><p><strong>函数的功能：</strong></p><blockquote><p>1、如果数组中存在目标值，则返回第一个是目标值的下标。</p><p>2、如果数组中不存在，则返回这个数应该出现的位置。</p></blockquote><p><strong>使用如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos1 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos2 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos3 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;1 出现的位置：&quot;</span> &lt;&lt; pos1 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2 出现的位置：&quot;</span> &lt;&lt; pos2 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出3</span><br>cout &lt;&lt; <span class="hljs-string">&quot;3 出现的位置：&quot;</span> &lt;&lt; pos3 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出4</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷宫</title>
    <link href="/2023/03/27/%E8%BF%B7%E5%AE%AB/"/>
    <url>/2023/03/27/%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、迷宫问题</h1><h2 id="题目描述："><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc">https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc</a><br>来源：牛客网</p><p>定义一个二维数组 N*M ，如 5 × 5 数组下所示：</p><p>int maze[5][5]= {<br>0, 1, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 1, 0,<br>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。</p><p>数据范围： 2 &lt;= n,m &lt;= 10,  输入的内容只包含 0 &lt;= val &lt;= 1</p></blockquote><h2 id="输入描述："><strong>输入描述：</strong></h2><blockquote><p>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p></blockquote><h2 id="输出描述"><strong>输出描述:</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">左上角到右下角的最短路径，格式如样例所示。<br></code></pre></td></tr></table></figure><p><strong>示例1</strong></p><h2 id="输入">输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="输出">输出</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="求解：">求解：</h2><p><strong>第一步：</strong></p><blockquote><p>首先我们先把简单的输入做好，然后再专心写怎么去找。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步：</strong></p><blockquote><p>因为深度优先搜索(DFS)非常适用于找是否有解的题，正巧题目说了有且仅有一条通路，所以非常契合。</p><p>那DFS怎么实现呢？用栈这种数据结构呢？还是用递归——函数调用创建栈帧？ 为了精简就用递归吧。</p><p><strong>递归三要素：</strong></p><p>1、确定递归函数的参数和返回值</p><p>2、确定终止条件</p><p>3、确定单层递归逻辑</p></blockquote><p><strong>1、确定递归函数的参数和返回值</strong></p><p>首先我们肯定要<strong>传入这个二维矩阵</strong>，其次我们还要<strong>传入迷宫起点坐标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">DFS</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br></code></pre></td></tr></table></figure><blockquote><p>那要不要传迷宫的长宽呢？因为我们用了vector容器，可以通过调用接口函数，直接得出，因此不用</p></blockquote><p>最后我们确定返回值，因为我们<strong>只要求是否有解</strong>，<strong>如果有的话直接返回true, 没有的话返回false不就行啦，所以返回值定位bool</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>2、确定终止条件</strong></p><p>显然<strong>走到出口就停止</strong>呗。即坐标(N - 1, M - 1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>3、确定单层递归逻辑</strong></p><p>首先我们在迷宫中不知道哪里能走，因此只能“摸黑走”，随便走，但<strong>总要规定一个顺序</strong>，我们这里<strong>假设就用上下左右</strong>的顺序去“走迷宫”。</p><p>但是，我们总不能是墙也走吧，或者走出迷宫边界，因此我们还要<strong>判定是否能向那一个方向走。</strong></p><p>写一个函数用来判断能不能走isPass</p><p><strong>首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳。</span><br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>    <br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>至此，我们整个递归的逻辑已经写完了。但是这道题需要让你输出从起点到终点的路径坐标。</p><p>如果我们走到一个死胡同，此时我们记录了这个死胡同的所有坐标，这不是我们想要的，因此我们要删除这些坐标。仔细思考，会发现，我们<strong>所需要删除的是所有后面来的坐标</strong>，这不就是<strong>后进先出</strong>嘛，所以我们就想到了用栈来记录。</p><p>因为<strong>坐标是两个整形的组合</strong>，类似一个结构体，我们可以<strong>用pair来记录坐标</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br></code></pre></td></tr></table></figure><p>至此，我们能记录出所有坐标辣，但是<strong>坐标顺序是反的</strong>。<strong>因此还要借助一个栈来辅助逆置</strong>。最后输出这个辅助栈就ok了</p><h2 id="最终代码：">最终代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, y));<br><br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">//归的过程</span><br><span class="hljs-comment">//因为走不通，返回false，并且要输出错误路的坐标</span><br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>(maze, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; help_st;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>help_st.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">while</span> (!help_st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>help_st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二届程序设计大赛</title>
    <link href="/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"/>
    <url>/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-闰年"><strong>1.闰年</strong></h2><p>问题描述</p><p>给定一个年份，判断这一年是不是闰年。当以下情况之一满足时，这一年是闰年：</p><ol><li>年份是4的倍数而不是100的倍数；</li><li>年份是400的倍数。<br>其他的年份都不是闰年。</li></ol><p><strong>输入格式</strong><br>输入包含一个整数y，表示当前的年份。</p><p><strong>输出格式</strong><br>输出一行，如果给定的年份是闰年，则输出yes，否则输出no。</p><p>说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。</p><p><strong>思路：</strong></p><p>按照题目描述输出即可。<strong><u>四年一润且百年不润 或 四百年一润</u></strong></p><p>因此可以得出这样的表达式：</p><p><strong>(year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)</strong></p><p>之后结合if语句判断即可~</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;year);<br>    <br>    <span class="hljs-comment">//如果表达式为真，则执行输出yes</span><br>    <span class="hljs-keyword">if</span>((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-找素数"><strong>2.找素数</strong></h2><p>输入一个正整数n，计算输出小于n的最大素数</p><p><strong>思路：</strong></p><p>抓住核心：<strong>小于n，最大，素数</strong></p><p><u><strong>1.分析素数：大于1，只能被1和自身整除</strong></u></p><p><u><strong>2.循环找出大于1，小于n的数</strong></u></p><p><u><strong>3.检查循环所枚举出来的数是否为素数</strong></u></p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//检查它是不是素数,如果是则返回1，不是返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br><span class="hljs-comment">//循环2 - num-1 之间的数，看是否能被num整除，能整除则说明不是</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= num - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (num % j == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br><span class="hljs-comment">//先得到小于n的数</span><br><br><span class="hljs-comment">//因为要最大，所以从后往前找</span><br><span class="hljs-comment">//但是因为要得到素数，而最小的素数是2，所以循环到2就行</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">2</span>; i--)<br>&#123;<br><span class="hljs-comment">//判断是否为素数</span><br><span class="hljs-keyword">if</span> (is_Prime(i) == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//如果当前数为素数，则一定是小于n的最大素数了</span><br>            <span class="hljs-comment">//中止循环即可~</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-爬楼梯"><strong>6.爬楼梯</strong></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><p>由于<strong>每次只能爬一个台阶或者两个台阶</strong>，因此<strong>第n阶台阶只能由第n-1阶台阶和n-2阶台阶到达</strong>。</p><p>所以我们<strong>只要知道</strong>了爬到n-1阶台阶有多少中走法和n-2阶台阶有多少种走法，<strong>就能得到</strong>爬到n阶台阶有多少种走法。</p><p>现用函数的形式表示n阶台阶的不同方法数：</p><p>f(n) = f(n - 1) + f(n - 2)。</p><p>f(n - 1) = f(n - 1 - 1) +f(n - 1 - 2)</p><p>f(n - 2) = f(n - 2 - 1) + f(n - 2 - 2)</p><p>…</p><p>我们会发现，每次操作都差不多，因此我们可以用<strong>递归解决问题</strong>(循环当然也可以)。</p><p>但有<strong>两个特例</strong>：</p><p>f(1) = 1</p><p>f(2) = 2</p><p>因为用上面的公式不符合，哪有走0阶台阶的- -</p><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> fun(n - <span class="hljs-number">1</span>) + fun(n - <span class="hljs-number">2</span>);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, fun(n));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-逆序对"><strong>7.逆序对</strong></h2><p><code>逆序对</code></p><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。<br>如 <code>2 4 3 1 </code>中，<code> 2 1</code> ，<code>4 3</code> ，<code>4 1</code>，<code>3 1</code>是逆序，逆序数是 4 。给出一个整数序列，求该序列的逆序数。</p><p><strong>输入</strong></p><p>第 1 行： $N$ ， $N$为序列的长度（ $N≤10000$ ）<br>第 2∼N+1 行：序列中的元素（$ 1≤A[i]≤10000 $）</p><p><strong>输出</strong></p><p>输出逆序数</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>2<br>4<br>3<br>1<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>抓住最重要的，<strong>前面的数大于后面的数</strong>！</p><p>所以只要<strong>两个循环</strong>就可以解决了！</p><p><strong>外循环</strong>：固定当前等待比较的数</p><p><strong>内循环</strong>：去当前等待比较的数后面寻找有没有它还大的数</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <br>    <span class="hljs-comment">//创建数组存放这些数</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">100001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//读取这些数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">//用来计数</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//外循环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//内循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; Nl j++)<br>        &#123;<br>            <span class="hljs-comment">//开始判断,是否前面大于后面</span><br>            <span class="hljs-keyword">if</span>(arr[i] &gt; arr[j])<br>        count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-宫殿距离">9.宫殿距离</h2><p><code>搜索</code></p><p>nxn的格子宫殿，包含一个起始点<code>#</code>，一个终止点<code>$</code>，其它点为<code>.</code></p><p><strong>输入</strong></p><p>第 1 行，一个数n，中间用空格隔开。 ($2≤n≤1000$)</p><p>第 2~n+1行，每行n个字符。</p><p><strong>输出</strong></p><p>输出起点到终点的最短距离，距离只能从一个方格通过上下左右的方式走到与之相邻的方格，每个方格代表的距离为1。</p><p>距离不包含起始位置，包含终止位置。</p><p><strong>输入样例</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5<br><span class="hljs-code">.....</span><br><span class="hljs-code">.#...</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">....$</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>别看这题在后面，其实装的，吓人的</p><p><strong>不就是计算两点之间的距离嘛，只是不能斜着走</strong></p><p>只要在读入迷宫的时候，记下#、$的位置就行了</p><p>C语言的难度对于本体在于如何读取这个迷宫，需要注意缓存区中的换行符。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//存放迷宫</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br><span class="hljs-comment">//用来记录#的位置</span><br><span class="hljs-type">int</span> s_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> s_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//用来记录$的位置</span><br><span class="hljs-type">int</span> e_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> e_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//读入迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;arr[i][j]);<br><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>&#123;<br>s_i = i;<br>s_j = j;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;$&#x27;</span>)<br>&#123;<br>e_i = i;<br>e_j = j;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br>&#125;<br><br><span class="hljs-comment">//abs函数是用来取绝对值的</span><br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">abs</span>(s_i - e_i) + <span class="hljs-built_in">abs</span>(s_j - e_j);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-数列求值"><strong>4.数列求值</strong></h2><p>给定数列1,1,1,3,5,9,17,…，从第4项开始，每项都是前3项的和。求第20190324项的最后4位数字。</p><p><strong>思路：</strong></p><p>斐波那契数列的改版：因此依葫芦画瓢，使用递归来写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> Fib(n - <span class="hljs-number">1</span>) + Fib(n - <span class="hljs-number">2</span>) + Fib(n - <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是因为递归的太深，所以需要求解的时间很长，因此在比赛中肯定是不能过得，因此我们要考虑用空间换时间。</p><hr><p>利用一个数组存储前n项的和，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>arr[n] = arr[n - <span class="hljs-number">1</span>] + arr[n - <span class="hljs-number">2</span>] + arr[n - <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p><strong>但是</strong>！对于这道题依旧行不通，<u><strong>因为他要让你存储第20190324个数，需要巨大的空间</strong></u>，在main函数中创建这个数组，程序会崩溃。但你可以**<u>将这个数组写在main函数外，写成全局变量数组。</u>**</p><p>**但是！**就算你开辟了这个很大的数组，你依旧过不了这题，因为当你傻乎乎的求解时，<em><strong>斐波那契数列的增长很快</strong></em>，不一会就会超出整形的范围，就会得到意想不到的数。不过这题给你了提示，<strong>让你求最后4位数，所以你每次只要关注当前数的后4位</strong>。</p><p>**补充：**要得到一个数的后i位，就要对这个数取模% 10 ^ i</p><h3 id="最终代码如下：">最终代码如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h2 id="3-泡泡世界"><strong>3.泡泡世界</strong></h2><p>小鱼儿吐泡泡，嘟嘟嘟冒出来。小鱼儿会吐出两种泡泡：大泡泡&quot;O&quot;，小泡泡&quot;o&quot;。 两个相邻的小泡泡会融成一个大泡泡,两个相邻的大泡泡会爆掉。</p><p><strong>输入</strong></p><p>一行仅有’O’与’o’组成的字符串。</p><p>保证字符串的长度不超过100。</p><p><strong>输出</strong></p><p>输出一行字符串代表小鱼儿吐出的泡泡经过融合以后所剩余的泡泡。</p><p>合并顺序为自左向右合并。</p><p><strong>输入样例</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ooOOoooO</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">oO</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><blockquote><p>通过观察，我们可以发现，我们只需要关注当前泡泡的最右边的一个泡泡是什么，然后进行操作，符合栈的性质，因此可以用栈来做。</p><p>因为C语言没有自带栈，所以就使用C++来解决.</p></blockquote><p><strong>最终代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str;<br>cin &gt;&gt; str;<br><br>stack&lt;<span class="hljs-type">char</span>&gt; st;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-comment">//如果此时栈里没泡泡</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>())<br>st.<span class="hljs-built_in">push</span>(str[i]);<br><span class="hljs-comment">//有泡泡</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//如果与栈顶的泡泡相等</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">top</span>() == str[i])<br>&#123;<br><span class="hljs-comment">//如果栈顶是和当前都是&#x27;o&#x27;,则还需要判断栈顶下一个元素是否是&#x27;O&#x27;，</span><br><span class="hljs-comment">//如果是需要继续删除，如果不是直接插入</span><br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;o&#x27;</span>)<br>&#123;<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;O&#x27;</span>)<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;O&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-comment">//如果不相等</span><br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">push</span>(str[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//由于栈中的元素顺序与答案是反着的，需要逆置一遍</span><br><span class="hljs-comment">//栈没有迭代器，只能手动逆置</span><br>stack&lt;<span class="hljs-type">char</span>&gt; helpSt;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>helpSt.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-comment">//输出答案</span><br><span class="hljs-keyword">while</span> (!helpSt.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; helpSt.<span class="hljs-built_in">top</span>();<br>helpSt.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-机器人走方格">8.机器人走方格</h2><p><code>dp</code> <code>组合数</code> <code>递推</code></p><p>m×n 的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？</p><p>由于方法数量可能很大，只需要输出 $mod(10^9+7)$的结果。</p><p><strong>输入</strong></p><p>第 1 行，两个数m,n，中间用空格隔开。 ($2≤m,n≤10^6$)</p><p><strong>输出</strong></p><p>输出走法的数量$mod (10^9+7)$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><blockquote><p>非常简单一道动态规划。</p><p>动态规划三部曲：</p><p>1、确定dp数组以及下标的含义。</p><p>dp数组表示的是到第(i,j)位置有多少种走法。</p><p>2、确定递推公式</p><p>因为只能向右和向下走，所以只能从两个方向上走过来，相加即可.</p><p>dp[i][j] = dp[i - 1][j ] + dp[i][j - 1]</p><p>3、dp数组如何初始化</p><p>第一行只能从左走到右，所以只有1种走法</p><p>第一列只能从上走到下，所以只有1中走法</p></blockquote><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><br><span class="hljs-comment">//dp数组表示的是到第(i, j)位置有多少种走法。</span><br><span class="hljs-comment">//直接全部初始化1，反正后面的会被覆盖</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)<br><span class="hljs-comment">//确定递推公式</span><br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br><br>cout &lt;&lt; dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] % (<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写到这里，能拿大部分的分数，但是由于题目故意将数据放大了，这样还是会超时。</p><p>所以看看能不能优化。</p><p>通过观察发现，其实就是组合数。</p><p>从左上到右下，一共要走m - 1 + n - 1步，因为只能走两个方向，所以从m+n-2步中任选m-1步往下走。</p><p>即：</p></blockquote><p><strong>最终代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = n, y = <span class="hljs-number">1</span>; y &lt; m; ++x, ++y) <br>    &#123;<br>        ans = ans * x / y;<br>    &#125;<br>    cout &lt;&lt; ans % (<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯模拟题</title>
    <link href="/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/"/>
    <url>/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第一题</h1><p><strong>问题描述</strong><br>　　请找到一个大于 2022 的最小数，这个数转换成十六进制之后，所有的数位（不含前导 0）都为字母（A 到 F）。<br>　　请将这个数的十进制形式作为答案提交。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><hr><p><strong>方法一：</strong></p><blockquote><p>2022 转十六进制 7E6</p><p>这是一道填空题，最笨的方法，拿着计算器一个一个数出来，看哪一个数最先为AAA。</p></blockquote><p><strong>方法二：</strong></p><blockquote><p>通过编程来找。</p><p><strong>思路</strong>：循环2022以后的数，看哪一个最先 转为十六进制后就全为字母</p><p>如何一个十进制数转为十六进制呢？</p><p>使用短除法~</p><p>如：2022 % 16 = 6， 2022 / 16 =  126</p><p>​126 % 16 = E(14),  126 / 16 = 7</p><p>​7 % 16 = 7,  7 / 16 = 0</p><p>最后将取模的数从下当上写出来， 所以 2022转为十六进制就为7E6了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Full</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-comment">//如果满足每一位都是字母那就返回1，否则返回0</span><br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//检查每一位是否为字母，如果为数字直接结束</span><br><span class="hljs-type">int</span> tmp = n % <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; <span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>n /= <span class="hljs-number">16</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2023</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (is_Full(n))<br>&#123;<br><span class="hljs-comment">//一旦找到某一个满足全是字母的数，直接结束</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>n++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第二题</h1><p><strong>问题描述</strong><br>　　在 Excel 中，列的名称使用英文字母的组合。前 26 列用一个字母，依次为 A 到 Z，接下来 26*26 列使用两个字母的组合，依次为 AA 到 ZZ。<br>　　请问第 2022 列的名称是什么？<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个由大写字母组成的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。</p><blockquote><p>介不就一道二十六进制的题。</p><p>满Z就进位A。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2022</span>;<br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//%c打印字符，即后面可以跟一个数字，然后会输出相应ASCII值的字符</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, n % <span class="hljs-number">26</span> + (<span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">1</span>));<br>n /= <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为TYB，需要将结果反过来即BYT，因为每次都是先得到个位再十位…</p><h1>第三题</h1><p><strong>问题描述</strong><br>　　对于一个日期，我们可以计算出年份的各个数位上的数字之和，也可以分别计算月和日的各位数字之和。请问从 1900 年 1 月 1 日至 9999 年 12 月 31 日，总共有多少天，年份的数位数字之和等于月的数位数字之和加日的数位数字之和。<br>　　例如，2022年11月13日满足要求，因为 2+0+2+2=(1+1)+(1+3) 。<br>　　请提交满足条件的日期的总数量。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>这题就老老实实的编程算了~不然得数到结束</p><p>技巧：我们可以创建一个月份数组，存入每个对应的天数</p><p>思路：枚举每个日期，看是否满足咯，记得要判断是否为闰年</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_LeapYear</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//得到每位之和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (year)<br>&#123;<br>ans += year % <span class="hljs-number">10</span>;<br>year /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> month[<span class="hljs-number">13</span>] = &#123; <span class="hljs-number">0</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<br><span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br><span class="hljs-comment">//用来计数，得到结果</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1900</span>; i &lt;= <span class="hljs-number">9999</span>; i++)<br>&#123;<br><span class="hljs-comment">//先判断这年是不是闰年</span><br>month[<span class="hljs-number">2</span>] = is_LeapYear(i) ? <span class="hljs-number">29</span> : <span class="hljs-number">28</span>;<br><br><span class="hljs-comment">//得到这年上的数字之和</span><br><span class="hljs-type">int</span> year = getSum(i);<br><br><span class="hljs-comment">//得到月和日的数字之和</span><br><span class="hljs-type">int</span> Mon_Day = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">12</span>; j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= month[j]; k++)<br>&#123;<br><span class="hljs-comment">//计算月份和日每位数字之和~</span><br><span class="hljs-type">int</span> tmp = getSum(j) + getSum(k);<br><span class="hljs-keyword">if</span> (tmp == year)<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第四题</h1><p>问题描述<br>小蓝有 30 个数，分别为：99, 22, 51, 63, 72, 61, 20, 88, 40, 21, 63, 30, 11, 18, 99, 12, 93, 16, 7, 53, 64, 9, 28, 84, 34, 96, 52, 82, 51, 77 。<br>小蓝可以在这些数中取出两个序号不同的数，共有 30*29/2=435 种取法。<br>请问这 435 种取法中，有多少种取法取出的两个数的乘积大于等于 2022 。</p><p>答案提交<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>水题哦。直接上代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">99</span>, <span class="hljs-number">22</span>, <span class="hljs-number">51</span>, <span class="hljs-number">63</span>, <span class="hljs-number">72</span>, <span class="hljs-number">61</span>, <span class="hljs-number">20</span>,<br>     <span class="hljs-number">88</span>, <span class="hljs-number">40</span>, <span class="hljs-number">21</span>, <span class="hljs-number">63</span>, <span class="hljs-number">30</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">99</span>, <span class="hljs-number">12</span>,<br>      <span class="hljs-number">93</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">9</span>, <span class="hljs-number">28</span>, <span class="hljs-number">84</span>, <span class="hljs-number">34</span>, <br>      <span class="hljs-number">96</span>, <span class="hljs-number">52</span>, <span class="hljs-number">82</span>, <span class="hljs-number">51</span>, <span class="hljs-number">77</span>&#125;;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">30</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]*a[j]&gt;=<span class="hljs-number">2022</span>)<br>            &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><hr><h1>第六题</h1><p><strong>问题描述</strong><br>　　给定一天是一周中的哪天，请问 n 天后是一周中的哪天？<br><strong>输入格式</strong><br>　　输入第一行包含一个整数 w，表示给定的天是一周中的哪天，w 为 1 到 6 分别表示周一到周六，w 为 7 表示周日。<br>　　第二行包含一个整数 n。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示 n 天后是一周中的哪天，1 到 6 分别表示周一到周六，7 表示周日。<br><strong>样例输入</strong><br>6<br>10<br><strong>样例输出</strong><br>2<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000。</p><blockquote><p>思路：给定一个整数w表明是周几，那不就是第几天嘛。让你算n天之后，只需要(w + n) % 7</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;w, &amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (w + n) % <span class="hljs-number">7</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1>第七题</h1><p><strong>问题描述</strong><br>　　小蓝负责一块区域的信号塔安装，整块区域是一个长方形区域，建立坐标轴后，西南角坐标为 (0, 0)， 东南角坐标为 (W, 0)， 西北角坐标为 (0, H)， 东北角坐标为 (W, H)。其中 W, H 都是整数。<br>　　他在 n 个位置设置了信号塔，每个信号塔可以覆盖以自己为圆心，半径为 R 的圆形（包括边缘）。<br>　　为了对信号覆盖的情况进行检查，小蓝打算在区域内的所有横纵坐标为整数的点进行测试，检查信号状态。其中横坐标范围为 0 到 W，纵坐标范围为 0 到 H，总共测试 (W+1) * (H+1) 个点。<br>　　给定信号塔的位置，请问这 (W+1)*(H+1) 个点中有多少个点被信号覆盖。<br><strong>输入格式</strong><br>　　输入第一行包含四个整数 W, H, n, R，相邻整数之间使用一个空格分隔。<br>　　接下来 n 行，每行包含两个整数 x, y，表示一个信号塔的坐标。信号塔可能重合，表示两个信号发射器装在了同一个位置。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示答案。<br><strong>样例输入</strong><br>10 10 2 5<br>0 0<br>7 0<br><strong>样例输出</strong><br>57<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= W, H &lt;= 100，1 &lt;= n &lt;= 100, 1 &lt;= R &lt;= 100, 0 &lt;= x &lt;= W, 0 &lt;= y &lt;= H。</p><blockquote><p>题目挺长的，但是细读会发现也就那样。</p><p>思路：</p><p>创建一个二维数组全部初始化为0，然后对每一个信号塔进行预处理，将这个点到信号塔的距离算出来(x - a)^2 + (y - b)^2.如果在信号塔的范围内</p><p>就将其对应二维数组的值改为1。最后再统计1的个数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> W, H, n, R;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;W, &amp;H, &amp;n, &amp;R);<br><span class="hljs-comment">//创建一个二维数组</span><br><span class="hljs-comment">//因为不知道支不支持边长数组，就将数组开到最大</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//对于每个信号塔进行预处理</span><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br><br><span class="hljs-comment">//这里是&lt;=哦~</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= H; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= W; j++)<br>&#123;<br><span class="hljs-comment">//两点距离公式</span><br><span class="hljs-comment">//一个点的坐标:(j,i)</span><br><span class="hljs-comment">//信号塔坐标:  (y,x)</span><br><span class="hljs-keyword">if</span> ((x - i) * (x - i) + (y - j) * (y - j) &lt;= (R * R))<br>&#123;<br><span class="hljs-comment">//懒得再遍历一遍数组了，直接记录下有多少个1不就完事了~</span><br><span class="hljs-comment">//注意！如果被两个信号塔覆盖，应该只能算1次</span><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-number">0</span>)<br>count++;<br><br>arr[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1>第八题</h1><p><strong>问题描述</strong><br>　　小蓝有一个 n * m 大小的矩形水域，小蓝将这个水域划分为 n 行 m 列，行数从 1 到 n 标号，列数从 1 到 m 标号。每行和每列的宽度都是单位 1 。<br>　　现在，这个水域长满了水草，小蓝要清理水草。<br>　　每次，小蓝可以清理一块矩形的区域，从第 r1 行（含）到第 r2 行（含）的第 c1 列（含）到 c2 列（含）。<br>　　经过一段时间清理后，请问还有多少地方没有被清理过。<br><strong>输入格式</strong><br>　　输入第一行包含两个整数 n, m，用一个空格分隔。<br>　　第二行包含一个整数 t ，表示清理的次数。<br>　　接下来 t 行，每行四个整数 r1, c1, r2, c2，相邻整数之间用一个空格分隔，表示一次清理。请注意输入的顺序。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示没有被清理过的面积。<br><strong>样例输入</strong><br>2 3<br>2<br>1 1 1 3<br>1 2 2 2<br><strong>样例输出</strong><br>2<br><strong>样例输入</strong><br>30 20<br>2<br>5 5 10 15<br>6 7 15 9<br><strong>样例输出</strong><br>519<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= r1 &lt;= r2 &lt;= n &lt;= 100, 1 &lt;= c1 &lt;= c2 &lt;= m &lt;= 100, 0 &lt;= t &lt;= 100。</p><blockquote><p>感觉水题一样的，跟上题差不多思路，依旧是创建一个二维数组，去找里面有多少个0——代表没被清理过的地方。</p><p>搞懂上题这题打个哈哈就过~</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n, m, t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;t);<br>    <span class="hljs-type">int</span> r1, c1, r2, c2;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);<br>        <span class="hljs-keyword">for</span> (i = r1; i &lt;= r2; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (j = c1; j &lt;= c2; j++)<br>            &#123;<br>                a[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
