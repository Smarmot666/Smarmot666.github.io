<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>网络原理-传输层</title>
    <link href="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在传输层中有两个非常重要的协议，UDP和TCP，现在就来研究一下这两个协议。</p><h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><img src="/2023/10/18/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E4%BC%A0%E8%BE%93%E5%B1%82/image-20231018103719412.png" class title="image-20231018103719412"><p>我们观察可以发现，里面UDP报文长度为2个字节，那么是多少呢？我们需要快速反应如下固定字节数据类型的取值范围：</p><table><thead><tr><th>字节大小</th><th>有无符号</th><th>取值范围</th></tr></thead><tbody><tr><td>1个字节</td><td>有符号</td><td>-128-127</td></tr><tr><td>1个字节</td><td>无符号</td><td>0-255</td></tr><tr><td>2个字节</td><td>有符号</td><td>-32768-32767</td></tr><tr><td>2个字节</td><td>无符号</td><td>0-65535</td></tr><tr><td>4个字节</td><td>有符号</td><td>-21亿-21亿</td></tr><tr><td>4个字节</td><td>无符号</td><td>0-42亿</td></tr></tbody></table><p><strong>源端口：</strong>2个字节，无符号，取值0-65535.</p><p><strong>目的端口：</strong>2个字节，无符号，取值0-65535.</p><p><strong>UDP报文长度：</strong>2个字节，无符号，取值范围0-64k，也就是说一个UDP最多能传输64kb的数据，这在当今是一个很小的数字(现在一个文件动不动就几个G).</p><blockquote><p><strong>说明：</strong></p><p>能否将这个长度变大呢？理论上可以，但是几乎无法做到。</p><p>理论上，我们只需要修改系统内核中udp的参数，将unsigned short改成int就可以增加长度，但是我们不能只修改自己电脑的，我们还得修改别人的，怎么说每个人都改呢???</p><p>不过我们还可以将数据拆分成多组进行传输或者使用tcp代替udp，tcp没有报文长度限制。</p></blockquote><p><strong>校验和：</strong>使用了一种简单粗暴的校验算法，把UDP数据报中的每个字节都依次进行累加。</p><blockquote><p><strong>说明：</strong></p><p>为什么要使用校验和呢？因为网络传输本质上是光信号&#x2F;电信号传输，会受到磁场，高能粒子的干扰，就有可能使传输的数据突变，即0变1，我们需要使用校验和来确保传输的数据没有变化。</p><p>一般UDP中校验和是将数据报中每个字节都累加，可能会溢出，但是不要紧，当接收方收到数据了后，再按照同样的方式进行累加，如果得到值一样，就是正确的。万一前面的字节值变小了，后面的变大了，一加一减没变，又该如何应对？这种情况是可能出现，但是概率极低，毕竟工程上有一些误差也能接受。</p></blockquote><h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h2><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>由于TCP中很多特性，在这列举比较熟知的。</p><p>一、确认应答</p><p>二、超时重传</p><p>三、连接管理</p><p>四、滑动窗口</p><p>五、流量控制</p><p>六、拥塞控制</p><p>七、延迟应答</p><p>八、捎带应答</p><p>九、面向字节流——粘包问题</p><p>十、异常情况处理——心跳包</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络原理-应用层</title>
    <link href="/2023/10/17/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/"/>
    <url>/2023/10/17/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86-%E5%BA%94%E7%94%A8%E5%B1%82%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>应用层是借助传输层提供的服务来实现自己的功能的，在应用层存在许多现成的协议，不过，很多时候程序猿也可以自定义协议，那协议究竟是什么？</p><h1 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h1><p>在这引入一个场景：在B站上搜索英雄联盟。</p><p>在这我们的请求是：英雄联盟，而服务器的响应是一大堆视频和比赛咨询信息啥的。</p><p>在这之间发生了什么呢？**首先我们需要知道，我们的代码中包含了各种各样的对象，当我们传输数据的时候需要将其进行序列化，将其变为文本数据或者二进制数据才能传输(简单理解将对象变为一个字符串)**。在我们输入”英雄联盟”的时候，客户端会将”英雄联盟”这个字符串按找某种协议的格式，重新组织，例如转换成”请求:英雄联盟\n”,然后发送给了服务器,此时服务器根据协议(例如:规定了从冒号后面开始读取,然后以\n为结尾)进行解析这个字符串,就得到了”英雄联盟”,之后计算响应,将一大堆视频信息组织整理,例如转换成”响应:视频1,xxxx;视频2,xxxx”，此时客户端再根据协议约定来解析这个响应，提取出里面的信息。</p><p><strong>总得来说，协议就是用来规定通信数据的格式、包含哪些信息，通信双方得遵守这个协议，才能读懂对方的意思</strong>，举个例子，我们都知道GBK编码后的中文字符，然后使用utf8来解读的话，会出现乱码，这就是因为双方没有遵守协议~ <strong>协议的具体格式可以非常灵活，但是要表征通信双方都使用相同的规则!!!</strong></p><h1 id="一些大佬的协议"><a href="#一些大佬的协议" class="headerlink" title="一些大佬的协议"></a>一些大佬的协议</h1><p>虽然说自定义格式可以是任意的，但是为了避免出现离离原上谱的设计方式，大佬门就搞出了一些”通用的协议格式”,我们可以参考这些格式。</p><h2 id="xml"><a href="#xml" class="headerlink" title="xml"></a>xml</h2><p>xml是以成对的标签，来表示”键值对”信息，和html长的差不多，不过<strong>xml中的标签是程序猿自己定义的</strong></p><p><strong>例如：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">request</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">userId</span>&gt;</span>张三<span class="hljs-tag">&lt;/<span class="hljs-name">userId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">request</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>优点：xml能非常清晰的把数据结构化表示出来。</strong></p><p><strong>缺点：表示数据需要引入大量标签，比较繁琐，传输的数据也多，会占用不少带宽。</strong></p><h2 id="json"><a href="#json" class="headerlink" title="json"></a>json</h2><p>json本质上也是”键值对”,相比xml更简洁一些，使用{}表示键值对。json是当前主流使用的一种网络传输数据的格式，其对换行并不敏感，在传输的时候会对json进行压缩,去掉不必要的换行来降低带宽(会影响可读性)。</p><p><strong>例如：</strong></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span><span class="hljs-string">&quot;Zhangsan&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;age&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">18</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;hobbies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;sleep&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;read&quot;</span><span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p><strong>优点：相比xml，数据简洁，可读性好。</strong></p><p><strong>缺点：依旧需要花费一定的带宽来传输”键”的数据。</strong></p><h2 id="protobuffer"><a href="#protobuffer" class="headerlink" title="protobuffer"></a>protobuffer</h2><p>protobuffer是谷歌提出的一套二进制的数据序列化方式。使用二进制的方式，约定某几个字节，表示什么什么属性，不必传输”键”的数据，通过位置和长度来区分每个属性。我们需要使用一个proto文件来编写，然后使用protobuf编译器将其转换。</p><p><strong>优点：不用传输”键”，节省带宽，最大化效率。</strong></p><p><strong>缺点：二进制数据，无法肉眼观察，使用比较复杂。</strong></p><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-网络编程</title>
    <link href="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、UDP-Socket编程"><a href="#一、UDP-Socket编程" class="headerlink" title="一、UDP Socket编程"></a>一、UDP Socket编程</h1><p>由于<strong>UDP是面向数据报</strong>的,我们需要用一个类来表示数据包,即DatagarmPacket.</p><h2 id="DatagramPacket-API"><a href="#DatagramPacket-API" class="headerlink" title="DatagramPacket API"></a>DatagramPacket API</h2><p><strong>构造方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>DatagramPacket(byte[] buf, int length)</td><td>构造一个DatagramPacket来<strong>接收数据报</strong>,数据存储在buf数组中，长度为length.</td></tr><tr><td>DatagramPacket(byte[] buf, int offset, int length, SocketAddress address)</td><td>构造一个DatagramPacket来发送数据报,发送的数据是从buf数组的offset位置开始往后length长度的数据，address指定目的ip和port</td></tr></tbody></table><p><strong>成员方法:</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>SocketAddress getSocketAddress()</td><td>返回SocketAddress,一般是ip+port</td></tr><tr><td>int getPort()</td><td>返回port</td></tr><tr><td>InetAddress getAddress()</td><td>返回ip地址</td></tr><tr><td>byte[] getData()</td><td>获取数据包中的数据</td></tr></tbody></table><h2 id="DatagramSocket-API"><a href="#DatagramSocket-API" class="headerlink" title="DatagramSocket API"></a>DatagramSocket API</h2><p>我们为了是层间传输的数据更小，就引入了Socket，我们需要使用Socket来表示一些特定的信息.如UDP的Socket本质上是一个整数，用来代表的一端的会话关系。</p><p><strong>构造方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>DatagramSocket()</td><td>一般是在客户端使用,创建一个UDP的Socket，端口号由系统分配</td></tr><tr><td>DatagramSocket(int port)</td><td>一般是在服务器端使用,创建一个UDP的Socket，端口号手动分配</td></tr></tbody></table><p><strong>成员方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>void receive(DatagramPacket p)</td><td>此处的p是返回型参数，将收到的数据报放到p中,如果没有接受到,会阻塞等待</td></tr><tr><td>void send(DatagramPacket p)</td><td>将数据报p发送</td></tr></tbody></table><h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231013110641383.png" class title="image-20231013110641383"><h2 id="简单通信程序"><a href="#简单通信程序" class="headerlink" title="简单通信程序"></a>简单通信程序</h2><p>在这里我们实现一个简单的UDP客户端&#x2F;服务器通信程序，这个程序中没啥业务逻辑，是一个回显服务器，服务器收到客户端的字符串后，原封不动的返回即可。</p><p><strong>UDPEchoServer</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.DatagramPacket;<br><span class="hljs-keyword">import</span> java.net.DatagramSocket;<br><span class="hljs-keyword">import</span> java.net.SocketException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpEchoServer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//手动指定服务器的端口号</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UdpEchoServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> SocketException &#123;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>(port);<br>    &#125;<br><br>    <span class="hljs-comment">//通过start方法来启动服务器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器启动!&quot;</span>);<br>        <span class="hljs-comment">//服务器一般都是7*24小时运行着</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//1.读取请求并解析</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">requestPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>], <span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">//服务器没收到请求的话就会在这阻塞等待</span><br>            socket.receive(requestPacket);<br><br>            <span class="hljs-comment">//2.根据请求计算响应</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(requestPacket.getData(), <span class="hljs-number">0</span>, requestPacket.getLength());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> process(request);<br><br>            <span class="hljs-comment">//3.将响应发送给客户端</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">responsePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(response.getBytes(), <span class="hljs-number">0</span>, response.getBytes().length, requestPacket.getAddress(), requestPacket.getPort());<br>            socket.send(responsePacket);<br><br>            <span class="hljs-comment">//打印日志</span><br>            System.out.printf(<span class="hljs-string">&quot;[%s:%d] req: %s, resp: %s\n&quot;</span>, requestPacket.getAddress().toString(), requestPacket.getPort(), request, response);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">process</span><span class="hljs-params">(String request)</span>&#123;<br>        <span class="hljs-keyword">return</span> request;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">UdpEchoServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UdpEchoServer</span>(<span class="hljs-number">8080</span>);<br>        server.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>UdpEchoClient</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.net.*;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UdpEchoClient</span> &#123;<br>    <span class="hljs-comment">//客户端不需要手动指定</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">DatagramSocket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">private</span> String serverIp;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> serverPort;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UdpEchoClient</span><span class="hljs-params">(String ip, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> SocketException &#123;<br>        serverIp = ip;<br>        serverPort = port;<br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramSocket</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端上线!&quot;</span>);<br>        <span class="hljs-comment">//循环去发请求</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            System.out.println(<span class="hljs-string">&quot;请输入：&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> sc.next();<br><br>            <span class="hljs-comment">//1.将服务器的地址和端口号放进数据报，然后发送</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">requestPacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(request.getBytes(), <span class="hljs-number">0</span>, request.getBytes().length, InetAddress.getByName(serverIp), serverPort);<br>            socket.send(requestPacket);<br><br>            <span class="hljs-comment">//2.等待接受服务器发来的响应</span><br>            <span class="hljs-type">DatagramPacket</span> <span class="hljs-variable">responsePacket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DatagramPacket</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>], <span class="hljs-number">1024</span>);<br>            socket.receive(responsePacket);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(responsePacket.getData(), <span class="hljs-number">0</span>, responsePacket.getData().length);<br>            System.out.println(response);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">UdpEchoClient</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="二、TCP-Socket编程"><a href="#二、TCP-Socket编程" class="headerlink" title="二、TCP Socket编程"></a>二、TCP Socket编程</h1><p>由于<strong>Tcp是面向字节流和有连接</strong>的，因此与Udp编程有一些差异，不过依旧是那三部曲：服务器读取请求并解析，根据请求计算响应，将响应返回给客户端。</p><p>Tcp的socket是用来标识通信的双方，是一个四元组，包含了：源ip、源port、目的ip、目的port。</p><h2 id="ServerSocket-API"><a href="#ServerSocket-API" class="headerlink" title="ServerSocket API"></a>ServerSocket API</h2><p>ServerSocket是在服务器端使用的。</p><p><strong>构造方法</strong>：</p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>ServerSocket(int port)</td><td>创建一个服务器端的socket，并绑定到指定端口</td></tr></tbody></table><p><strong>普通方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>Socket accept()</td><td>守候自己的端口号上等待用户的连接，当有连接后，返回一个Socket对象，表示与客户端建立的连接。</td></tr><tr><td>void close()</td><td>关闭socket</td></tr></tbody></table><h2 id="Socket-API"><a href="#Socket-API" class="headerlink" title="Socket API"></a>Socket API</h2><p>这个socket类可以表示客户端Socket，也可以表示为服务器端接受到客户端连接的请求后，返回的服务器端Socket。</p><p><strong>构造方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>Socket(String host, int port)</td><td>创建一个socket，与对应ip上的对应port建立连接</td></tr></tbody></table><p><strong>普通方法：</strong></p><table><thead><tr><th>方法名</th><th>方法说明</th></tr></thead><tbody><tr><td>InetAddress getInetAddress()</td><td>返回socket所连接的地址</td></tr><tr><td>InputStream getInputStream()</td><td>返回socket的输入流</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回socket的输出流</td></tr></tbody></table><h2 id="大致流程-1"><a href="#大致流程-1" class="headerlink" title="大致流程"></a>大致流程</h2><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016104641763.png" class title="image-20231016104641763"><h2 id="简单通信程序-1"><a href="#简单通信程序-1" class="headerlink" title="简单通信程序"></a>简单通信程序</h2><p><strong>TcpEchoServer：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.ServerSocket;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpEchoServer</span> &#123;<br>    <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">//指定服务器端的port</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TcpEchoServer</span><span class="hljs-params">(<span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        serverSocket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>    &#125;<br><br>    <span class="hljs-comment">//启动服务器</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器启动!&quot;</span>);<br>        <span class="hljs-comment">//服务器往往是7*24小时一直运转~</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-comment">//获取一个和服务器端的连接</span><br>            <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>            <span class="hljs-comment">//处理连接</span><br>            processConnection(socket);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processConnection</span><span class="hljs-params">(Socket socket)</span>&#123;<br>        System.out.printf(<span class="hljs-string">&quot;[%s:%d] 客户端已经上线~\n&quot;</span>, socket.getInetAddress().toString(), socket.getPort());<br>        <span class="hljs-comment">//与udp同理三部曲，不过tcp是字节流，使用流对象来读请求和发响应</span><br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream())&#123;<br>            <span class="hljs-comment">//为了方便，使用Scanner直接当做字符来处理</span><br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(inputStream);<br>            <span class="hljs-comment">//客户端可能会多次发请求</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">if</span>(!scanner.hasNext())&#123;<br>                    System.out.printf(<span class="hljs-string">&quot;[%s:%d] 客户端已经下线~\n&quot;</span>, socket.getInetAddress().toString(), socket.getPort());<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">//1、读取请求并解析</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> scanner.next();<br>                <span class="hljs-comment">//2.根据请求计算响应</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> process(request);<br>                <span class="hljs-comment">//3.将响应发送给客户端</span><br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStream);<br>                writer.println(response);<br>                <span class="hljs-comment">//刷新缓冲区</span><br>                writer.flush();<br>                <span class="hljs-comment">//打印日志</span><br>                System.out.printf(<span class="hljs-string">&quot;[%s:%d] req: %s, resp: %s\n&quot;</span>, socket.getInetAddress().toString(), socket.getPort(), request, response);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">process</span><span class="hljs-params">(String request)</span>&#123;<br>        <span class="hljs-keyword">return</span> request;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">TcpEchoServer</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TcpEchoServer</span>(<span class="hljs-number">8080</span>);<br>        server.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>TcpEchoClient:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.OutputStream;<br><span class="hljs-keyword">import</span> java.io.PrintWriter;<br><span class="hljs-keyword">import</span> java.net.Socket;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TcpEchoClient</span> &#123;<br>    <span class="hljs-comment">//客户端自己的socket</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TcpEchoClient</span><span class="hljs-params">(String ip, <span class="hljs-type">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">//指定服务器的地址和端口号</span><br>        socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(ip, port);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> socket.getInputStream();<br>            <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> socket.getOutputStream())&#123;<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scannerConsole</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-comment">//1.组织请求</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> scannerConsole.next();<br>                <span class="hljs-comment">//2.将请求发送给服务器</span><br>                <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStream);<br>                writer.println(request);<br>                writer.flush();<br>                <span class="hljs-comment">//3.接受服务器端的响应</span><br>                <span class="hljs-type">Scanner</span> <span class="hljs-variable">scannerResponse</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(inputStream);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> scannerResponse.next();<br>                System.out.println(response);<br><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">TcpEchoClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TcpEchoClient</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>);<br>        client.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p><strong>虽然Java有着垃圾回收机制，但是我们的服务器端一般是7*24小时运行着</strong>，而我们的代码中有着一个死循环，它一直在创建Socket对象，而每个socket对象与文件有关，也就是说<strong>每创建一个socket对象会占用一定的文件资源，因此我们需要去手动释放它</strong>。由于Socket类实现了closeable接口，我们可以使用try with resourse来关闭。</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016111221970.png" class title="image-20231016111221970"><p><strong>那么我们是否还需要去手动关闭Scanner和PrintWriter呢</strong>？不用，这是因为这两个里面<strong>持有的是inputStream和outputStream对象的引用</strong>，我们已经设置了自动关闭这两个对象，因此我不需要再关闭一次。</p><h2 id="多个客户端访问"><a href="#多个客户端访问" class="headerlink" title="多个客户端访问"></a>多个客户端访问</h2><p>虽然我们代码现在是安全了，但是还存在一个问题，当我们来了<strong>多个客户端访问服务器</strong>的时候，由于我们在processConnection中写了一个while循环，那么当客户端A进来后，<strong>程序就会阻塞在这个循环中</strong>，直到客户端A断开连接后，服务器才能去服务器客户端B，因此我们需要使用多线程来处理并发。</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016112051391.png" class title="image-20231016112051391"><p>很自然的我们可以写出这样的代码，然后就会出现如下错误：</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016112152276.png" class title="image-20231016112152276"><p>这是因为我们主线程在执行完代码块的时候，我们的另一个线程去执行了processConnction方法，但是还没执行完，我们的主线程就自动调用了socket.close，于是就抛出了上述异常。</p><p><strong>正确写法应该这样：</strong></p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016113704003.png" class title="image-20231016113704003"><p>在processConnection中关闭连接，因为<strong>一个processConnection处理完了，也就相当于一个连接结束</strong>了，因此我们可以在这进行关闭。</p><p>不过手动创建线程会涉及到用户态和内核态的转变，我们还可<strong>以使用一个线程池来进一步优化效率</strong>。</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016114507131.png" class title="image-20231016114507131"><p>最终结果如下：</p><img src="/2023/10/13/JavaEE-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/image-20231016114531403.png" class title="image-20231016114531403">]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-IO</title>
    <link href="/2023/10/05/JavaEE-IO/"/>
    <url>/2023/10/05/JavaEE-IO/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="认识文件"><a href="#认识文件" class="headerlink" title="认识文件"></a>认识文件</h1><p>文件是一个广义的概念，在操作系统中，会把很多的硬件设备和软件资源都抽象成”文件”, 统一进行管理。我们平时所谈到的文件，都是指硬盘中的文件。文件就相当于是对”硬盘”数据的一种抽象。</p><h2 id="文件组织结构"><a href="#文件组织结构" class="headerlink" title="文件组织结构"></a>文件组织结构</h2><p>由于文件很多，那么如何来管理文件呢？——<strong>使用一种按照层级结构进行组织，即树形结构</strong>。</p><img src="/2023/10/05/JavaEE-IO/image-20231005104001376.png" class title="image-20231005104001376"><h2 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h2><p>文件路径是用来定位当前文件资源的，被分为<strong>相对路径和绝对路径</strong>。</p><p><strong>绝对路径：从根节点(以C,D盘符开头的)到叶子节点(当前文件)的路径。</strong></p><p>如: C:\植物大战僵尸\Plants Vs Zombies\PlantsVsZombies.exe</p><p><strong>相对路径：使用一个基准目录(使用.或者..表示,一个.表示当前目录,两个.表示当前目录的上一级),表示从这个基准目录往后到叶子节点的路径。</strong></p><p>如：.\Plants Vs Zombies\PlantsVsZombies.exe 这里的.就代表了C:\植物大战僵尸</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>从编程的角度来看，文件主要分为两大类：</p><p><strong>1、文本文件(文件中保存的都是字符串，都是合法的字符)。</strong></p><p><strong>2、二进制文件(文件中保存是二进制数据)</strong></p><p>如何区分？丢将文件丢记事本中,<strong>记事本会尝试按照字符的方式来展示内容，这个过程中会自动查码表，如果出现了一些看不懂的内容，那大概率就是二进制文件了。</strong></p><img src="/2023/10/05/JavaEE-IO/image-20231005110248724.png" class title="image-20231005110248724"><h1 id="File类"><a href="#File类" class="headerlink" title="File类"></a>File类</h1><p>Java中通过java.io.File类来对一个文件进行描述。File对象可以对应到一个已经真实存在的文件，也可以对应到一个不存在的文件。</p><h2 id="File中常用方法"><a href="#File中常用方法" class="headerlink" title="File中常用方法"></a>File中常用方法</h2><p><strong>构造方法</strong></p><table><thead><tr><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>File(File parent, String child)</td><td>根据父目录+孩子文件路径创建File实例</td></tr><tr><td>File(String pathname)</td><td>根据文件路径来创建一个File实例</td></tr><tr><td>File(String parent, String child)</td><td>根据父目录+孩子文件路径创建File实例</td></tr></tbody></table><p><strong>成员方法</strong></p><table><thead><tr><th>返回值</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>String</td><td>getParent()</td><td>返回File对象的父目录文件路径</td></tr><tr><td>String</td><td>getName()</td><td>返回File对象的文件名称</td></tr><tr><td>String</td><td>getPath()</td><td>返回File对象的文件路径</td></tr><tr><td>String</td><td>getAbsolutePath()</td><td>返回 File 对象的绝对路径</td></tr><tr><td>String</td><td>getCanonicalPath()</td><td>返回 File 对象的修饰过的绝对路径</td></tr><tr><td>void</td><td>deleteOnExit()</td><td>根据 File 对象，标注文件将被删除，删除动作会到 JVM 运行结束时才会进行</td></tr><tr><td>boolean</td><td>exists()</td><td>判断File对象文件是否存在</td></tr><tr><td>boolean</td><td>createNewFile()</td><td>根据File对象创建空文件</td></tr><tr><td>boolean</td><td>delete()</td><td>根据File对象，删除该文件</td></tr><tr><td>boolean</td><td>isFile()</td><td>判断 File 对象代表的文件是否是一个普通文件</td></tr><tr><td>boolean</td><td>isDirectory()</td><td>判断 File 对象代表的文件是否是一个目录</td></tr><tr><td>boolean</td><td>mkdir()</td><td>创建File对象代表的目录&#x2F;文件夹</td></tr><tr><td>boolean</td><td>mkdirs()</td><td>创建File对象代表的目录，可以创建中间目录</td></tr></tbody></table><h1 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h1><p>以上是文件系统的操作，但我们日常更多的是进行文件内容的操作。这时候我们就需要用到”文件流”了。</p><p>“流”是一种抽象的概念，程序员不用关注数据是怎么从硬盘上读入&#x2F;读出的，只需要关注如何写入到”流”中。文件流一般又分为两大类：字节流和字符流。</p><h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><p>字节流顾名思义是一个字节一个字节的读入&#x2F;读出的，更适合与二进制文件的操作，这样可以保证文件不失真。</p><p>字节流又分为输入字节流InputStream和输出字节流OutputStream。这两个类在Java中是各种实现字节流类的基类，而且还是抽象类。</p><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p><strong>常用方法</strong></p><table><thead><tr><th>返回值</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>int</td><td>read()</td><td>读取一个字节的数据，返回-1表示已经读完了</td></tr><tr><td>int</td><td>read(byte[] b)</td><td>最多读取b.length个字节的数据到b数组中，返回实际读到的数量，-1表示读完了</td></tr><tr><td>int</td><td>read(byte[] b, int off, int len)</td><td>最多读取len-off个字节到b数组，放在从off开始位置</td></tr><tr><td>void</td><td>close</td><td>关闭字节流</td></tr></tbody></table><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><table><thead><tr><th>返回值</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>void</td><td>write(int b)</td><td>将b写入到文件</td></tr><tr><td>void</td><td>write(byte[] b)</td><td>将b数组中全部数据写入文件</td></tr><tr><td>int</td><td>write(byte[] b, int off, int len)</td><td>将b数组中从off位置往后len个数据写入文件</td></tr><tr><td>void</td><td>close()</td><td>关闭字节流</td></tr><tr><td>void</td><td>flush()</td><td>刷新缓冲区</td></tr></tbody></table><p><strong>注意</strong>：</p><p>为什么要手动进行刷新缓冲区呢？这是因为I&#x2F;O写入的速度很慢，OutputStream为了频繁多次只写一点点数据，就在写数据的时候会先将数据暂时<strong>写入缓冲区</strong>，然后才会将真正的数据写入文件。因此有可能当我们写完数据，结束程序后去看文件发现什么也没有，这是因为数据都在缓冲区中，还没来得及到文件里，这时需要手动刷新缓冲区。</p><p>我们可以使用上述的方法，进行读文件与写文件操作，但我们还可以<strong>使用PrintWriter类来帮我更简便的操作</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> FileNotFoundException, UnsupportedEncodingException &#123;<br>    <span class="hljs-type">OutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;D:/Test/test.txt&quot;</span>);<br>    <span class="hljs-type">OutputStreamWriter</span> <span class="hljs-variable">outputStreamWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutputStreamWriter</span>(outputStream, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(outputStreamWriter);<br><br>    writer.println(<span class="hljs-string">&quot;我是第一行~&quot;</span>);<br>    writer.println(<span class="hljs-string">&quot;我是第二行~&quot;</span>);<br>    writer.println(<span class="hljs-string">&quot;我是第三行~&quot;</span>);<br>    writer.flush();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><p>在字符流中会使用到两个重要的基类：Reader和Writer。里面的方法使用跟上述字节流基本一致，只不过一个针对的是字节一个针对的是字符。</p><p>在Java中字符通常用char类型表示，字节用byte表示，一个char类型为2个字节，一个utf8编码的中文字符占3个字节。在Java标准库中，对字符编码进行了很多处理，如果只是用char，此时使用的字符集固定是Unicode，如果是使用了String，此时会自动把每个字符的unicode转为utf8编码，同样一个中文汉字，在unicode编码下占2个字节，而在utf8编码下占3个字节。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>我们每创建一个流对象就应该在不使用的时候进行关闭，即调用它的close方法。这是因为一个进程创建的时候，其PCB中会有一个文件描述符表来描述文件相关资源，如果我们的代码一直打开文件而不去关闭文件，这个文件描述符表里的元素越来越多，直到占满了，后续再次尝试创建就会出错，最终导致了文件资源泄漏。</p><p><strong>方案一：</strong></p><p><strong>每次使用完，人为的去手动调用它的close方法.</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:/Test/test.txt&quot;</span>;<br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(path);<br>        <br>        <span class="hljs-comment">//写入文件~</span><br>        <br>        writer.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是这样去写的话，万一中间抛出了什么异常，那么就不会往下执行代码了，就导致了close方法没有执行。</p><p><strong>方案二:</strong></p><p><strong>在finally代码块中调用。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:/Test/test.txt&quot;</span>;<br>        <span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(path);<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//写文件</span><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            writer.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样无论如何，finally代码块中的代码都会被执行，即close方法一定被执行了。虽然能这么写，但是不够优雅~</p><p><strong>方案三：</strong></p><p><strong>使用try(){}语法，这个语法会在try代码块执行结束的时候(正常结束或者抛出异常)，自动调用()定义的变量中的close方法。不过里面的变量类型必须实现了closeable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo5</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;D:/Test/test.txt&quot;</span>;<br>        <span class="hljs-keyword">try</span>(<span class="hljs-type">Writer</span> <span class="hljs-variable">writer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(path))&#123;<br>            <span class="hljs-comment">//写文件</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-多线程进阶</title>
    <link href="/2023/09/22/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/09/22/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、常见的锁策略"><a href="#一、常见的锁策略" class="headerlink" title="一、常见的锁策略"></a>一、常见的锁策略</h1><h2 id="乐观锁-vs-悲观锁"><a href="#乐观锁-vs-悲观锁" class="headerlink" title="乐观锁 vs 悲观锁"></a>乐观锁 vs 悲观锁</h2><p>乐观锁和悲观锁并不是一个具体的锁，而是一类锁的特性。</p><p><strong>悲观锁</strong>：悲观锁认为接下来<strong>锁冲突的概率较大</strong>，所以在<strong>访问资源共享资源前会先上锁</strong>。</p><p><strong>乐观锁</strong>：乐观锁认为接下来<strong>锁冲突的概率不大</strong>，所以会<strong>先修改共享资源</strong>，然后<strong>再去验证这段时间内有没有发生冲突</strong>，如果没有，则完成操作，<strong>如果有，放弃本次操作，返回用户错误信息，让用户再去处理。</strong></p><p><strong>两种锁并没有孰优孰劣之分，而是需要看当前使用的场景。</strong></p><p>如果当前冲突概率确实大，使用悲观锁策略会更好，而使用乐观锁的话，会导致”白操作”很多次，耗费资源。</p><p>如果当前冲突概率比较小，使用乐观锁更好，而使用悲观锁的话就会一直加锁，并发程度就下降了。</p><p>synchronized 初始使用的是乐观锁策略，当发现锁竞争比较频繁的时候，就会自动切换成悲观锁策略(真是太强了~~)。</p><h2 id="重量级锁-vs-轻量级锁"><a href="#重量级锁-vs-轻量级锁" class="headerlink" title="重量级锁 vs 轻量级锁"></a>重量级锁 vs 轻量级锁</h2><p>重量级和轻量级描述的是实际的开销量。<strong>在底层，加锁机制是通过操作系统提供的mutex锁来实现的，因此一旦加上锁，就会涉及到操作系统的内核，即在内核态与用户态间切换，这就会带来不小的开销。</strong></p><p>上述悲观锁就是重量级锁，因为会频繁加锁，而乐观锁则是轻量级锁，其原则是尽量不加锁。</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><strong>在多线程中数据的读取操作不会产生线程安全问题，但是当有线程在写入数据的时候，另一个线程无论是读还是写操作都会出现线程安全的问题。</strong>如果在这两种场景(都是读或者有读有写)都只是用一个锁的话，就会产生很大的性能消耗，因此读写锁应运而生~</p><p>读写锁分为两部分：一个”读锁”,一个”写锁”。适合于”读多，写少”的场景。<strong>在Java中ReentrantReadWriteLock类就实现了读写锁。</strong></p><img src="/2023/09/22/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/image-20230927160351210.png" class title="image-20230927160351210"><p><strong>读写锁将读操作和写操作进行了区分对待</strong>，其中：</p><ul><li><p>读加锁和读加锁之间，不互斥。</p></li><li><p>写加锁和写加锁之间，互斥。</p></li><li><p>写加锁和读加锁之间，互斥。</p></li></ul><h2 id="自旋锁-vs-互斥锁-挂起等待锁"><a href="#自旋锁-vs-互斥锁-挂起等待锁" class="headerlink" title="自旋锁 vs 互斥锁(挂起等待锁)"></a>自旋锁 vs 互斥锁(挂起等待锁)</h2><p><strong>自旋锁是一种轻量级锁</strong>，其实现套路往往是<strong>使用一个循环不停的检查当前锁是否被释放</strong>，如果没有释放就继续循环，释放了就去获取锁，<strong>因此自旋锁往往是在纯用户态实现</strong>。但是不停的循环，就会产生”忙等”现象(消耗cpu换取更快的响应速度)。</p><p><strong>互斥锁是一种重量级锁</strong>，一个<strong>线程针对互斥锁进行加锁失败而阻塞是由操作系统内核实现</strong>的，当加锁失败，内核会将线程置为睡眠状态，等待锁释放后，内核会在合适的时机唤醒线程。所以<strong>当加锁失败后，会从用户态切换到内核态</strong>，而这就会产生不小的开销。</p><h2 id="可重入锁-vs-不可重入锁"><a href="#可重入锁-vs-不可重入锁" class="headerlink" title="可重入锁 vs 不可重入锁"></a>可重入锁 vs 不可重入锁</h2><p>如果一个<strong>针对同一把锁，连续加锁两次不会产生死锁，那么就是可重入锁</strong>，如果会死锁，就是不可重入锁。</p><p><strong>synchronized就是可重入锁</strong>，而linux中的mutex就是不可重入锁。</p><h2 id="公平锁-vs-非公平锁"><a href="#公平锁-vs-非公平锁" class="headerlink" title="公平锁 vs 非公平锁"></a>公平锁 vs 非公平锁</h2><p>当很多线程尝试去加一把锁的时候，只有一个线程能够拿到这把锁，其他线程进行阻塞等待，当这个线程释放锁后，接下来哪个线程能够拿到锁呢？</p><p><strong>公平锁：按照”先来后到”的顺序</strong>。(需要使用数据结构来维护加锁顺序)</p><p><strong>非公平锁：剩下的线程以”均等”的概率来重新竞争锁</strong>。</p><h1 id="二、CAS"><a href="#二、CAS" class="headerlink" title="二、CAS"></a>二、CAS</h1><p>CAS的全称是Compare And Swap, 本质上是<strong>一个cpu提供的指令，具有原子性</strong>，其被操作系统封装提供成api，然后又被JVM封装成api提供给程序员使用。</p><p><strong>CAS比较交换的是内存和寄存器</strong>，假设现在有一个内存M,两个寄存器A,B,CAS的操作如下：</p><p><strong>如果M和A的值相同，则交换M和B中的值，如果不同的话，则无事发生。</strong></p><hr><p>在介绍线程安全的时候，我们引入了一个案例，即通过i++操作让两个线程对变量i进行2w次的自增操作，最终结果并不是我们所想要的。<strong>这是因为i++操作本质上不是原子的，由load、add、save这三个指令完成，在并发的时候由于穿插执行，导致了线程不安全</strong>。解决办法是进行加锁。不过我们也可以使用CAS指令来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AtomicInteger</span> &#123;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> value;<br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndIncrement</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> value;<br>        <span class="hljs-keyword">while</span> ( CAS(value, oldValue, oldValue+<span class="hljs-number">1</span>) != <span class="hljs-literal">true</span>) &#123;<br>        oldValue = value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> oldValue;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里CAS是通过重试的方法来避免穿插执行的。</p><p>当两个线程同时进行操作的时候，线程1已经自增过一次了，线程2此时使用CAS，发现value不等于oldValue，此时就不进行操作了，然后一直循环，知道发现某一次相等才会进行自增操作。</p><h2 id="CAS中的ABA问题"><a href="#CAS中的ABA问题" class="headerlink" title="CAS中的ABA问题"></a>CAS中的ABA问题</h2><p>虽然CAS已经是一个原子指令了，但是还是可能会出现一些问题，即反复横跳问题。</p><img src="/2023/09/22/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E9%98%B6/image-20230927211126606.png" class title="image-20230927211126606"><p>如图所示，本来是让两个线程去同时操作value的值，理论上value的值应该只能被修改一次，但是<strong>后面又来了线程3，它偷偷将value的值修改回去了</strong>，然后线程1发现值没变，最后又修改了，这样就导致了value的值被修改了两次。如果带入到取钱场景中，会发现非常要命，假设ATM机卡了，你多点了两次，就创建了两个线程去扣款50，此时剩下的钱变为了50，但恰巧有人给你转账了50，余额又变为了100，前面扣款的某个线程发现了值没变，又再一次扣款了,最终导致多扣了50……</p><hr><p>大部分情况下ABA问题都是没啥问题的，但又一些极端情况，还是会出现bug的。</p><p><strong>解决方案</strong>：</p><p><strong>ABA问题是因为某个值出现有增有减的情况</strong>，<strong>那么只要让判定的数值，按照一个方向增长即可。</strong>我们可以<strong>引入一个版本号，约定好每次修改余额的时候，都让版本号自增</strong>，此时CAS判定的时候就不是判定余额了，而是<strong>判定版本号是否发生了变化</strong>。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-线程安全</title>
    <link href="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    <url>/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、-案例引入"><a href="#一、-案例引入" class="headerlink" title="一、 案例引入"></a>一、 案例引入</h1><p><strong>线程安全是多线程中最重要最复杂的部分。可能同一份代码在单线程的环境下执行是正确的，但在多线程环境中就不一定了。</strong></p><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test4</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>                count++;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)&#123;<br>                count++;<br>            &#125;<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br><br>        t1.join();<br>        t2.join();<br><br>        System.out.println(<span class="hljs-string">&quot;count: &quot;</span> + count);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>在逻辑上，count应该自增了2w次，最终count的值应该为2w，然而结果却不是2w，而且<strong>几乎每次运行的结果都不相同</strong>。</p><img src="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20230823154800674.png" class title="image-20230823154800674"><p><strong>解释：</strong></p><p>这是因为count++ 操作并不是原子的，<strong>本质上是分成三步的</strong>：</p><blockquote><p>1、load 把数据从内存中读到cpu寄存器中</p><p>2、add 把寄存器中的数据进行+1</p><p>3、save 把寄存器中的数据，保存到内存中。</p></blockquote><p><strong>如果是多个线程执行的话，由于线程之间的调度顺序是随机的，并不确定，就会导致出现问题</strong>。</p><p>如：当第一个线程正在进行第一个操作的load的时候，第二个线程已经完成了第二、三、四的操作，此时第一个线程再进行第一个操作的add的时候，从寄存器中读取到的数据是0，而非3，因此就会出现错误。</p><p><strong>总结：</strong></p><p>产生线程安全问题的原因：</p><blockquote><p>1、操作系统中，线程的调度顺序是随机的(抢占式执行)</p><p>2、不同线程，最对同一个变量进行修改</p><p>3、修改操作，不是原子的，即某个操作必须一起全部完成。</p><p>4、内存可见性问题</p><p>5、指令重排序问题</p></blockquote><hr><p>那要如何保证代码一定准确呢？答案是<strong>加锁</strong>！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(对象名)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意：</strong></p><p>() 中需要表示一个用来加锁的对象，这个<strong>对象是啥不重要</strong>，<strong>重要的是通过这个对象来区分两个线程是否在竞争同一个锁</strong>。如果两个线程是在针对同一个对象加锁，就会有锁竞争，如果不是针对同一对象加锁，就不会有锁竞争，而此时的并发程度最高，但是不能保证正确。</p><p>{}内的代码就是要执行的内容了。</p><p>当一个线程拿到了这把对象锁之后，另外一个线程就得阻塞，等待上一个线程释放锁，之后再进行竞争这把锁。</p><h1 id="二、Synchronized的特性"><a href="#二、Synchronized的特性" class="headerlink" title="二、Synchronized的特性"></a>二、Synchronized的特性</h1><h3 id="2-1-修饰权限"><a href="#2-1-修饰权限" class="headerlink" title="2.1 修饰权限"></a>2.1 修饰权限</h3><p><strong>synchronized不仅能修饰代码块，还可以修饰方法。</strong></p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>      <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>            <br>      &#125;<br>&#125;<br><br><span class="hljs-comment">//相当于</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>          <span class="hljs-comment">//使用this，表示对当前对象加锁</span><br>          <span class="hljs-keyword">synchronized</span>(<span class="hljs-built_in">this</span>)&#123;<br>              <br>          &#125;<br>      &#125;<br>&#125;<br><br><span class="hljs-comment">//静态方法也是一样</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//相当于</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fun</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-comment">//这里Test.class为类对象</span><br>        <span class="hljs-keyword">synchronized</span>(Test.class)&#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-刷新内存"><a href="#2-2-刷新内存" class="headerlink" title="2.2 刷新内存"></a>2.2 刷新内存</h3><p>由于网上众说纷纭…….</p><h3 id="2-3-可重入"><a href="#2-3-可重入" class="headerlink" title="2.3 可重入"></a>2.3 可重入</h3><p>所谓的可重入锁指的是一个线程中连续对某一个对象进行加锁，但不会出现死锁的现象，如果满足就是“可重入”。</p><p><strong>举个例子</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">locker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                    <br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>分析</strong>：如果没有可重入特性的话……</p><p>假设当在最外面的时候对locker对象加锁成功了，此时locker对象应该是”被锁定的状态”，然后进行内层的加锁操作，发现此时locker已经是锁定的状态了，原则上，需要阻塞等待locker对象的锁被释放，才能进行第二次加锁，这样就形成了“死锁”，即第二次加锁操作需要等待第一次加锁操作释放锁，第一次加锁操作需要等待第二次加完锁后执行代码才能释放锁……. </p><p>但在Java中并不会出现这种情况，这是因为<strong>synchronized的可重入特性</strong>。当进行加锁操作的时候，会先记录一下是哪个线程获得了这个对象锁，后续这个线程再进行加锁的话，会检查是否已经持有了这个对象锁，如果有直接加锁成功。同理释放锁是在最外层的synchronized结束后，才释放锁(底层使用了计数器来管理，每当加锁一次，计数器+1，出了这个锁，计数器-1，如果为0了，则真正释放锁)。</p><h1 id="三、-死锁"><a href="#三、-死锁" class="headerlink" title="三、 死锁"></a>三、 死锁</h1><p>死锁可大致分为两类：一个线程一把锁，N个线程M把锁。</p><h3 id="3-1-一个线程一把锁"><a href="#3-1-一个线程一把锁" class="headerlink" title="3.1 一个线程一把锁"></a>3.1 一个线程一把锁</h3><p>这种情况也就是上面所说的情况，但在Java中synchronized是可重入锁，并不会产生，但在c++中，std::mutex可并不是可重入锁，就会出现死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <br>        <span class="hljs-type">Object</span> <span class="hljs-variable">locker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//并不会死锁~~</span><br>            <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                    <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                        <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                            <span class="hljs-keyword">synchronized</span> (locker)&#123;<br><br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-N个线程M把锁"><a href="#3-2-N个线程M把锁" class="headerlink" title="3.2 N个线程M把锁"></a>3.2 N个线程M把锁</h3><p>这个情境下，最经典的就是哲学家就餐问题。</p><p><strong>描述如下</strong>：</p><p>有5个哲学家在一张桌子前吃饭，在每个哲学家左手边放置一根筷子，哲学家拿起两根筷子才能吃饭，吃完饭才能把筷子放下。</p><img src="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20230912210928449.png" class title="image-20230912210928449"><p>如果某一时刻，某几个哲学家手快，拿起了两个筷子，那么这些哲学家就可以吃饭，吃完后放回筷子，然后竞争下一次。如果非常不巧，每个哲学家都抢到一根筷子，此时，所有人都没有两根筷子且此时所有人都持有一根筷子，每个哲学家都在等待别人将筷子放下，但是只有拿到两根筷子后才能放下筷子，这就陷入了死局。</p><hr><p>死锁是比较严重的bug，会导致线程卡住，无法执行后续的代码。</p><p>如何避免死锁的产生呢？**首先考虑产生的原因(4点)**。</p><p>1、**互斥使用(锁的基本特性，无法改变)**。即两个线程不能同时获得同一把对象锁，当一个线程获得这个对象锁的时候，另一个线程需要阻塞等待。</p><p>2、**不可抢占(锁的基本特性，无法改变)**。当一个线程获得这把对象锁后，另一个线程不能抢过来，只能等待释放这把锁才能去竞争。</p><p>3、**请求保持(可通过调整代码结构避免)**。一个线程可以拿到多把对象锁。即当一个线程获取到了锁1，再获取到了锁2，锁1不会立即释放。(吃着碗里的，看着锅里的)</p><p>4、**循环等待(可通过调整代码结构避免)**。如上述哲学家就餐问题，等待的依赖关系成环了。</p><p>要想出现死锁的情况，需要把上面的4个条件都占了，但其中的1和2是锁的基本特性不可避免，因此我们只需要针对3和4的情况。</p><p>对于条件3，避免编写“锁嵌套”，但这个有时候也无法避免。因此我们着重对条件4着手。</p><p>对于条件4，可以约定加锁的顺序，这样就可以避免循环等待。如：针对锁进行编号，加多把锁的时候，先加编号小的锁，再加编号大的锁。</p><p><strong>哲学家就餐问题解决方案</strong>：</p><img src="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20230912214923919.png" class title="image-20230912215451748"><p>我们规定，每个哲学都要遵守如下规定：选择左手和右手中编号较小的一根筷子，如果较小的那根筷子没了，那就等待出现编号小的筷子再进行竞争。这样优化以后，就不会出现僵持的现象了。</p><h1 id="四、-volatile"><a href="#四、-volatile" class="headerlink" title="四、 volatile"></a>四、 volatile</h1><h3 id="4-1-案例引入"><a href="#4-1-案例引入" class="headerlink" title="4.1 案例引入"></a>4.1 案例引入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo01</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">Quit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(Quit == <span class="hljs-number">0</span>)&#123;<br><br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;退出成功&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;请输入Quit的值:&quot;</span>);<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            Quit = sc.nextInt();<br>        &#125;);<br><br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，当我们通过线程2来修改Quit的值变为1时，此时线程1并没有退出输出“退出成功”，而是依然还在运行。</p><img src="/2023/09/18/JavaEE-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/image-20230913100049705.png" class title="image-20230913100049705"><p>此处的问题就是”内存可见性“引起的，其实是编译器优化错了。</p><h3 id="4-2-内存可见性"><a href="#4-2-内存可见性" class="headerlink" title="4.2 内存可见性"></a>4.2 内存可见性</h3><p><strong>为什么会有内存可见性？</strong></p><p>这是因为在计算机运算代码的时候，要经常访问数据，而这些数据存储在内存中，cpu使用这个变量的时候，就会把到内存中取出这个数，放到寄存器上，然后进行计算，但是<strong>读内存的速度相较于读寄存器慢了几千倍</strong>，如果要频繁的读内存的话会大大降低效率，因此<strong>编译器为了解决频繁读内存的问题，就对代码进行了优化，把一些本来要读取内存的操作优化成读取寄存器</strong>，从而使整体效率提升了。</p><p>对于上述案例，因为线程1的循环体内没有做任何事情，因此循环的速度非常快，但每一次循环的时候，都需要读取内存中Quit的值到寄存器中，编译器发现你老是读取这个值，然后这个值还一直没有修改，而每一次读都非常浪费时间，于是编译器就做了一个大胆的决定，不再从内存中读取了，而是直接从寄存器中拿值比较，于是后面的修改只是修改了内存中的值，实际比较的时候并没有改变。</p><hr><p>这种情况下就得使用volatile来修饰Quit。在多线程环境下，编译器对于优化的判定不一定准确，此时就需要程序猿通过volatile关键字，告诉编译器不要进行优化。</p><h1 id="五、-wait和notify"><a href="#五、-wait和notify" class="headerlink" title="五、 wait和notify"></a>五、 wait和notify</h1><p>在多线程编程中，我们往往会涉及到多个线程间的配合调用。前面所提到join方法可以使线程阻塞，但得等到某个线程执行完后，才能解除阻塞，继续执行，而通过使用wait方法，可以手动阻塞某个线程，然后通过notify方法手动再让线程继续执行。</p><h3 id="5-1-wait"><a href="#5-1-wait" class="headerlink" title="5.1 wait"></a>5.1 wait</h3><p>wait方法的作用是：让当前调用的线程进入等待状态，直到其他线程调用notify方法。</p><p>wait方法是Object的方法，因此任何对象都有wait方法。</p><p>在执行wait方法的时候，会做3件事情。</p><ul><li>1、释放当前锁(如果当前线程没有进行加锁操作会报错)</li><li>2、让当前线程进入阻塞状态</li><li>3、当线程被唤醒的时候，尝试重新获取这把锁</li></ul><h3 id="5-2-notify"><a href="#5-2-notify" class="headerlink" title="5.2 notify"></a>5.2 notify</h3><p>notify方法是用来唤醒等待的线程。有以下3点需要值得注意：</p><ul><li>1、notify方法<strong>需要在synchronized代码块中调用</strong></li><li>2、notify方法调用完后，<strong>当前线程不会立马释放对象锁</strong>，而是等到执行notify方法的线程执行完所有代码后才会去释放对象锁</li><li>3、如果有对个线程等待，会<strong>随机挑选一个等待的线程唤醒</strong>。因此还提供了notifyAll方法，可以唤醒所有等待的线程。</li></ul><h3 id="5-3-线程饿死"><a href="#5-3-线程饿死" class="headerlink" title="5.3 线程饿死"></a>5.3 线程饿死</h3><p>假设现在有多个线程来竞争一把锁，第一次线程1抢到了这把锁，执行完代码后就释放了锁，然后进行下一次的锁竞争，恰巧第二、第三、第四………..第N次又抢到了这把锁(因为线程1已经在cpu上执行，没有调度的过程，更容易拿到锁)，但是线程1每一次拿到锁又不干嘛，就光竞争，最后就有可能导致某些关键的线程一直拿不到锁。我们称这种情况为“线程饿死”。</p><p>针对这种情况，我们可以使用wait和notify来解决。让线程在某个条件下调用wait，把资源让出来，不参与后续竞争。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-多线程案例</title>
    <link href="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/"/>
    <url>/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、阻塞队列"><a href="#一、阻塞队列" class="headerlink" title="一、阻塞队列"></a>一、阻塞队列</h1><h2 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h2><p>阻塞队列是在多线程代码中常用的一种数据结构，也具有”先进先出”的原则。与普通队列相比，阻塞队列是一种线程安全的队列，并且具有如下特性：</p><p>1、当<strong>阻塞队列为空</strong>时，继续<strong>出队</strong>，不会抛出异常，而是会<strong>阻塞等待</strong>，直到其他线程往队列中添加元素为止。</p><p>2、当<strong>阻塞队列为满</strong>时，继续<strong>入队</strong>，不会抛出异常，而是会<strong>阻塞等待</strong>，直到其他线程往队列中删除元素为止。</p><p>由于阻塞队列是一个数据结构，所以往往用来管理数据，典型的应用场景是”生产者消费者模型”。</p><h2 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h2><p>生产者消费者模型是一种用来协调多个线程的设计模式。生产者负责生产数据，消费者用来消耗数据。</p><p>生产者与消费者之间通过一个阻塞队列来维护数据，即生产者将生成的数据放进阻塞队列中，消费者从阻塞队列中取数据，阻塞队列可以控制数据的流量，防止资源的过度消耗或浪费。</p><p><strong>生产者消费者模型的意义</strong>：</p><p><strong>1、解耦合</strong></p><p>耦合指的是两个不同的模块，如果联系紧密(一个模块的修改会影响另一个模块)，则称耦合度高。生产者消费者模型通过使用阻塞队列，生产者A不直接与消费者B联系，而是通过阻塞队列，此时耦合就降低了，如果后续增加了一个消费者C，生产者A不需要进行修改，而是只需让消费者C从阻塞队列中取数据即可~</p><p><strong>2、削峰填谷</strong></p><p>在实际生活中，有一些特定的场景，例如”学校抢课”，服务器会在某一时刻收到大量请求，如果直接处理这些请求，服务器可能会扛不住(在处理的某些环节中，可能比较脆弱，如：数据库操作)，这时候就可以把这些请求放到阻塞队列中，后续让消费者线程慢慢的处理。</p><hr><h2 id="标准库中内置的阻塞队列"><a href="#标准库中内置的阻塞队列" class="headerlink" title="标准库中内置的阻塞队列"></a><strong>标准库中内置的阻塞队列</strong></h2><p>1、BlockingQueue是一个接口，实现的类是ArrayBlockingQueue和LinkedBlockingQueue，即底层有链表和数组实现的类。</p><p>2、put方法用于阻塞式的入队了，take方法用于阻塞式出队列，offer、poll方法不带有阻塞特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.BlockingQueue;<br><span class="hljs-keyword">import</span> java.util.concurrent.LinkedBlockingQueue;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>        blockingQueue.put(<span class="hljs-string">&quot;hello&quot;</span>);<br>        <span class="hljs-keyword">while</span>(!blockingQueue.isEmpty())&#123;<br>            System.out.println(blockingQueue.take());<br>        &#125;<br>        <span class="hljs-comment">//程序阻塞</span><br>        blockingQueue.take();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>阻塞队列的使用与普通队列类似，注意使用put和take方法即可~</p><h2 id="模拟实现阻塞队列"><a href="#模拟实现阻塞队列" class="headerlink" title="模拟实现阻塞队列"></a><strong>模拟实现阻塞队列</strong></h2><p>首先实现一个循环队列，然后对put和take方法注入阻塞等待的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBlockingQueue</span>&#123;<br>    <span class="hljs-comment">//浪费一个空间，来区分满与空</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">2</span> + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String s)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">while</span>((tail + <span class="hljs-number">1</span>) % data.length == head)&#123;<br>                <span class="hljs-comment">//如果队列满了，就会阻塞</span><br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125;<br>            <span class="hljs-comment">//队列不满，插入元素</span><br>            data[tail] = s;<br>            tail = (tail + <span class="hljs-number">1</span>) % data.length;<br>            <span class="hljs-comment">//唤醒take中wait的线程</span><br>            <span class="hljs-built_in">this</span>.notify();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;<br>            <span class="hljs-keyword">while</span>(head == tail)&#123;<br>                <span class="hljs-comment">//如果队列为空，阻塞等待</span><br>                <span class="hljs-built_in">this</span>.wait();<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> data[head];<br>            head = (head + <span class="hljs-number">1</span>) % data.length;<br>            <span class="hljs-comment">//唤醒put中wait的线程</span><br>            <span class="hljs-built_in">this</span>.notify();<br>            <span class="hljs-keyword">return</span> ret;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">MyBlockingQueue</span> <span class="hljs-variable">myBlockingQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBlockingQueue</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                myBlockingQueue.put(<span class="hljs-string">&quot;1&quot;</span>);<br>                myBlockingQueue.put(<span class="hljs-string">&quot;1&quot;</span>);<br>                myBlockingQueue.put(<span class="hljs-string">&quot;1&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                System.out.println(myBlockingQueue.take());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;);<br>        t2.start();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>这份代码有一个地方值得注意：put方法中是否需要循环判断队列是否已满？</strong></p><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230918202907725.png" class title="image-20230918202907725"><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230918203518563.png" class title="image-20230918203518563"><p>所以使用wait的时候，需要注意当前wait唤醒的时候，是通过notify唤醒的还是通过interrupt唤醒的，如果是通过notify唤醒的，说明别的线程已经删除了元素，队列不可能为满，如果是interrupt唤醒的，队列可能还满着呢，需要继续判断。因此使用while循环判断的话，就可以保证队列一定是不为满。</p><p><strong>总结：使用wait的时候，往往都是使用while作为条件判定的方式，目的是为了让wait唤醒后的线程再确定一次，是否满足条件。上述while循环写法，也是官方文档的建议。</strong></p><h1 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h1><p><a href="https://smarmot666.github.io/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">设计模式-单例模式 - 机智的土拨鼠 (smarmot666.github.io)</a></p><h1 id="三、定时器"><a href="#三、定时器" class="headerlink" title="三、定时器"></a>三、定时器</h1><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><strong>定时器是一种非常常用的组件，约定好某一时间，时间到达后，开始执行某些代码</strong>(在网络通信中经常出现)。</p><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230919154600704.png" class title="image-20230919154600704"><hr><p>在java库中内置了一个Timer类，里面有一个核心方法schedule方法。</p><p><strong>schedule方法包含了两个参数，第一个是指定要即将执行的任务代码，第二个是指定多久后执行。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Timer;<br><span class="hljs-keyword">import</span> java.util.TimerTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br>        timer.schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行定时器任务&quot;</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>TimeTask是一个抽象类，实现了Runnable接口</strong>，所以需要进行重写run方法，通过run方法描述任务的详细情况。</p><p>主线程在执行schedule方法时，会把这个任务放到timer对象，而<strong>在timer对象内部包含了一个”扫描线程”，一旦时间到了，扫描线程就会执行刚才安排的任务</strong>。(主线程的结束，并不会影响扫描线程~)</p><h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>分析：</p><p>1、首先需要一个类来描述任务以及什么时候执行任务。</p><p>2、然后在Timer中需要一个线程，循环判断是否有任务已经到达时间了。</p><p>3、最后选择某个数据结构用来管理多个任务，由于一定是时间小的先执行，那么可以使用一个优先队列。</p><hr><p>如何描述每个任务？通过创建一个类，这个类中包含一个Runnable属性(描述任务)，和一个执行任务时间的属性time(在这使用绝对时间)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimerTask</span>&#123;<br>    <span class="hljs-comment">//通过重写run，描述执行的任务</span><br>    <span class="hljs-keyword">private</span> Runnable runnable;<br>    <span class="hljs-comment">//执行任务的时间，这里使用绝对时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>        <span class="hljs-comment">//传入的是相对时间,这里计算绝对时间</span><br>        <span class="hljs-built_in">this</span>.time = System.currentTimeMillis() + time;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来创建Timer类，在Timer类中需要加入一个schedule方法，来添加任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimer</span>&#123;<br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;MyTimerTask&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span>&#123;<br>        priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTimerTask</span>(runnable, time));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//描述线程</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <br>        &#125;);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于优先队列会进行比较的操作，所以我们需要让MyTimerTask类实现一下Comparable接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;MyTimerTask&gt;&#123;<br>    <span class="hljs-comment">//通过重写run，描述执行的任务</span><br>    <span class="hljs-keyword">private</span> Runnable runnable;<br>    <span class="hljs-comment">//执行任务的时间，这里使用绝对时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>        <span class="hljs-comment">//传入的是相对时间,这里计算绝对时间</span><br>        <span class="hljs-built_in">this</span>.time = System.currentTimeMillis() + time;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyTimerTask o)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (<span class="hljs-built_in">this</span>.time - o.time);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过前面分析，Timer中应该有一个while循环，一直扫描是否有任务到时间该执行了，不过我们还要<strong>对还未添加任务的情况处理</strong>，跟之前的阻塞队列类似，<strong>我们可以让程序先阻塞着，直到添加了任务在进行执行，此时就需要用到wait方法</strong>，再进一步发现，在多线程的应用场景下，<strong>schedule方法和构造方法可能会同时对队列进行修改操作，因此我们还需要加锁。</strong></p><p><strong>完整代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.PriorityQueue;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;MyTimerTask&gt;&#123;<br>    <span class="hljs-comment">//通过重写run，描述执行的任务</span><br>    <span class="hljs-keyword">private</span> Runnable runnable;<br>    <span class="hljs-comment">//执行任务的时间，这里使用绝对时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimerTask</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span> &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>        <span class="hljs-comment">//传入的是相对时间,这里计算绝对时间</span><br>        <span class="hljs-built_in">this</span>.time = System.currentTimeMillis() + time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getTime</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> time;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Runnable <span class="hljs-title function_">getRunnable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> runnable;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(MyTimerTask o)</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) (<span class="hljs-built_in">this</span>.time - o.time);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTimer</span>&#123;<br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;MyTimerTask&gt; priorityQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Object</span> <span class="hljs-variable">locker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(Runnable runnable, <span class="hljs-type">long</span> time)</span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>            priorityQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MyTimerTask</span>(runnable, time));<br>            locker.notify();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyTimer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//扫描线程，需要不停的扫描队首元素，看是否到达时间</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>                <span class="hljs-keyword">synchronized</span> (locker)&#123;<br>                    <span class="hljs-comment">//如果当前没有任务，阻塞等待</span><br>                    <span class="hljs-keyword">while</span>(priorityQueue.isEmpty())&#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            locker.wait();<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                    &#125;<br>                    <span class="hljs-comment">//判断是否到执行时间了</span><br>                    <span class="hljs-type">long</span> <span class="hljs-variable">curTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                    <span class="hljs-type">MyTimerTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> priorityQueue.peek();<br>                    <span class="hljs-keyword">if</span>(curTime &gt;= task.getTime())&#123;<br>                        <span class="hljs-comment">//执行完任务，并删除队首元素</span><br>                        task.getRunnable().run();<br>                        priorityQueue.poll();<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">//如果还没有到时间，怎让线程阻塞等待</span><br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-comment">//可以不做等待处理，但是会让线程一直去查看当前是否到达执行时间</span><br>                            <span class="hljs-comment">//会浪费cpu资源，可以让其阻塞至指定时间</span><br>                            locker.wait(task.getTime() - curTime);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、线程池"><a href="#四、线程池" class="headerlink" title="四、线程池"></a>四、线程池</h1><h2 id="为什么要有线程池？"><a href="#为什么要有线程池？" class="headerlink" title="为什么要有线程池？"></a><strong>为什么要有线程池？</strong></h2><p>首先我们需要知道为什么要使用多线程而不使用多进程呢？这是因为进程创建太过重量,当需要频繁销毁&#x2F;创建的时候, 就不能忽视这些资源开销了。而线程依赖与进程，多个线程共享同个进程的资源，不过线程的创建&#x2F;销毁也会消耗一定的资源(相比进程少)，因此到达一定程度，这些开销也不能忽视了!!!</p><h2 id="两种解决方案："><a href="#两种解决方案：" class="headerlink" title="两种解决方案："></a><strong>两种解决方案：</strong></h2><p><strong>1、使用协程</strong></p><p>协程相比于线程来说，更加轻量级，因为协程把系统调度的过程给省略了，程序猿可以手动调度。不过在Java中，标准库没有协程，只有一些第三方库中有，但第三方库靠不靠谱？使用协程更多的是Go和Python。</p><p><strong>2、使用线程池</strong></p><p>在计算中”池”是一个重要的思想方法，例如：线程池、进程池、内存池…….</p><p>大致思想就是，一次多创建几个线程，后续要用到的话，直接从池子里取出来，可为什么从池子里取出就比重新创建效率高呢？</p><p><strong>原因</strong>：</p><p>在计算机工作中，操作系统会在”内核态”和”用户态”两种状态来回切换，<strong>创建一个新的线程，就需要调用系统API，让操作系统的内核去完成，而操作系统内核是需要给所有的进程提供服务的，可能并不会马上回应你，这是不可控的</strong>，可能操作系统花费了很多时间才来理睬捏。但如果是<strong>从线程池中取出一个线程，这个操作是只需要”用户态”来完成，程序立马就能去执行，这是可控的。</strong></p><h2 id="标准库中的线程池"><a href="#标准库中的线程池" class="headerlink" title="标准库中的线程池"></a>标准库中的线程池</h2><p><strong>简单使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.ThreadPoolExecutor;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Demo1</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <br>        service.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;111&quot;</span>);<br>        &#125;);<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里线程池对象不是直接new出来的，而是通过一个专门的方法，返回了一个线程池对象。(在这使用到了一个<strong>设计模式——工厂模式</strong>)。</p><p>在这使用了Executors.newFixedThreadPool方法，可以创建一个固定包含10个线程的线程池，其返回值类型是ExecutorService，通过调用里面的submit方法，可以将一个任务放到线程池中。</p><hr><p><strong>Executors创建线程池有这几种方式</strong>：</p><ul><li>newFixedThreadPool: 创建固定线程数的线程池.</li><li>newCachedThreadPool: 创建线程数目动态增长的线程池.</li><li>newSingleThreadPool: 创建单个线程的线程池.</li><li>newScheduleThreadPool: 设置延迟时间后执行命令，或者定期执行命令.</li></ul><p>上述的几个工厂方法生成的线程池，本质上是Executors类对ThreadPoolExecutor类的封装。</p><hr><p><strong>ThreadPoolExecutor中的重要的方法就两个</strong>：</p><ol><li>构造方法</li><li>submit方法(注册任务)</li></ol><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230922152359084.png" class title="image-20230922152359084"><p><strong>参数含义</strong>：</p><ul><li>int corePoolSize：表示核心线程数(线程池中可以摸鱼的线程数目)。</li><li>int maxiumPoolSize：表示线程池中最大线程的个数。</li><li>long keepAliveTime：表示非核心线程可以摸鱼的时间，一到时间就会销毁。</li><li>TimeUnit unit：表示keepAliveTime的时间单位。</li><li>BlockingQueue<Runnable> workQueue：表示用来维护任务的容器，但必须为阻塞队列或其子类(优先阻塞队列)。</Runnable></li><li>ThreadFactory threadFactory：使用某个工厂对象，线程由这个对象创建。使用工厂类是为了在创建过程中对线程属性做一些修改。</li><li>RejectedExecutionHandler handler：线程池的拒绝策略，一个线程池中线程数达到了最大容量，当继续往线程池中添加任务，的话就需要采用某种策略来处理。</li></ul><hr><p><strong>线程池拒绝策略：</strong></p><img src="/2023/09/18/JavaEE-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A1%88%E4%BE%8B/image-20230922155648608.png" class title="image-20230922155648608"><ul><li>AbortPolicy：直接抛出异常。(摆烂~老子不干了！！)</li><li>CallerRunsPolicy：新添加的任务，由添加任务的那个线程执行。(假装没听到~~依旧是自己干)</li><li>DiscardOldestPolicy：丢弃任务队列中最老未被执行的任务。(放弃很久之前没做的事，将任务添加进来)</li><li>DiscardPolicy：丢弃当前新加的任务。(任务都别干了)</li></ul><hr><p><strong>如果使用newFixedThreadPool方法来构建线程池的话，初始构建多少个合适？根据cpu核心数设置？</strong></p><p><strong>应当根据实际项目来设置。</strong>在一个线程中，执行的代码主要有两类：第一类为<strong>cpu密集型</strong>，在代码中主要进行算术运算&#x2F;逻辑判断，另一类为<strong>IO密集型</strong>，在代码中主要进行IO操作。</p><p>假设一个线程的代码都是cpu密集型，这个时候线程池中的个数不应该超过cpu的核心数，此时如果超过了，也无法进一步提高效率了，反而回应为太多线程影响调度开销。</p><p>假设一个线程的代码都是IO密集型，这个时候不吃cpu，设置的线程数就以超过N，一个核心可以通过调度来执行并发。</p><p>所以需要根据实际需求，进行多轮测试的方式，来找到最佳的线程池的线程数目。</p><h2 id="模拟实现-1"><a href="#模拟实现-1" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>在这就实现一个最简单的线程池(固定个数，不使用工厂模式)</p><p><strong>要点</strong>：</p><ul><li>线程池中核心的操作时submit方法，将线程添加到线程池中。</li><li>由于有多个线程任务，考虑使用阻塞队列来管理这些任务。</li></ul><p><strong>实现代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThreadPool</span>&#123;<br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable runnable)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        queue.put(runnable);<br>    &#125;<br>    <br>    MyThreadPool(<span class="hljs-type">int</span> n)&#123;<br>        <span class="hljs-comment">//创建n个线程，如果没有任务，则阻塞等待</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//如果没有任务，让线程阻塞等待</span><br>                    <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> queue.take();<br>                    runnable.run();<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125;<br>            &#125;);<br>            t.start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JavaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>设计模式———单例模式</h1><p>单例也就是只能有一个实例，即只创建一个实例对象，不能有多个。</p><p>可能会疑惑，那我写代码的时候注意点，只new一次不就得了。理论上是可以的，但在实际中很难实现，因为你无法预料到后面是否会脑抽一下~~因此我们就可以<strong>通过编码技巧，让编译器来帮助我们检查约束。</strong></p><p>单例模式又分为两种：<strong>饿汉式和懒汉式</strong>，<strong>区别在于实例对象创建的时机不同</strong>。</p><h2 id="0x00-饿汉式">0x00 饿汉式</h2><p>说到饿汉，那一定是很饥饿的人，很急切，也就是说这个实例对象创建的时机比较早，在类加载的时候就创建了。</p><p><strong>要点</strong>：</p><ul><li>1、由于创建时机较早，设置为静态即可在类加载的时候就可以创建实例对象</li><li>2、由于只能创建一个实例对象，因此将构造函数私有化</li><li>3、对外提供一个获取实例对象的静态类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Singleton</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>     <span class="hljs-keyword">private</span> <span class="hljs-title function_">Singleton</span><span class="hljs-params">()</span>&#123;<br>         <br>     &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="0x01-懒汉式">0x01 懒汉式</h2><p>懒汉，顾名思义，很懒，比较缓慢，也就是说这个实例对象是在使用到的时候才去创建。</p><p><strong>要点</strong>：</p><ul><li>1、一开始设置为null，直到在使用的时候再去new实例对象</li><li>2、由于只能创建一个实例对象，因此将构造函数私有化</li><li>3、对外提供一个获取实例对象的静态类方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingletonLazy</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="0x02-单例模式与多线程">0x02 单例模式与多线程</h2><p>众所周知，许多在单线程环境下的代码一到多线程环境下就会出错，在此将对单例模式在多线程下的编写进行调整优化~</p><p>先来看看饿汉式的代码，我们发现这个实现的方式是在类加载的时候就去实例化对象了，而后续在多线程中掉用getInstance方法来获取实例对象的时候，只会进行返回操作，即”<strong>只读”</strong>，<strong>因此多个线程在操作的时候是安全的</strong>。</p><img src="/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230913211123788.png" class><p>再来看看懒汉式，可以发现在调用getInstance方法的时候，会进行修改操作，<strong>如果恰巧有两个线程同时进入了if，然后就会进行new操作，那不就创建了多个实例对象了</strong>，如果恰巧每个对象不是很轻量，可能有很多属性，加载了几十G的数据到内存中…</p><img src="/2023/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/image-20230913211530808.png" class><p>因此解决方法是进行加锁操作，<strong>保证if和new操作是原子的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingletonLazy</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">synchronized</span>(SingletonLazy.class)&#123;<br>            <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样修改以后，就能保证if和new操作是一个整体，此时线程的安全问题就得到了改善。</p><p><strong>但是这样写是否就真的完了呢？</strong></p><p>答案：不是。因为我们是单例模式，所以只需要new一次之后，实例对象就不可能是null了，后续直接return对象就行了。<strong>假如我们现在已经创建好了一个对象，当后续有多个线程去调用getInstance方法的时候，需要去获取到这把锁才能进行返回操作，也就是我们的多线程变成了串行化，并发程度几乎没了</strong>~</p><p>那是否有办法，既可以保证代码线程安全，又不会对执行效率产生大的影响呢？</p><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">SingletonLazy</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(SingletonLazy.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>与前面的代码对比，可以发现，在外层多加了一个if语句。</p><p><strong>分析</strong>：</p><p>当有多个线程进入了第一个if语句，此时里面有一个加锁操作，这样可以保证只创建了一个实例对象。假设此时已经创建好了一个实例对象了，当下一次又有多个线程进来时，由于instance不为null，直接返回了，并不会进入到加锁操作，此时并发并没有再受到影响了，既保证了正确又保证了效率。</p><p><strong>总结</strong>：</p><p><strong>在锁外面的if语句保证了是否要进行加锁操作，即如果还没有创建实例对象，此时线程由于需要进行修改操作要进行加锁才能保证安全，如果已经创建了实例对象，此时线程安全了就不用加锁了。</strong></p><p><strong>在锁里面的if语句是来保证只创建一个实例对象。</strong></p><h2 id="0x03-指令重排序">0x03 指令重排序</h2><p>上述代码其实还不够安全，还存在指令重排序的问题。</p><p><strong>指令重排序，本质是编译器为了提高执行效率，调整原有的代码执行顺序(前提是保持逻辑不变)。</strong></p><p>接下来具体问题具体分析：</p><p>上述的代码中，出现了一个new操作，而new操作其实是分三步的，第一步，申请内存空间，第二步，在内存空间上构造对象，第三步，把内存地址赋值给对象引用。一般是按照1,2,3的顺序执行的，但是编译器优化过后，可能会按照1,3,2的顺序执行，在单线程环境下都可以，但是在多线程环境下则不是。如果线程1是按照1,3,2顺序执行完了3后，线程2此时返回了这个实例对象，但是此时这个对象还没有初始化呢，也就是说这是个非法对象，当我们的线程2去访问这个对象的属性或方法时，此时就是非法，会出错。此时我们还需要再对instance加一个限制操作，即用volatile来修饰instance。</p><p><strong>最终代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingletonLazy</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">SingletonLazy</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SingletonLazy <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">synchronized</span>(SingletonLazy.class)&#123;<br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-literal">null</span>)&#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SingletonLazy</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">SingletonLazy</span><span class="hljs-params">()</span>&#123;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>至此，这段“健壮”的代码基本可以满足使用了~</p>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaEE-线程引入</title>
    <link href="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/"/>
    <url>/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、计算机的组成</h1><p><strong>1、CPU</strong>：中央处理器，一台电脑最核心的部分，通过指令来完成各种算术运算和逻辑判断，是人类科技巅峰之作</p><p><strong>补充</strong>：</p><p><strong>cpu虽然技术门槛非常高</strong>，但是很<strong>便宜</strong>，这是因为<strong>cpu每年都在更新换代</strong>，并且<strong>每一代cpu的提升幅度都比较大</strong>，因此并不保值。intel的创始人之一提出了一个<strong>摩尔定律</strong>：集成电路上可容纳的晶体管数量每隔大约18至24个月就会翻倍，从而导致芯片性提升接近一倍，同时成本也下降一半。</p><p>在cpu中还有<strong>寄存器</strong>，用于<strong>暂时存储指令，操作数和中间结果</strong>，寄存器的<strong>存储空间更小</strong>，<strong>访问速度更快</strong>(相比于内存)，大概相差3-4个数量级，因此为了协调工作，cpu又引入了“缓存”来协调 寄存器 和 内存 之间的速度。</p><p><strong>2、存储器</strong>：分为内存和外存。</p><p><strong>内存：速度快，空间小，成本高，不能持久保存</strong></p><p><strong>外存：速度慢，空间大，成本小，可持久保存</strong></p><p>这里说的快和慢是内存和外存相对而言的~</p><p><strong>3、输入设备</strong>：键盘、鼠标、摄像头…</p><p><strong>4、输出设备</strong>：显示器、打印机、扬声器…</p><h1>二、操作系统</h1><h2 id="0x00-什么是操作系统">0x00 什么是操作系统</h2><p>市面上存在着许多的操作系统，如：<strong>Windows11，linux，mac os， android，ios</strong>…</p><p>这些操作系统，需要<strong>对下管理硬件设备，对上提供稳定的运行环境</strong></p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815091501568.png" class title="image-20230815091501568"><p>由于操作系统毕竟只是一个软件，不可能识别所有硬件设备，不过硬件设备就这么几个大类，因此操作系统只要知道每个大类中有什么功能，然后硬件产商在开发硬件的同时开发一个驱动程序(软件)，让操作系统通过这个驱动程序完成对硬件设备的控制。可以这么理解：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815091420684.png" class title="image-20230815091420684"><h2 id="0x01-进程-任务">0x01 进程/任务</h2><p>一个运行起来的程序就叫做进程。每个进程要想运行，就需要消耗一定的系统资源。因此<strong>进程是系统资源分配的基本单位。</strong></p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815092300478.png" class title="image-20230815092300478"><h2 id="0x02-管理进程">0x02 管理进程</h2><p>一个操作系统上可能跑了很多进程，那如何对这些进程管理呢？两方面：描述、组织</p><p>1、<strong>使用类来描述一个进程</strong>，把管理的每个对象都用属性表示出来</p><p>2、<strong>使用数据结构组织这些进程对象</strong>，类似于双向链表，方便创建、销毁</p><p>在系统中专门有一个结构体(操作系统内核是c/c++写的，java中结构体相当于类)来描述进程的属性，这个结构体叫做**“进程控制块”PCB**。</p><hr><p>PCB时一个非常庞大的结构体，包含很多的属性，在这就讨论一些比较重要的属性。</p><p><strong>1、pid：</strong></p><p><strong>进程的身份标识</strong>，每一个进程都会有一个pid，同一时刻，不同进程之间的pid是不同的。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815093901192.png" class title="image-20230815093901192"><p><strong>2、内存指针</strong></p><p><strong>描述了进程持有的“内存资源“</strong>，每个进程运行的时候，都会分配一定的内存空间。这个进程的内存空间，具体在哪，分配的内存空间有哪些部分，每个部分是干啥的，有这么一组指针来进行区分。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815093901192.png" class title="image-20230815095135867"><p><strong>3、文件描述符</strong></p><p><strong>描述了进程持有的“硬盘资源”</strong>，类似于顺序表这样的数据结构，有很多元素。如果一个进程涉及到了文件操作，保存数据啥的，就需要与硬盘挂钩，于是需要通过文件读写的方式来操作，将硬盘上的数据修改/读取。</p><hr><p>我们都知道一个程序的运行离不开cpu的运转，也就是说<strong>每个进程都需要消耗cpu资源</strong>，那<strong>怎么体现cpu资源</strong>呢？答案：<strong>进程的调度</strong>。</p><p>早期的操作系统，是一个“<strong>单任务操作系统</strong>”，<strong>同一时刻只有一个进程能运行</strong>，运行下一个进程就会退出当前进程，此时就不需要考虑调度问题，但随着发展，后面都支持<strong>多任务</strong>了，那如何运行这多个进程呢？——<strong>分时复用</strong>！</p><p>假设<strong>cpu是单核</strong>，如果使用分时复用的方法，就是<strong>将1s分成许多份，每个进程获取其中的一份或者多份，cpu在这一份的时间内执行这个进程</strong>。这样的执行方式叫作<strong>并发执行</strong>，只要我们时间<strong>轮转的够快</strong>(分成的份数够多)，此时看起来就像是同时执行一样(<strong>宏观上是同时执行的，微观上是分时复用</strong>)。</p><p>现代的<strong>cpu都是多个核心</strong>了，此时我们可以在同一时刻使用两个核心执行进程，这种执行方式叫做并行执行，也就是说<strong>在微观上也是同时执行的</strong>。</p><p>不过在应用层，我们感知不到是并发还是并行，其内部都是通过系统调度来选择的。平时普通的程序员也不会去具体区分是并发还是并行，因此<strong>常常使用“并发”来代指并行和并发</strong>。</p><p>那<strong>操作系统如何进行进程调度呢</strong>？通过如下属性~</p><hr><p><strong>4、进程的状态</strong></p><p>表示进程的状态，如就绪、运行、阻塞等，以指导操作系统的调度决策。</p><p><strong>就绪状态</strong>：进程准备好运行，只等待操作系统分配处理器时间。</p><p><strong>阻塞状态</strong>：进程某种执行条件不具备，导致这个进程暂时无法参与cpu的调度执行。例如：进程等待用户输入…</p><p><strong>运行状态</strong>：进程当前正在cpu上执行其指令，正在占用cpu资源，以完成其所需的计算和任务。</p><p><strong>5、进程的优先级</strong></p><p>操作系统在调度多个进程的时候并非一视同仁，有的进程会给更高的优先级，优先执行。例如：接受QQ消息，晚个几秒钟也没啥关系。</p><p><strong>6、进程的上下文</strong></p><p>进程从cpu离开之前，需要保存当前数据，把当前cpu中寄存器的状态都记录到内存中，等到下次进程回到cpu上执行的时候，再把保存的值恢复回去，进程就沿着上次执行到的位置继续执行，类似于游戏打了一半，然后去吃饭了，等下次继续的时候，读取数据恢复到上次的关卡。</p><p><strong>补充：</strong></p><p>CPU中有些寄存器没有特殊含义，只是用来保存运算的中间结果，还有些寄存器是有特定含义的。</p><p><strong>1、程序计数器</strong></p><p>存储的是一个内存地址，用来保存当前执行到哪个指令(可以理解为指针)。一个进程在运行的时候，操作系统会将里面的指令和数据加载到内存中并形成地址，然后CPU就会从内存中通过查询地址的方式找到指令并执行指令。</p><p><strong>2、维护栈相关的寄存器</strong></p><p>程序在调用函数的时候会创建栈帧，而栈是一块空间，通过维护头和尾就可以知道个空间的位置，大小。如：ebp寄存器是存储的地址是栈底，esp寄存器存储的是栈顶，通过修改esp的值就可以实现“入栈”，”出栈“操作。</p><p><strong>3、其他的通用寄存器</strong></p><p>一般是用来保存计算的中间结果。如：当前有一个表达式, 10+20+30+40,假设现在算完了前面两项的和，但还没来得及算后面的，此时进程调度走了，就需要将保存计算的前面两项的和的寄存器的值备份到上下文中。</p><p><strong>7、进程的记账信息</strong></p><p>通过优先级的机制，对不同的进程分配了不同权重的资源，不过有可能会出现极端的情况，将所有资源都分配给了某个进程，其他进程没有分配到，通过记账信息记录当前进程在cpu的执行情况(执行时间)，然后<strong>操作系统可以参考记账信息来进行下一次的调度进程</strong>。</p><h2 id="0x03-虚拟内存空间">0x03 虚拟内存空间</h2><p><strong>早期的操作系统，程序运行时分配的内存就是“物理内存”</strong>，这样就会导致，我的A程序通过某种方式访问到B程序的内存空间，然后进行修改，这就有可能会使B程序崩溃，为了防止这种情况，就<strong>引入了“虚拟内存空间”</strong>。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230815095135867.png" class title="image-20230816211910788"><p>操作系统通过使用“虚拟内存地址”，不直接分配物理内存，而是分配虚拟的内存空间，类似哈希的思想，通过某个key来寻找value。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230816211910788.png" class title="image-20230816212757122"><p>此时进程A想要操作某个内存中的数据，先通过虚拟内存地址告诉操作系统，然后操作系统将虚拟内存翻译成物理内存地址，进行修改，在翻译的过程中，操作系统就可以进行校验操作，如果是非法访问就可以处理，不会危害到别的进程了，保持了进程的独立性，为进程提供稳定的运行环境。</p><h1>三、线程</h1><p>当今时代大部分电脑的cpu都已经是多核心的了，因此我们可以充分利用这个特点，进行并发执行多个任务，从而提高程序的执行效率。</p><p>进行并发编程可以从两个方面：<strong>多进程、多线程</strong>。</p><h2 id="0x00-多进程">0x00 多进程</h2><p>通过多进程实现并发编程效果非常理想，但是多进程模型会有明显的缺点：<strong>太重量、效率不高</strong>。(相比多线程)</p><p>这是因为<strong>进程是资源分配的基本单位</strong>，每个进程都有自己的内存空间和系统资源，这就导致<strong>创建一个进程需要去申请资源，销毁一个进程需要去释放资源</strong>。如果频繁的进行创建/销毁进程，这个时候，开销就不能忽视了~</p><h2 id="0x01-多线程">0x01 多线程</h2><p>在Java中，更加鼓励使用多线程编程，这样就能很好的解决上述问题。这是因为<strong>线程是“轻量级进程”</strong>，<strong>创建/销毁比进程更快</strong>。</p><p><strong>线程不能独立存在，而是依附于进程。一个进程可以包含一个线程，也可以包含多个线程</strong>。一个进程在最开始的时候，至少要有一个进程，也可以根据需要创建多个线程，从而实现并发编程。</p><p>一个进程中，可以有多个线程，<strong>每个线程都是可以独立的进行调度的</strong>，而调度是根据pcb属性来进行的，因此<strong>一个拥有多个线程的进程需要使用多个pcb</strong>(pid、内存指针、文件描述符表共用一份)来进行维护。</p><p>同<strong>一个进程的多个线程</strong>之间，由于<strong>共用一份内存空间和文件资源</strong>，创建线程的时候，<strong>不需要再重新申请资源了</strong>，直接复用之前操作系统分配给进程的资源，省去了<strong>资源分配的开销，提高了效率</strong>。</p><p><strong>总得来说就是：</strong></p><p>1、一个进程拥有一个或多个线程</p><p>2、每个线程使用一个pcb来表示，每个线程都可以独立的去CPU上调度执行，所以pcb中的状态、上下文、优先级、记账信息是独立的，线程是调度执行的基本单位。</p><p>3、pcb中的pid、内存指针、文件描述符表共用一份，所以创建线程的时候不需要再申请资源，创建的效率更高。</p><h2 id="0x-02-多线程的问题">0x 02 多线程的问题</h2><p>1、我们知道可以通过创建额外的线程来帮我们提升效率，假设我们的线程创建的非常多，此时还能进一步提高效率吗？肯定是不能的，反而会因为要调度的线程太多了，导致调度的开销太大，进而降低了效率。</p><p>2、如果两个线程同时去争抢某个资源，这就会引起冲突，导致线程不安全。</p><p>3、如果某个线程生气了，出现了异常，此时如果没有妥善的处理，就容易使整个进程崩溃。例如：在程序中越界了，你却没有catch。</p><h2 id="0x-03-进程与线程的区别">0x 03 进程与线程的区别</h2><p>1、进程包含线程，一个进程可以有一个或多个线程。</p><p>2、同一个进程的线程之间共用一份资源，不用再申请资源。</p><p>3、线程是资源分配的基本单位，进程是调度执行的基本单位。</p><p>4、进程和线程都是用来实现并发编程的，但是线程比进程更轻量、高效。</p><p>5、进程拥有独立性，一个进程挂了不会影响到别的进程。但一个进程内的线程挂了可能会影响到其他线程。</p><h1>四、多线程编程</h1><p>如何使用Java进行多线程编程？</p><p>线程是操作系统的概念，操作系统提供了一些API，可以用来操作线程，Java针对操作系统的API进行了封装，因此<strong>Java程序员只需要掌握一套API</strong>就可以&quot;到处运行&quot;了~~</p><h2 id="0x00-如何创建线程">0x00 如何创建线程</h2><p>在Java中通过创建Thread类对象(本质是重写run方法，调用start方法)，来进行多线程操作。如果我们要想自定义一个线程的话，我们需要继承Thread。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个<strong>线程跑起来，是从它的入口方法，也就是从run方法开始执行的</strong>，类似于一个<strong>Java程序的入口是main方法</strong>一样，只不过运行一个Java进程，会创建一个主线程，而<strong>主线程的入口是main方法</strong>。</p><p>我们观察源码会发现，Thread类实现了Runnable接口，而这个接口内部就定义了一个抽象的run方法。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822083331688.png" class title="image-20230822083331688"><p>所以，我们只需要重写一下run方法，在里面写线程的代码逻辑。不过重写了run方法只是定义了方法，要想真正<strong>启动一个线程，我们还需要调用start方法</strong>(在Thread类中定义了)。</p><p>线程，启动！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//当前线程执行的入口</span><br>        System.out.println(<span class="hljs-string">&quot;线程 启动！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>小结：</strong></p><p>start、run方法都是Thread的成员方法。<strong>run方法只是描述了线程的入口</strong>，该执行什么代码。<strong>start方法则是真正的调用了系统API，在系统中创建了线程，再让线程调用run方法</strong>。</p><h2 id="0x01-线程如何执行">0x01 线程如何执行</h2><p>现有如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//当前线程执行的入口</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;myThread线程在执行&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br><br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;main线程在执行&quot;</span>);<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">200</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822085201024.png" class title="image-20230822085201024"><p>通过观察，我们发现，<strong>在主线程开启一个线程的时候，主线程并不过阻塞</strong>，依旧会往下执行，而且线程执行的顺序也不是完全按照线程调用顺序，而是根据调度来决定。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822085820615.png" class title="image-20230822085820615"><hr><p>如果<strong>将调用start方法，改成调用run方法</strong>呢？</p><p>由于没有使用start方法，<strong>程序不会创建一个线程</strong>，而是去调用run方法，<strong>直到调用完run方法后，才会回来继续往下执行main方法</strong>。</p><hr><p>在多线程运行的时候，可以使用<strong>jconsole</strong>来观察到进程里的多线程情况。<strong>jconsole是jdk中的一个工具</strong>。</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230822090753214.png" class title="image-20230822090753214"><h2 id="0x02-线程的创建方式">0x02 线程的创建方式</h2><p>创建一个线程其实很简单，<strong>只需要你重写run方法(写自己的代码逻辑)，和调用start方法</strong>。而重写run方法可以通过继承Thread、实现Runnable接口、通过匿名内部类、使用lambda表达式…</p><p><strong>1、继承Thread类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        myThread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2、实现Runnable接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>        <span class="hljs-comment">//由于Runnable接口没有start方法，所以得通过Thread的构造方法来创建。</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myThread);<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、通过匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">//程序代码</span><br>            &#125;<br>        &#125;;<br>        thread.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4、基于lambda表达式</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        Thread thread =  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">//程序代码</span><br>        &#125;);<br>        thread.<span class="hljs-built_in">start</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1>五、Thread类及常用的方法</h1><h2 id="0x00-Thread类的构造方法">0x00 Thread类的构造方法</h2><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>Thread()</td><td>创建线程对象</td></tr><tr><td>Thread(Runnable target)</td><td>使用Runnable对象创建线程对象</td></tr><tr><td>Thread(String name)</td><td>创建线程对象，并命名</td></tr><tr><td>Thread(Runnable target, String name)</td><td>使用Runnable对象创建线程对象，并命名</td></tr><tr><td>Thread(ThreadGroup grop, Runnable target)</td><td>将线程分组管理</td></tr></tbody></table><h2 id="0x01-Thread的几个常用的属性">0x01 Thread的几个常用的属性</h2><table><thead><tr><th>属性</th><th>获取方法</th><th>说明</th></tr></thead><tbody><tr><td>ID</td><td>getId()</td><td>获取线程的身份标识符ID</td></tr><tr><td>名称</td><td>getName()</td><td>获取线程的名称</td></tr><tr><td>状态</td><td>getState()</td><td>获取线程的状态</td></tr><tr><td>优先级</td><td>getPriority()</td><td>获取线程的优先级</td></tr><tr><td>是否是后台线程</td><td>isDaemoin()</td><td>判断是否是后台线程</td></tr><tr><td>是否存活</td><td>isAlive()</td><td>判断是否存活</td></tr><tr><td>是否被中断</td><td>isInterrupte()</td><td>判断是否中断</td></tr></tbody></table><p><strong>补充</strong>：</p><p>1、<strong>ID是线程的身份标识</strong>，标识一个进程中的唯一线程，这个ID是Java给你分配的，并不是系统api提供的线程ID。</p><p>2、优先级，在理论上可以使优先级高的线程更容易被调度到，但站在应用程序的角度，很难察觉到。</p><p>3、后台线程，也叫做守护线程，与之对应的是前台线程。</p><p><strong>前台线程：当所有的前台线程执行结束后，进程才会结束执行</strong></p><p><strong>后台线程：后台线程的结束与否不会影响进程的结束。</strong></p><p>4、判<strong>断是否存活，是判断内核线程中是否还有，而不是判断Thread对象</strong>。Thread对象的生命周期往往比线程长，线程没了，Thread对象还在。</p><h2 id="0x02-中断一个线程">0x02 中断一个线程</h2><p>在C++中可以直接终止一个正在运行的线程，但是在Java中是不可以的，因此设计思路就是<strong>让这个线程中的run方法尽快的结束</strong>。如下：</p><p><strong>1、通过共享的标记，让线程退出</strong></p><p><strong>2、通过interrupt方法来中断线程</strong></p><p><strong>示例1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">Quit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span>(!Quit)&#123;<br>                System.out.println(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;);<br><br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <span class="hljs-comment">//手动设置退出</span><br><br>        Quit = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述方式是通过<strong>修改一个共享的变量，进行控制线程的运行的</strong>。但有如下缺点：</p><p>1、需要手动创建变量，比较麻烦。</p><p>2、当修改了变量，理应让线程立马去执行完剩下的代码，但如果线程此时sleep了，会到导致这个线程还要再睡一会，不符合我们的设计初衷(让线程尽快的执行结束)。</p><hr><p><strong>示例2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test2</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>           <span class="hljs-comment">//currentThread() 返回的是 哪个线程调用，就返回哪个线程对象</span><br>           <span class="hljs-comment">//isInterrupted() 判断是否中断</span><br>           <span class="hljs-keyword">while</span>(!Thread.currentThread().isInterrupted())&#123;<br>               System.out.println(<span class="hljs-string">&quot;线程正在工作&quot;</span>);<br>               <span class="hljs-keyword">try</span> &#123;<br>                   Thread.sleep(<span class="hljs-number">600</span>);<br>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                  e.printStackTrace();<br>               &#125;<br>           &#125;<br>        &#125;);<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        <span class="hljs-comment">//让线程中断</span><br>        thread.interrupt();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/2023/08/24/JavaEE%E5%88%9D%E9%98%B61/image-20230823113549767.png" class title="image-20230823113549767"><p>抛出了一个异常，这是因为这个线程在sleep，然后interrupt()唤醒了线程，这就触发了sleep的异常。</p><p>但我明明是<strong>让线程中断的，但是线程依然在工作</strong>，这是为什么呢？</p><p><strong>解释：</strong></p><p>sleep的线程被interrupt唤醒后，此时sleep方法会抛出异常，同时**将&quot;终止标识符&quot;清除(**在Thread对象内部有一个终止标识符，interrupt方法本质是通过设置终止标识符来退出程序的)。</p><p>为什么要这样设定？是因为<strong>Java期望当线程收到终止信号的时候，能够自己决定接下来如何处理</strong>。也就是说如果在catch中捕获到异常，程序员可以自己决定接下来要干嘛，如果没有捕获到，run方法尽快结束就行。</p><h2 id="0x03-线程等待">0x03 线程等待</h2><p>用来控制线程结束的顺序，让一个线程等待另一个线程执行结束，再继续执行。</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>join()</td><td>等待线程结束</td></tr><tr><td>join(long millis)</td><td>等待线程结束，最多等 millis 毫秒</td></tr><tr><td>join(long millis, int nanos)</td><td>等待线程结束，精度可以达到纳秒</td></tr></tbody></table><p><strong>说明：</strong></p><p>thread.join() 工作过程：<strong>如果thread线程正在运行，那调用join的线程就会阻塞，一直阻塞到thread线程执行结束，如果thread线程已经执行结束了，调用join的线程就不会阻塞，直接继续执行</strong>。</p><h2 id="0x04-线程状态">0x04 线程状态</h2><table><thead><tr><th>状态</th><th>说明</th></tr></thead><tbody><tr><td>NEW</td><td>Thread对象创建了，但还没调用start方法</td></tr><tr><td>TERMINATED</td><td>Thread对象还在，但内核中的线程已经没了</td></tr><tr><td>RUNNABLE</td><td>可运行的，线程已经在cpu上执行了/线程正在排队等待上cpu执行</td></tr><tr><td>TIME_WAITING</td><td>阻塞，由于sleep这种固定时间的方式产生阻塞</td></tr><tr><td>WAITING</td><td>阻塞， 由于wait这种不固定时间的方式成的阻塞</td></tr><tr><td>BLOCKED</td><td>阻塞，由于锁竞争导致的阻塞</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>javaEE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/2023/07/31/MySQL/"/>
    <url>/2023/07/31/MySQL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><strong>本文说明</strong>：2023的暑假中mysql的学习~ 学习的内容的侧重点不同于学校的理论，而是工作、面试中可能经常出现的内容~ 本文是针对小白和稍微有一些了解的用户所讲解的~</p><h1 id="一、数据库介绍"><a href="#一、数据库介绍" class="headerlink" title="一、数据库介绍"></a>一、数据库介绍</h1><h2 id="0x00-什么是数据库"><a href="#0x00-什么是数据库" class="headerlink" title="0x00 什么是数据库"></a>0x00 什么是数据库</h2><p>数据库是一个广义的概念：</p><ol><li><p>表示 “数据库” 这一门学科。研究如何设计实现一个数据库(造轮子)</p></li><li><p>表示一类软件，用来有效管理数据</p><p>……</p></li></ol><p>我们这里介绍的是mysql数据库管理软件。学科啥的太抽象了~</p><h2 id="0x01-数据库软件"><a href="#0x01-数据库软件" class="headerlink" title="0x01 数据库软件"></a>0x01 数据库软件</h2><p>数据库的软件大致可以分为下面几种：</p><ol><li><strong>Oracle</strong> ： 数据库软件中的大哥。但是因为软件要收费，而且Oracle数据库在使用的时候，必须搭配IBM的小型机(不是一般我们用的电脑)，才能发挥出十成功力， 但是小型机很贵，所以使用Oracle数据库的<strong>成本太高</strong>了，<strong>一般都是银行这种不差钱，且要保存非常重要的数据的公司才会使用</strong>。</li><li><strong>MySQ</strong>L：<strong>开源&amp;免费</strong>的数据库(白嫖能不香嘛)！不过已经被Oracle公司收购了~ 钞能力的强大 ~</li><li><strong>SQLSever</strong>：微软做的数据库，但是最初的时候，由于只支持Windows系统，而且还收费，而使用数据库的场景一般是服务器开发，用到的系统大多是Linux，所以到现在用的公司不是很多~</li><li><strong>SQLite</strong>：主打一个轻便。运行速度快，占用内存小，经常在嵌入式设备(智能冰箱、洗衣机、空调……)中使用~</li><li><strong>redis</strong>：与上面的数据库不同的是，redis是“<strong>非关系型数据库</strong>”。</li></ol><p><strong>补充</strong>：</p><p><strong>关系型数据库(比较传统的数据库)<strong>，是</strong>使用“表”</strong>这样的结构来组织数据的，<strong>对数据的格式要求较高</strong>，也就是说每一行的每一列都得与设置的含义匹配上。举个例子：我们创建一个int的二维数组， 里面就只能存放int型的数据，而非关系型，就类似创建一个object的二维数组，里面可以存放不止一种类型的数据。</p><p><strong>非关系型数据库</strong>，更加<strong>灵活</strong>，通常<strong>使用“文档”、“键值对”</strong>这样的结构来组织数据，也就是说<strong>一行&#x2F;条数据差异可以很大</strong>~</p><h2 id="0x02-MySQL结构"><a href="#0x02-MySQL结构" class="headerlink" title="0x02 MySQL结构"></a>0x02 MySQL结构</h2><p><strong>MySQL</strong>使用的是cs的结构，就是“<strong>客户端-服务器”</strong>结构。</p><p><strong>客户端</strong>：<strong>主动</strong>发起<strong>请求</strong>的一方</p><p><strong>服务器</strong>：<strong>被动响应</strong>客户端请求的一方。由于服务器不知道客户端什么时候请求，因此服务器需要一直等待~</p><p><strong>补充</strong>：</p><p>当客户端的数量越来越多的时候，那么他们对服务器的请求也越来越多，这就要求服务器要增加性能来应对这些请求，但是往后增加性能的成本会越来越高，因此，就出现了<strong>“分布式系统”</strong>，也就是说一台机器，<strong>既可以是服务器，也可以是客户端</strong>。当机器A想要请求资源的时候，可以对机器B发起，然后B可以看看自己有没有资源，没有的话就向其他机器请求，在这里面每一个就是一个对等体，所以也可以叫做<strong>peer to peer</strong>的模式。</p><p>虽然MySQL是客户端-服务器的结构，但是我们<strong>真实的数据是存储在硬盘上</strong>的，而<strong>服务器才是MySQL的本体，负责存储和管理数据</strong>~</p><h1 id="二、数据库操作"><a href="#二、数据库操作" class="headerlink" title="二、数据库操作"></a>二、数据库操作</h1><h2 id="0x00-创建数据库"><a href="#0x00-创建数据库" class="headerlink" title="0x00 创建数据库"></a>0x00 创建数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create database [if not exists] 数据库名 charset 字符集名字;<br><br>#说明<br>#[]里面的内容是可加可不加的~<br>#if not exists 可以用来避免报错，使用场景是当我们要执行一系列的SQL语句时，如果存在了同名数据库，此时依旧会执行后面的SQL语句<br>#charset 也可以写成 character set 可以指定当前数据库使用什么编码方式<br>#在写完SQL语句后要加;号，表示此行语句写完了，因为mysql客户端允许你输入的时候换行<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p>不同的字符集，会产生不同的编码方式，也就是说在不同的字符集下，一个汉字占用几个字节是不同的。例如：<strong>gbk编码</strong>，一个<strong>汉字占用2个字节</strong>，<strong>utf8编码</strong>，一个<strong>汉字占3个字节</strong>。</p><h2 id="0x01-查看所有数据库"><a href="#0x01-查看所有数据库" class="headerlink" title="0x01 查看所有数据库"></a>0x01 查看所有数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show databases;<br><br>#列出当前mysql服务器上一共有哪些数据库<br></code></pre></td></tr></table></figure><h2 id="0x02-选中数据库"><a href="#0x02-选中数据库" class="headerlink" title="0x02 选中数据库"></a>0x02 选中数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">use 数据库名;<br><br>#当我们想要对数据进行操作的时候，我们首先要选中数据库，可以理解为指向性技能~<br></code></pre></td></tr></table></figure><h2 id="0x03-删除数据库"><a href="#0x03-删除数据库" class="headerlink" title="0x03 删除数据库"></a>0x03 删除数据库</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop database 数据库名;<br><br>#删除一个数据库，会删除里面的所有内容，非常危险(从删库到跑路~)<br>#当年炉石服务器就发生了严重的数据问题，服务器选择了回档，但还好补偿够给力，玩家选择了集体失忆~<br></code></pre></td></tr></table></figure><h1 id="三、表操作"><a href="#三、表操作" class="headerlink" title="三、表操作"></a>三、表操作</h1><h2 id="0x-00-字段类型"><a href="#0x-00-字段类型" class="headerlink" title="0x 00 字段类型"></a>0x 00 字段类型</h2><p>一些常用的类型。</p><table><thead><tr><th>数据类型</th><th>大小</th><th>说明</th><th>对应java类型</th></tr></thead><tbody><tr><td>int</td><td>4字节</td><td></td><td>Integer</td></tr><tr><td>bigint</td><td>8字节</td><td></td><td>Long</td></tr><tr><td>double</td><td>8字节</td><td></td><td>Double</td></tr><tr><td>decimal(M,D)</td><td>M&#x2F;D最大值+2</td><td>M指定数的长度，D表示小数点显示到D位数</td><td>BigDecimal</td></tr><tr><td>varchar(N)</td><td>0-65535字节</td><td>可变长度字符串，N表示字符串长度</td><td>String</td></tr><tr><td>datetime</td><td>8字节</td><td>插入格式：“YY-MM-DD 00:00:00”</td><td>java.util.Date</td></tr></tbody></table><p>有了这些类型，那么就可以开始创建一张表，开始存储数据了~</p><h2 id="0x-01-创建表"><a href="#0x-01-创建表" class="headerlink" title="0x 01 创建表"></a>0x 01 创建表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名(列名 类型, 列名 类型......);<br><br>#创建一张表，指定列的属性<br></code></pre></td></tr></table></figure><h2 id="0x-02-查看所有表"><a href="#0x-02-查看所有表" class="headerlink" title="0x 02 查看所有表"></a>0x 02 查看所有表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show tables;<br><br>#查看当前数据库中所有的表<br></code></pre></td></tr></table></figure><h2 id="0x-03-查看表结构"><a href="#0x-03-查看表结构" class="headerlink" title="0x 03 查看表结构"></a>0x 03 查看表结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">desc 表名;<br><br>#查看指定表的结构<br>#desc 的全称是 describe 描述<br></code></pre></td></tr></table></figure><h2 id="0x-04-删除表"><a href="#0x-04-删除表" class="headerlink" title="0x 04 删除表"></a>0x 04 删除表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">drop table 表名;<br><br>#删除指定表，比较危险需要慎重<br></code></pre></td></tr></table></figure><h1 id="四、SQL的增删改查"><a href="#四、SQL的增删改查" class="headerlink" title="四、SQL的增删改查"></a>四、SQL的增删改查</h1><p>增删改查也称crud，全称create、read、update、delete，是数据库非常基础的部分，也是后端开发工作中主要的一部分。</p><h2 id="0x-00-插入数据"><a href="#0x-00-插入数据" class="headerlink" title="0x 00 插入数据"></a>0x 00 插入数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">insert into 表名 values (值, 值......);<br><br>#此处的值需要和表的列进行一一对应， 也就是值的个数和类型要匹配<br><br>insert into 表名 (列名, 列名......) values (值, 值......);<br><br>#此处的值需要和前面的列名匹配，如果有的列没有赋值，会进行赋默认值<br><br>insert into 表名 values (值, 值......), (值, 值......);<br><br>#一次插入多个数据，相比于分多次插入会有性能的提升。因为每次一次操作客户端都要向服务器请求，服务器要响应，这一定会影响性能。<br></code></pre></td></tr></table></figure><h2 id="0x-01-删除数据"><a href="#0x-01-删除数据" class="headerlink" title="0x 01 删除数据"></a>0x 01 删除数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">delete from 表名 where 条件;<br><br>#删除表中某一行数据<br>#如果不加where的话，将会删除表中所有数据！<br></code></pre></td></tr></table></figure><h2 id="0x-02-修改数据"><a href="#0x-02-修改数据" class="headerlink" title="0x 02 修改数据"></a>0x 02 修改数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">update 表名 set 列名 = 值 where 条件;<br><br>#将表中某一列的值修改<br>#如果不加where的话，将会修改表中所有数据！<br></code></pre></td></tr></table></figure><h2 id="0x-03-查询数据"><a href="#0x-03-查询数据" class="headerlink" title="0x 03 查询数据"></a>0x 03 查询数据</h2><h3 id="3-1-全列查询"><a href="#3-1-全列查询" class="headerlink" title="3.1 全列查询"></a>3.1 全列查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from 表名;<br><br>#把表中所有行所有列的数据查询出来<br># * 表示通配符，代指所有列<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p><strong>select * 是一个危险操作</strong>。如果当前这个表的数据特别多，可能会把<strong>硬盘的IO跑满</strong>， 此时其他程序想要访问硬盘，会非常慢。而且由于是客户端-服务器的结构，我们是通过客户端发起请求，然后服务器通过网络将查询的结构返回给客户端，此时数据太多的话， 可能会<strong>把网卡的带宽跑满</strong>，其他客户端通过网络访问服务器将非常慢~</p><h3 id="3-2-指定列查询"><a href="#3-2-指定列查询" class="headerlink" title="3.2 指定列查询"></a>3.2 指定列查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名, 列名...... from 表名 ;<br><br>#指定查询表中指定列的数据<br></code></pre></td></tr></table></figure><h3 id="3-3-查询字段为表达式"><a href="#3-3-查询字段为表达式" class="headerlink" title="3.3 查询字段为表达式"></a>3.3 查询字段为表达式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 +-*/ 数字 from 表名;<br><br>#一边查询，一边进行计算<br>#这里的操作不会对真正的数据库中的数据进行修改，相当于临时的<br></code></pre></td></tr></table></figure><h3 id="3-4-别名"><a href="#3-4-别名" class="headerlink" title="3.4 别名"></a>3.4 别名</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 as 别名 from 表名;<br><br>#将某一列查询后面改个名字，一般配套表达式使用<br>#这里的as可以省略也可以不省略(通常建议不省略，防止看花眼)~<br></code></pre></td></tr></table></figure><h3 id="3-5-去重"><a href="#3-5-去重" class="headerlink" title="3.5 去重"></a>3.5 去重</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select distinct 列名, 列名...... from 表名;<br><br># distinct 修饰某个列/多个列, 此时查询的结果中相同的数据只会保留一个<br></code></pre></td></tr></table></figure><h3 id="3-6-排序"><a href="#3-6-排序" class="headerlink" title="3.6 排序"></a>3.6 排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名, 列名...... from 表名 order by 列名 desc/asc;<br><br>#以某一列的数值为准，进行排序操作<br>#如果写了desc 那就是降序，如果不写或者写了asc 那就是升序<br></code></pre></td></tr></table></figure><p><strong>补充</strong>：</p><p>如果order by 列1, 列2, 列3  写了多个字段，那么会先按照字段的顺序进行排序，比如，现在回先按照列1进行排序，如果列1的值相同，那么再比较列2 ，以此往复~</p><h3 id="3-7-条件查询"><a href="#3-7-条件查询" class="headerlink" title="3.7 条件查询"></a>3.7 条件查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 where 条件;<br></code></pre></td></tr></table></figure><p>条件中存在着一些运算符，我们来认识一下~</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>&gt;, &gt;&#x3D;, &lt;, &lt;&#x3D;</td><td>大于，大于等于，小于，小于等于</td></tr><tr><td>&#x3D;</td><td>等于，NULL 不安全，例如 NULL &#x3D; NULL 的结果是 NULL</td></tr><tr><td>&lt;&#x3D;&gt;</td><td>等于，NULL 安全，例如 NULL &lt;&#x3D;&gt; NULL 的结果是 TRUE(1)</td></tr><tr><td>!&#x3D;, &lt;&gt;</td><td>不等于，推荐写成 !&#x3D;</td></tr><tr><td>between a0 and a1</td><td>范围匹配，[a0, a1] 都是闭区间，如果 a0 &lt;&#x3D; value &lt;&#x3D; a1，返回 TRUE(1)</td></tr><tr><td>in (n1, n2, …..)</td><td>离散化，如果是 (n1, n2, ……) 中的任意一个，返回 TRUE(1)</td></tr><tr><td>is null</td><td>是 null</td></tr><tr><td>is not null</td><td>不是null</td></tr><tr><td>like</td><td>模糊匹配。后面可以接通配符类似于癞子，或者%表示大于等于0个字符，_表示一个字符</td></tr></tbody></table><p>还有一些逻辑运算符~</p><table><thead><tr><th>运算符</th><th>说明</th></tr></thead><tbody><tr><td>AND</td><td>多个条件必须都为 TRUE(1)，结果才是 TRUE(</td></tr><tr><td>OR</td><td>任意一个条件为 TRUE(1), 结果为 TRUE(1)</td></tr><tr><td>NOT</td><td>条件为 TRUE(1)，结果为 FALSE(0)</td></tr></tbody></table><p><strong>注意</strong>：</p><p><strong>where 条件可以使用表达式，但不能使用别名。</strong></p><p>因为<strong>select 条件查询的执行顺序</strong>：</p><ol><li>遍历表中每个记录</li><li>根据记录的值带入条件，根据条件进行筛选</li><li>如果这个记录条件成立，则保留当前记录，然后进行列上的表达式计算(或者重命名啥的)</li><li>如果有order by， 再进行排序</li></ol><p>所以，在条件筛选的优先级高于列上的表达式计算，因此使用别名的话，sql服务器就不认识了~</p><h3 id="3-8-分页查询"><a href="#3-8-分页查询" class="headerlink" title="3.8 分页查询"></a>3.8 分页查询</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 limit n offset x;<br><br>#从索引为x的记录(第一条记录的索引为0)开始， 查询出 n 条记录<br></code></pre></td></tr></table></figure><p>以上都是基础的SQL查询语句，不过很实用~</p><h1 id="五、约束"><a href="#五、约束" class="headerlink" title="五、约束"></a>五、约束</h1><p>有时候，数据库中数据是有约束的，比如 性别列，你不能填一些奇奇怪怪的数据~</p><p>如果靠人为的来对数据进行检索约束的话，肯定是不行的，人肯定会犯错~因此就需要让计算机对插入的数据进行约束要求！</p><p><strong>约束的使用语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create 表名 (列名 类型 约束);<br><br>#在创建表的时候对某一列数据进行约束操作<br></code></pre></td></tr></table></figure><p><strong>在mysql中提供了如下约束</strong>：</p><table><thead><tr><th>约束</th><th>说明</th></tr></thead><tbody><tr><td>not null</td><td>某一列的数据不能为null值</td></tr><tr><td>unique</td><td>某一列中的值唯一</td></tr><tr><td>default</td><td>规定没有给某列赋值时为默认值</td></tr><tr><td>primary key</td><td>not null 和 unique 的结合。记录身份的标识，一般配合自增主键使用</td></tr><tr><td>foreign key</td><td>保证一个表中的数据匹配另一个表中的值的参照完整性</td></tr><tr><td>check</td><td>保证列中的值符合指定条件</td></tr></tbody></table><p>注意：使用约束的话，一定会数据库的效率有影响！</p><p>由于not null、 unique、default、check比较容易，这里就对主键(primary key)和外键(foreign key) 进行解释。</p><h2 id="主键primary-key"><a href="#主键primary-key" class="headerlink" title="主键primary key"></a>主键primary key</h2><p>主键可以理解为记录的身份标识，就像身份证一样是我们每个人的身份标识，既不能为空，又不能重复。</p><p><strong>一张表里只能有一个主键</strong>，毕竟是身份标识嘛，存在多个了，以谁为准???</p><p>虽然主键只能有一个，但是<strong>主键不一定是一列</strong>，可以用<strong>多个列共同构成主键</strong>(联合主键)。</p><p>由于主键具有unique属性，因此我们一般<strong>配合mysql中 ”自增主键”</strong> 来使用，也就是会自动分配一个逐个增长的值~</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名 (列名 类型 primary key auto_increment);<br></code></pre></td></tr></table></figure><p>如果手动插入一个数据，此时<strong>数据库会与主键最高的值进行比较</strong>，如果高了就更新，<strong>此后自动分配的值也会从这个最高值进行增长</strong>！</p><p><strong>拓展</strong>：</p><p>如果是<strong>分布式系统</strong>，在<strong>同一时间插入了一个数据</strong>，此时<strong>自增主键就会出错</strong>，那么如何处理这种并发场景呢？</p><p><strong>一般会使用一个公式来形成主键</strong>：</p><p>分布式主键值 &#x3D;  时间戳 + 机房编号&#x2F;主机号 + 随机因子   此处使用的是字符串拼接操作!!!</p><p>前面两个可以<strong>防止在同一时间不同机器的的主键冲突</strong>，后面的<strong>随机因子</strong>可以<strong>防止同一时间同一机器的主键冲突</strong>，但是理论上还是有可能存在冲突的~</p><h2 id="外键foreign-key"><a href="#外键foreign-key" class="headerlink" title="外键foreign key"></a>外键foreign key</h2><p>案例引入： </p><p>现在我们有两张表，一张是学生表，里面有学号、姓名、班级号字段，另一张表示班级表，里面有班级号、班级名字段。</p><img src="/2023/07/31/MySQL/image-20230803084857974.png" class title="image-20230803084857974"><img src="/2023/07/31/MySQL/image-20230803085241442.png" class title="image-20230803085241442"><p>我们细细观察，可以发现，肯定是先有班级表，学生的班级号才能确定，但是现在突然冒出了一个classId 为 300的学生，但是在我们的班级表中不存在这个班级号，为了防止这种情况发生，我们可以使用外键约束~</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table 表名 (列名 类型, 列名 类型, ......, foreign key (列名) references 主表名(列名));<br><br>#我们创建学生表的时候可以这样写：<br>#create table student (id int, name varchar(20), classId int, foreign key （classId） references class(classId));<br>#student表的classId 的所有数据都要出自于class表的classId这一列，也就是说如果class表中没有这个班级号，那么我们插入的学生信息将会报错~<br></code></pre></td></tr></table></figure><p><strong>使用外键</strong>之后，<strong>被约束的表就称为子表</strong>， <strong>另一张表相对的就是父表</strong>，<strong>子表</strong>中的那一个字段的<strong>数据</strong>都要<strong>出自父表</strong>。当然，力的作用是相互的，约束也不例外，当我们想要<strong>删除&#x2F;修改父表的约束子表的那个字段</strong>，如果子表<strong>已经引用</strong>过了，那么我们将会<strong>删除&#x2F;修改失败</strong></p><p><strong>注意</strong>：</p><p><strong>父表中约束子表的字段必须为主键或者unique！！！</strong></p><h1 id="六、表的设计"><a href="#六、表的设计" class="headerlink" title="六、表的设计"></a>六、表的设计</h1><p> 在实际的场景中，有大量的数据，我们需要明确当前要创建几个表，每个表有什么字段，这些表中是否存在一定的联系。</p><p>因此根据实际开发就整理出了三大范式~</p><h2 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h2><p>例如：<strong>一个学生只有一个账号，一个账号只属于一个学生</strong>。</p><p>此时我们设计两张表，让其中的一张表存储另一张表的<strong>唯一</strong>属性，这样我们可以通过这个属性就能找到想要的值了。或者也可以将两张表整合，成为一张表。</p><img src="/2023/07/31/MySQL/image-20230813092055975.png" class title="image-20230813092055975"><h2 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h2><p>例如：<strong>一个学生只能属于一个班级，一个班级可以拥有多个学生。</strong></p><p>此时我们设计两张表，<strong>将那个“一”的表中添加上“多”的表中的唯一的字段</strong>。</p><p><strong>补充</strong>：如果是redis这种能够支持数组类型的数据库，我们可以不这样设计，可以使用一个数组类型，用来存储多个学生。如下图：</p><img src="/2023/07/31/MySQL/image-20230813093004691.png" class title="image-20230813093004691"><h2 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h2><p>例如：一个学生可以选多门课程，一个课程可以被多名学生选择。</p><p>此时我们需要再<strong>创建一张表来描述这两张表之间的关系</strong>。</p><img src="/2023/07/31/MySQL/image-20230813093735349.png" class title="image-20230813093735349"><h1 id="七、查询增强-进阶"><a href="#七、查询增强-进阶" class="headerlink" title="七、查询增强(进阶)"></a>七、查询增强(进阶)</h1><p><strong>查询操作有很多的花样，但一般实际开发中最最最常使用的还是前面基础的crud操作。</strong></p><h2 id="0x-00-聚合查询"><a href="#0x-00-聚合查询" class="headerlink" title="0x 00 聚合查询"></a>0x 00 聚合查询</h2><p>之前的<strong>表达式查询</strong>是对于一条记录上的<strong>列与列</strong>之间进行运算的，如果要针对<strong>行与行之间进行运算</strong>呢？这时候就要用到<strong>聚合查询</strong>了~</p><p>首先来了解一些聚合函数：</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>count()</td><td>返回查询数据的个数</td></tr><tr><td>sum()</td><td>返回查询数据的总和，不是数字没意义</td></tr><tr><td>avg()</td><td>返回查询数据的平均值，不是数字没意义</td></tr><tr><td>max()</td><td>返回查询数据的最大值，不是数字没意义</td></tr><tr><td>min()</td><td>返回查询数据的最小值，不是数字没意义</td></tr></tbody></table><p><strong>语法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count([distinct]表达式) from 表名;<br>select sum([distinct]表达式) from 表名;<br>select avg([distinct]表达式) from 表名;<br>select max([distinct]表达式) from 表名;<br>select min([distinct]表达式) from 表名;<br><br>#注意：<br>#count(*) 和 count(列名)的区别，count(*)会把一条为null的数据也统计进去，而count(列名)则不会<br>#如果计算字符串的值，需要字符串合法，因为mysql会尝试转成double<br></code></pre></td></tr></table></figure><h2 id="0x-01-分组查询"><a href="#0x-01-分组查询" class="headerlink" title="0x 01 分组查询"></a>0x 01 分组查询</h2><p>分组查询一般会配合聚合查询，因为分组查询会把几行数据看做是一行，如果不使用聚合查询，那么显示的结果为一组中某一个数据。</p><p><strong>举例：</strong></p><p><strong>求各班的平均成绩：</strong></p><img src="/2023/07/31/MySQL/image-20230808091752885.png" class title="image-20230808091752885"><p>那么我们的代码得这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(socre) from class group by class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808091927650.png" class title="image-20230808091927650"><p><strong>使用group by的时候，还可以搭配条件。此时我们需要区分该条件是分组前的，还是分组之后的？</strong></p><p>如果是分组前，使用where条件查询</p><p>如果是分组后，使用having条件查询</p><p>举例：</p><p><strong>查询各班平均分，但是学生成绩不能超过100</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(socre) from class where socre &lt;= 100 group by class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808092930270.png" class title="image-20230808092930270"><p><strong>查询平均分大于100分的班级</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select class_id, avg(score) from class group by class_id having avg(score) &gt; 100;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808093239831.png" class title="image-20230808093239831"><h2 id="0x-02-联合查询"><a href="#0x-02-联合查询" class="headerlink" title="0x 02 联合查询"></a>0x 02 联合查询</h2><p>联合查询也就是多表查询，就是在多张表上进行查询。但是联合查询也会有<strong>一些问题</strong>……</p><p><strong>联合查询会产生笛卡尔积</strong>，也就是说表A中的每一条数据都会与表B中每一条数据进行组合，如果A表中的数据个数为100，表B中的数据个数为100，那么最终会产生100<em>100条数据。但是仔细观察，会发现有一些数据是“非法”的。*<em>笛卡尔积是简单的排列组合，穷举所有情况，因此你我们需要筛选数据~</em></em></p><p><strong>如果要联合n张表进行查询，那么我们需要使用n-1个连接条件，才不会出现笛卡尔积的现象~</strong></p><img src="/2023/07/31/MySQL/image-20230808094213698.png" class title="image-20230808094213698"><p><strong>此时就出现了笛卡尔积，但是仔细观察，会发现class_id 不同的数据都组合到了一起，因此我们需要一个连接条件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select student.class_id, student.name, class.socre from student, class where student.class_id = class.class_id;<br></code></pre></td></tr></table></figure><img src="/2023/07/31/MySQL/image-20230808094523104.png" class title="image-20230808094523104"><hr><p><strong>由于多表查询一般比较复杂，我们可以按照如下的步骤来写：</strong></p><p>1、先进行指定哪个几个表，进行笛卡尔积</p><p>2、指定连接条件，去除笛卡尔积</p><p>3、精简列数据</p><p>以上查询都是基于“内连接“的操作，然而mysql还提供了”外连接“(左外连接，右外连接)</p><hr><p><strong>案例引入</strong>：</p><p>现有如下表<img src="/2023/07/31/MySQL/image-20230808095817918.png" class title="image-20230808095817918"></p><p>此时<strong>student的每一条记录都可以在score表中找到对应，每一个score中记录也可以在student表中找到对应。</strong></p><p>此时我们使用外内接或者内连接查询的结果是一样。</p><img src="/2023/07/31/MySQL/image-20230808100511716.png" class title="image-20230808100511716"><p><strong>但是如果不存在记录，那么内连接与外连接就会天差地别~</strong></p><img src="/2023/07/31/MySQL/image-20230808100806990.png" class title="image-20230808100806990"><p>外连接分为左外连接和右外连接。</p><p><strong>左外连接：</strong>以左表为基准，保证左侧表的每个数据都会出现在最终的结果集里，如果右表没有与之对应的记录则显示null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名1 left join 表2 on 连接条件<br></code></pre></td></tr></table></figure><p><strong>右外连接：</strong>以右表为基准，保证右侧表的每个数据都会出现在最终的结果集里，如果左表没有与之对应的记录则显示null。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名1 right join 表2 on 连接条件<br></code></pre></td></tr></table></figure><p>我们还可以用集合图来表示这些连接的关系：</p><img src="/2023/07/31/MySQL/image-20230809090138583.png" class title="image-20230809090138583"><p><strong>补充</strong>：</p><p>以上我们都是针对于两个表进行联合查询的，但我们甚至还可以<strong>将一个表当做两个表来进行联合查询</strong>，这样我们就能在一张表中进行 <strong>行与行的比较</strong>~这种连接方式一般被称为<strong>“内连接”</strong>。</p><p>自连接的查询跟上面的联合查询基本没什么区别，需要注意将两张表进行别名操作~</p><h2 id="0x-03-子查询"><a href="#0x-03-子查询" class="headerlink" title="0x 03 子查询"></a>0x 03 子查询</h2><p><strong>子查询是将多个简单的SQL语句拼成一个复杂的SQL, 也就是说将某一个查询的结果看做是一张表，然后进行操作，但本质是在套娃</strong>。因此我们实际也是可以用简单的查询完成子查询的操作的~ (合成2048？合成复杂SQL！)</p><p>语法形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名 from 表名 where 列名 = (select 列名 from 表名 where 列名 = (套娃下去....));<br></code></pre></td></tr></table></figure><h2 id="0x-04-合并查询"><a href="#0x-04-合并查询" class="headerlink" title="0x 04 合并查询"></a>0x 04 合并查询</h2><p>合并查询就是<strong>将多个sql的查询结果集 合并在一起</strong>。合并的两个sql结果集的列，需要<strong>匹配，列的个数和类型得是一致的</strong>！<strong>合并的时候是会进行去重的，如果不想要去重，得使用 union all</strong> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select 列名1 列名2 from 表1 union [all] select 列名3 列名4 from 表2;<br></code></pre></td></tr></table></figure><p><strong>最终结果</strong>：</p><img src="/2023/07/31/MySQL/image-20230809092917129.png" class title="image-20230809092917129"><h1 id="八、索引"><a href="#八、索引" class="headerlink" title="八、索引"></a>八、索引</h1><p>由于我们在使用数据库的时候，<strong>大部分操作的都是查询操作</strong>，但是我们<strong>每一次进行查询都需要遍历一遍表</strong>中所有数据，这会花费O(n)的时间，因此数据<strong>引入了“索引”</strong> 也就是在底层使用了数据结构来进行<strong>优化查询</strong>的操作，但是可能会<strong>造成插入&#x2F;删除操作变慢</strong>和<strong>消耗空间</strong>。</p><p><strong>语法</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">show index from 表名;<br><br>#查看表中哪一列有索引<br><br>create index 索引名字 on 表名(列名);<br><br>#对某一列创建索引<br><br>drop index 索引名 on 表名;<br><br>#删除索引<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>一个索引是针对列来指定的。<strong>只有针对这一列进行查询时</strong>，查询速度才能被索引优化~如果进行全列查询的话，那还是需要遍历表的。</p><p><strong>如果某一列被primary key、foreign key、unique所约束的话，会自动创建索引</strong>。</p><p><strong>创建索引</strong>也是一个相当<strong>危险的操作</strong>，因为创建索引是需要对现有的数据进行大规模的整理，如果数据非常多，很容易就把服务器卡住，一般来说创建索引的时候都是在创建完表后立马操作，一旦使用久了的话， 需要慎重操作。不过也可以采用分治的思想，一点一点将数据写入到创建好的表中~</p><hr><p><strong>以上内容都是基础的知识，但是面试常考查的是索引的底层~~</strong></p><p>(由于本人水平有限，在此先简单介绍简单的内容知识~)</p><p>索引的底层使用的是<strong>一种类似二叉搜索树</strong>(在极端情况下，<strong>二叉搜索树的时间复杂度为O(n)，AVL树，红黑树能达到O(logn)</strong>)的树 ，也就是<strong>一棵改进的树形结构：B+树</strong>。可能会好奇，为啥不用哈希表呢？时间复杂度可以O(1),这是因为<strong>在查询的过程中我们往往会进行范围查询，而哈希表只能进行精确的查询</strong>，因此我们不使用哈希表。</p><img src="/2023/07/31/MySQL/f070fdfc8e4b40dda2ebee96c3c6170a.jpeg" class title="img"><p>B+树顾名思义是在B树的基础上改进的。那啥是B树呢？</p><p>B树：是一棵<strong>N叉搜索树</strong>，每个节点的度不确定，一个节点上保存N个数据的值，划分出N + 1个区间，每个区间衍生出一棵子树。</p><p><strong>逻辑上存储结果如下</strong>：</p><img src="/2023/07/31/MySQL/image-20230810085349816.png" class title="image-20230810085349816"><p>而B+树则是对B树的改进，感觉像是针对数据库进行量身定做。</p><p>如果使用B树会有遇到什么问题呢？假如我们现在要使用范围查询去查询10-40之间的数。我们在如下图中进行观察：</p><img src="/2023/07/31/MySQL/image-20230810093232881.png" class title="image-20230810093232881"><p><strong>搜索过程大致如下</strong>：</p><p>我们先要进行小于20区间的搜索，然后再进行20-40区间的搜索，里面<strong>包含大量“向下递”(需要开辟内存空间)，”回溯“的操作</strong>，如果一棵区间子树的高度较高，我们需要花费较多时间进行这个子树的搜索，恰巧另一些范围内的数据在另一棵子树上，那么我们又要花费较多时间进行搜索。<strong>总的来说，由于范围查询，我们有时要搜索多棵子树，这会导致效率的下降。</strong></p><p>基于这些缺点，B+树进行了优化。首先，<strong>B+数在每个非叶子节点上存储的是索引</strong>(B树上就是实际的值)，<strong>所有数据都是存储在叶子节点上</strong>，<strong>B+树再使用了一个链表</strong>，将所有叶子节点连了起来，这就导致了<strong>范围查询更加高效</strong>，因为只要找到了一个符合要求的叶子节点，我们就直接对链表进行遍历，省去了再搜索其他子树的操作。</p><hr><p><strong>B+树的优点(相比B树、哈希、红黑树)：</strong></p><p>1、<strong>是一棵N叉搜索树，因此树的高度比较小</strong>。</p><p>2、<strong>磁盘IO次数更少，效率更高</strong>。</p><p>红黑树是一棵平衡二叉搜索树，为了平衡需要进行旋转操作，而<strong>旋转操作时针对于整棵树</strong>的，但是因为数据库中可能存储着大量的数据，我们往往<strong>不能将所有的数据读取到内存中，因此需要部分多次读取</strong>，这就导致了旋转可能会有问题且效率不高，而且也<strong>无法利用磁盘预读</strong>(存储器某一个位置被访问了，那么其附近位置也会被访问)。</p><p>在B树中，<strong>每一个节点是在一个硬盘区域中</strong>，可以利用磁盘预读，<strong>一次读硬盘就能取出整个节点(<strong>多个键值对)。而</strong>读取硬盘的时间远大于内存比较的时间</strong>，近似于 读一次硬盘 &#x3D; 内存1w次比较。</p><p>在B+树中，<strong>非叶子节点上是存的索引信息</strong>，而对应数据库中一行数据可能内容比较多，但是单单某一行的<strong>某一列(索引)所占空间往往只有几个字节</strong>，因此我们能够<strong>将所有的索引信息读取到内存中进行比较</strong>，然后找到叶子节点上的值，再通过链表遍历的方式进行搜索，从而大大减少了IO次数。</p><p>3、所有的查询最终要落实到叶子节点，因此整体的<strong>查询效率比较稳定</strong>，而B树中可能在前面的节点就能找到，复杂度为O(1), 不稳定。</p><p>4、<strong>非常擅长范围查询</strong></p><h1 id="九、事务"><a href="#九、事务" class="headerlink" title="九、事务"></a>九、事务</h1><p>事务：一组数据库的操作语句，这些操作将会被视为一个整体，保证要么这些语句全部执行，要么“一个都不执行”。</p><h2 id="0x-00-案例引入"><a href="#0x-00-案例引入" class="headerlink" title="0x 00 案例引入"></a>0x 00 案例引入</h2><img src="/2023/07/31/MySQL/image-20230806090729717.png" class title="image-20230806090729717"><p>现在，SQL语句执行完了第一条但是还没执行第二条的时候，突然电脑关机&#x2F;程序崩溃了…….</p><p>张三一看已经扣了钱，但是李四却没有收到，这就很尴尬了。此时我们需要引入“事务”，来帮助我们解决这个问题，也就是要么张三扣了钱，李四收到了钱，要么就无事发生~ <strong>我们将这种“要么全部执行，要么相当于没有执行”这个特殊的性质称为“原子性”</strong></p><h2 id="0x-01-事务的特性ACID"><a href="#0x-01-事务的特性ACID" class="headerlink" title="0x 01 事务的特性ACID"></a>0x 01 事务的特性ACID</h2><p>1、<strong>原子性(Atomicity)</strong> ：<strong>事务出现的原因</strong>。将一系列sql语句看成一个整体，要么全部执行，要么通过回滚的方式，恢复如初。</p><p>2、 <strong>一致性(Consistency)</strong> ：事务执行之前和之后，数据都不能出现非法的情况。</p><p>3、 <strong>持久性(Durability)</strong> ：事务做出的修改，都是在硬盘上持久保存的，即使在系统故障或者崩溃的情况下，事务执行的修改都是有效的。</p><p>4、<strong>隔离性(Isolation)</strong> ：<strong>由于mysql是客户端-服务器的模式，会存在并发的情况，即多个用户在同一时间请求服务器。</strong>事务的执行是相互隔离的，一个事务的操作不应该影响其他事务的操作。</p><p><strong>补充</strong>：</p><p><strong>并发操作往往能提高效率，但是会降低准确性</strong>。mysql数据库在并发执行的时候，会遇到如下问题：</p><p><strong>1、脏读：</strong></p><p>事务A在**改变(修改，增加，删除) **数据</p><p>事务B在事务A未提交的时候就来读取数据</p><p>后来事物A可能在事物B读完了数据后又修改了或者回滚了，此时事务B读到数据就是“脏”的，即无效的。</p><p><strong>脏读也就是在写的过程中进行读操作。 <strong>解决脏读问题，思路是</strong>对写操作进行加锁</strong>，告诉事务B在我写的时候，不要来读取数据。此时并发性降低了，隔离性提高了，效率降低了，准确性提高了~</p><p><strong>2、不可重复读：</strong></p><p>事务B在读取数据</p><p>事务A<strong>修改或删除了数据</strong>然后提交事务</p><p>事务B第二次读数据的时候，发现两次读到的数据不相同，也就是事务A在事物B两次读取的时候进行了修改。</p><p><strong>不可重复读也就是在读的过程中进行了写操作</strong>。解决不可重复读问题，思路是<strong>对读操作进行加锁</strong>，告诉事务A在我读的时候，不要来修改数据。</p><p><strong>3、幻读：</strong></p><p>事务B在读数据</p><p>事务A此时<strong>插入了数据</strong>然后提交了事务</p><p>事务B第二次读数据，然后读到了与第一不一样的结果集。</p><p><strong>幻读与不可重复读类似，区别在于幻读是强调插入操作，不可重读是修改操作。</strong>解决幻读的问题，思路是<strong>引入串行化的方式</strong>，保证绝对的串行执行事务，此时完全没有并发了。</p><p>针对以上的问题，mysql提供了4种隔离级别，可以在mysql配置文件中修改~</p><table><thead><tr><th>隔离级别</th><th>解决问题</th></tr></thead><tbody><tr><td>read uncommitted(读未提交)</td><td>隔离性最低，但效率最高</td></tr><tr><td>read committed(读已提交)</td><td>给写加锁，解决脏读</td></tr><tr><td>repeatable read(可重复读)</td><td>给读、写加锁，解决脏读、不可重复读</td></tr><tr><td>serializable(串行化)</td><td>严格按照串行的方式，一个一个执行事务，解决脏读、不可重复读、幻读</td></tr></tbody></table><h2 id="0x-02-操作语句"><a href="#0x-02-操作语句" class="headerlink" title="0x 02 操作语句"></a>0x 02 操作语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction; #开启事务<br><br>进行一些列sql语句......<br><br>rollback;   #回滚事务，恢复到未执行事务前<br><br>commit;   #提交事务<br><br><br>#事务的使用很简单，但需要关注事务背后的一些原理性质的内容<br></code></pre></td></tr></table></figure><h1 id="十、JDBC"><a href="#十、JDBC" class="headerlink" title="十、JDBC"></a>十、JDBC</h1><h2 id="0x-00-什么是JDBC"><a href="#0x-00-什么是JDBC" class="headerlink" title="0x 00 什么是JDBC"></a>0x 00 什么是JDBC</h2><p>JDBC代表Java连接数据库，也就是<strong>通过Java代码操作数据库</strong>。</p><p>在初期，市面上有着许多的数据库，如：MySQL, Oracle, SQL Sever…….但是<strong>不同的数据库</strong>大概率是<strong>由不同的程序员所开发</strong>出来的，因此在使用方面<strong>存在差异(如：方法名，类名，功能不同)<strong>，这就大大的增加了程序员的难度，苦不堪言~这时候就需要一个真正有分量的大佬来一统江湖！！！于是</strong>Java就自己设计出一套API的规范</strong>，让各种各样的<strong>数据库都要遵守</strong>，因此<strong>java程序员只需要会一套自己的API就好了</strong>，大大减少了学习成本~</p><img src="/2023/07/31/MySQL/image-20230811195028006.png" class title="image-20230811195028006"><p><strong>各厂商实现了接口</strong>后将其打包好并发布，如果<strong>Java程序员想要操作MySQL的话，只需要导入MySQL实现的jar包</strong>，然后在程序中调佣Java自己制定的API即可。其他如果数据库也同理，不过需要导入不同厂家的jar包。</p><h2 id="0x-01导入jar包"><a href="#0x-01导入jar包" class="headerlink" title="0x 01导入jar包"></a>0x 01导入jar包</h2><p>在使用Java操作数据库前需要先将下载好的jar包(可以去中央仓库下载)导入程序。</p><p><a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">Maven Repository: mysql » mysql-connector-java (mvnrepository.com)</a></p><img src="/2023/07/31/MySQL/image-20230811200839804.png" class title="image-20230811200839804"><p>然后就可以在程序中使用了。</p><h2 id="0x-02-使用JDBC"><a href="#0x-02-使用JDBC" class="headerlink" title="0x 02 使用JDBC"></a>0x 02 使用JDBC</h2><p><strong>1、创建DataSource</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里我们可以看到，我们<strong>创建了一个dataSource</strong>，但是使用的时候却<strong>进行了向下转型</strong>，那<strong>为什么不直接创建一个MysqlDataSource的呢？</strong>这是因为要<strong>降低代码的耦合度</strong>，让MysqlDataSource这个类名不要扩散到代码的其他地方，如果后续要操作别的数据库了，代码的改动比较小。</p><p>那<strong>Url是什么</strong>呢？<strong>url表示网络上的资源位置通俗讲就是网址</strong>，因为服务器是cs模式，需要通过网络交互。</p><p><strong>127.0.0.1 表示IP地址</strong>，描述网络上一个主机所在的位置，不过这个IP地址是一个<strong>“环回IP”</strong>，即自己把数据发给自己。这是因为<strong>jdbc程序和mysql服务器都在我们自己的电脑上</strong>~</p><p><strong>3306 表示端口号，用来区分不同进程的。</strong></p><p>test 表示数据库名称。</p><p>？&amp; &#x2F;…… 这些符号是一些特殊符号。这里从？后面，表示访问资源的时候，需要哪些参数</p><p>useSSL&#x3D;false 表示是否要加密</p><p>这里dataSource光写url的话 只能找到mysql服务器，但还得登录认证，因此还需要设置账号，密码。</p><p><strong>2、和数据库服务器建立连接</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>在创建的时候千万不要选错！！！</strong></p><img src="/2023/07/31/MySQL/image-20230811203528869.png" class><p><strong>3、构造sql语句并执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(1, &#x27;张三&#x27;)&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> statement.executeUpdate(); <span class="hljs-comment">//看看修改了几条</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过使<strong>用preparedStatement进行对sql语句的检查</strong>，在<strong>将sql发给服务器之前先看看有没有语法错误</strong>啥的，这样就能<strong>减小mysql服务器的开销</strong>。</p><p>如果要执<strong>查询操作</strong>的话，要<strong>使用executeQuery()方法</strong>，如果是<strong>改操作</strong>的话，<strong>使用executeUpdate()方法</strong>。</p><p><strong>4、执行完后关闭连接，释放资源</strong></p><p><strong>程序通过代码和服务器进行通信</strong>，是<strong>需要消耗一定的资源</strong>的。因此在程序结束后需要告知服务器，<strong>释放这些资源</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(1, &#x27;张三&#x27;)&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> statement.executeUpdate();<br><br>        statement.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>后申请的先释放！</strong></p><h2 id="0x-03自定义sql语句"><a href="#0x-03自定义sql语句" class="headerlink" title="0x 03自定义sql语句"></a>0x 03自定义sql语句</h2><p>刚刚我们是为了演示总得流程，所以sql语句就在程序中写死了，如果我们要插入我们想要的数据该怎么办呢？</p><p>方案一：</p><p>创建变量让用户输入赋值修改就行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into sutdent values (&quot;</span> + id + <span class="hljs-string">&quot;, &#x27;&quot;</span> + name + <span class="hljs-string">&quot;&#x27;)&quot;</span>;<br></code></pre></td></tr></table></figure><p>这样写，既不优雅，也不安全。这么多符号很容易出错，然后如果用户是高手，懂<strong>sql注入</strong>的话，那就危险了。name一栏不好好写，写成 删库 那就惨了。</p><p>方案二：</p><p>创建变量并<strong>使用占位符</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into student values(?, ?)&quot;</span>;<br>statement.setInt(<span class="hljs-number">1</span>, id); <span class="hljs-comment">//当心第一个是从1位置开始计算的，而不是0</span><br>statement.setString(<span class="hljs-number">2</span>, name);<br></code></pre></td></tr></table></figure><p>这样就好多了~</p><h2 id="0x-04-输出查询结果"><a href="#0x-04-输出查询结果" class="headerlink" title="0x 04 输出查询结果"></a>0x 04 输出查询结果</h2><p>查询在数据库操作中是大头，怎么将查询结果输出呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-type">DataSource</span> <span class="hljs-variable">dataSource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlDataSource</span>();<br>        ((MysqlDataSource) dataSource).setUrl(<span class="hljs-string">&quot;jdbc:mysql://127.0.0.1:3306/test?characterEncoding=utf8&amp;useSSL=false&quot;</span>);<br>        ((MysqlDataSource) dataSource).setUser(<span class="hljs-string">&quot;root&quot;</span>);<br>        ((MysqlDataSource) dataSource).setPassword(<span class="hljs-string">&quot;root&quot;</span>);<br><br>        <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select * from student&quot;</span>;<br>        <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">statement</span> <span class="hljs-operator">=</span> connection.prepareStatement(sql);<br>        <span class="hljs-type">ResultSet</span> <span class="hljs-variable">resultSet</span> <span class="hljs-operator">=</span>  statement.executeQuery();<br>        <span class="hljs-keyword">while</span>(resultSet.next())&#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>);<br>            System.out.println(id + <span class="hljs-string">&quot;,&quot;</span> + name);<br>        &#125;<br><br>        resultSet.close();<br>        statement.close();<br>        connection.close();<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们的<strong>查询结果返回的是一张临时表</strong>，此时需要<strong>使用ResultSet类来接收结果集</strong>。然后要进行<strong>遍历ResultSet</strong>才能取出全部数据。</p><p>遍历ResultSet是<strong>通过调用next方法</strong>获取临时表中的每一行数据。这个next方法<strong>相当于在临时表中有一个“光标”，一开始的时候指向的是第一行的前一个位置，而每一次执行，就相当于将光标移到下一行。如果走到最后一行，将会放回false。</strong></p><p><strong>resultSet中提供了getXXX方法</strong>，里面的<strong>参数是列名</strong>，这样就可以拿到一行中的某一列数据了。</p><p>最后记得要释放result资源~</p><hr><p>以上就是一些mysql中高频常用的知识了~</p><p>完结，撒花~~</p>]]></content>
    
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包装类|认识泛型</title>
    <link href="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/"/>
    <url>/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、包装类"><a href="#一、包装类" class="headerlink" title="一、包装类"></a>一、包装类</h1><h2 id="0x-00为什么要有包装类？"><a href="#0x-00为什么要有包装类？" class="headerlink" title="0x 00为什么要有包装类？"></a>0x 00为什么要有包装类？</h2><p>众所周知，在java中，<strong>类的祖先是Object</strong>，但是基本数据类型，如int、float等并不是继承自Object，但是<strong>为了在泛型代码中可支持基本类型</strong>，Java给每个基本类型都对应了一个包装类型。</p><table><thead><tr><th>基本数据类型</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>Byte</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>char</td><td>Character</td></tr><tr><td>boolean</td><td>Boolean</td></tr></tbody></table><h2 id="0x-01装箱和拆箱"><a href="#0x-01装箱和拆箱" class="headerlink" title="0x 01装箱和拆箱"></a>0x 01装箱和拆箱</h2><p><strong>装箱</strong>：把一个 <strong>基本数据类型</strong> 转化为 <strong>包装类</strong></p><p><strong>拆箱</strong>：把一个 <strong>包装类</strong> 转化为 <strong>基本数据类型</strong></p><p><strong>装箱</strong>又分为 <strong>自动装箱</strong> 和 <strong>显示装箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i1</span> <span class="hljs-operator">=</span> n; <span class="hljs-comment">//自动装箱</span><br>    System.out.println(i1);<br>    <br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">i2</span> <span class="hljs-operator">=</span> Integer.valueOf(n); <span class="hljs-comment">//显示装箱</span><br>    System.out.println(i2);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们可以通过javap进行反汇编，看看编译器偷偷隐藏了什么操作</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517200812580.png" class title="image-20230517200812580"><p><strong>拆箱</strong>也分 <strong>自动拆箱</strong> 和 <strong>显示拆箱</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(<span class="hljs-number">10</span>);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> n;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> n.intValue();<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517201347559.png" class title="image-20230517201347559"><p><strong>我们可以看到，就算我们没有显示调用intValue方法，编译器也在底层偷偷的调用了intValue方法</strong></p><h2 id="0x-02注意"><a href="#0x-02注意" class="headerlink" title="0x 02注意"></a>0x 02注意</h2><p>当写出如下代码时，需要注意：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>    System.out.println(c == d);<br><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">128</span>;<br>    System.out.println(a == b);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>结果为：true和false</strong></p><p><strong>因为在Integer底层，装箱的时候会调用valueOf方法，而这个方法，会根据数字给定的范围，返回的是不同的“结果”。</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230517202210854.png" class title="image-20230517202210854"><p><strong>当i &gt;&#x3D; -128 &amp;&amp; i &lt;&#x3D; 127的时候，会返回一个static共享的数组，而不在这个范围的时候，就会返回一个新的对象！</strong></p><h1 id="二、认识泛型"><a href="#二、认识泛型" class="headerlink" title="二、认识泛型"></a>二、认识泛型</h1><h2 id="0x-00什么是泛型"><a href="#0x-00什么是泛型" class="headerlink" title="0x 00什么是泛型"></a>0x 00什么是泛型</h2><p>一般的类和方法，只能使用具体的类型，要么是基本类型，要么是自定义类型，如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大。——《Java编程思想》</p><p><strong>泛型，通俗讲，就是适用于多种类型。从代码上讲，就是对类型实现了参数化</strong>。(当我们自己写一个冒泡排序的时候，我们用的是int，如果我们要排序别的类型，就得对代码改改，但通过泛型，我们可以一次编写，随便使用~)</p><h2 id="0x-01案例引入"><a href="#0x-01案例引入" class="headerlink" title="0x 01案例引入"></a>0x 01案例引入</h2><p>如果现在要实现一个类，类中包含一个数组成员，这个数组中可以存放任何类型的数据，也可以返回数组中的某个下标值。</p><p><strong>因为要放任何类型的数据，因此我们要类的祖先Object数组来存放。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>&#123;<br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span>&#123;<br>        <span class="hljs-keyword">return</span> array[pos];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, Object val)</span>&#123;<br>        array[pos] = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样写，会有<strong>两个缺陷</strong>：</p><p><strong>1.数组想放啥类型的数据就放什么类型的数据，不便于管理。</strong></p><p><strong>2.当我们取出数据的时候，还需要强制类型转换，很麻烦。</strong></p><p>于是，就引出了泛型~</p><h2 id="0x-02泛型"><a href="#0x-02泛型" class="headerlink" title="0x 02泛型"></a>0x 02泛型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArray</span>&lt;T&gt;&#123;<br>    <span class="hljs-keyword">private</span> Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> pos)</span>&#123;<br>        <span class="hljs-keyword">return</span> (T)array[pos];<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(<span class="hljs-type">int</span> pos, T val)</span>&#123;<br>        array[pos] = val;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>当我们这样写，T就相当于参数，我们在使用的时候就可以传入所需要的类型，然后，一旦我们存数据的时候，如果类型不匹配，会报编译错误，然后我们在取数据的时候也不需要再强制类型转换了，解决了我们的痛点。</strong></p><p>如果我们把数组写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">T</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这样写是不对的,会报编译错误</span><br><span class="hljs-keyword">private</span> T[] arr = (T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>]; <span class="hljs-comment">//这样写，也会有问题，因为泛型的编译机制。</span><br></code></pre></td></tr></table></figure><p>小结：</p><p>1.泛型是将数据类型参数化，进行传递的。因此程序员可以在编译时指定</p><p>2.使用<T>表示当前类是一个泛型类</T></p><h2 id="0x-03泛型的编译"><a href="#0x-03泛型的编译" class="headerlink" title="0x 03泛型的编译"></a>0x 03泛型的编译</h2><p>泛型是怎么编译的呢？简单来说，<strong>泛型会再编译的过程中，将所有的T替换为Object</strong>，我们称这种机制为 <strong>擦除机制</strong>。</p><p>现在我们来对这段代码进行解释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> T[] arr = (T[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>如果我们这样写，尽管编译的时候能编译过，但是在Java中不允许你将数组类型强制转换为其他类型，在运行的时候会抛出异常！</p><p><strong>如下代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;abc&quot;</span>;<br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;bcd&quot;</span>;<br>String[] strs = (String[])arr;<br></code></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><img src="/2023/05/17/%E5%8C%85%E8%A3%85%E7%B1%BB-%E8%AE%A4%E8%AF%86%E6%B3%9B%E5%9E%8B/image-20230518162513603.png" class title="image-20230518162513603"><p><strong>原因是：将Object[]分配给String[]引用，程序报错。</strong></p><p><strong>通俗来讲，Object数组中可能存放任何类型的数据，运行时，直接转换，编译器认为是不安全的。</strong></p><p>因此，推荐如下写法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">10</span>];<br></code></pre></td></tr></table></figure><p>底层源码也是这样写的~</p><h2 id="0x-04泛型的上界"><a href="#0x-04泛型的上界" class="headerlink" title="0x 04泛型的上界"></a>0x 04泛型的上界</h2><p>在定义泛型类的时候，有可能会对传入的类型进行一定的约束，可以通过类型边界来约束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArr</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Base</span>&gt;&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>这样写，就只能接受Base类和Base的子类类型了。因此我们可以通过这样的方式对类型进行约束。</p><p>当然，还可以”继承”接口，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFun</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt;<br></code></pre></td></tr></table></figure><p>如果这样写的话，那么传入的那个类型必须是实现了Compareable这个接口，也就是说这个类是可以比较的。</p><p>举个列子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFun</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;T&gt;&gt;&#123;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">findMax</span><span class="hljs-params">(T[] arr)</span>&#123;<br>        <span class="hljs-type">T</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> arr[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(arr[i].compareTo(ans) &gt; <span class="hljs-number">0</span>)&#123;<br>                ans = arr[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Integer[] integers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;;<br>        MyFun&lt;Integer&gt; fun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyFun</span>&lt;&gt;();<br>        System.out.println(fun.findMax(integers));<br>    &#125;<br></code></pre></td></tr></table></figure><p>这样我们通过泛型，实现了一个可以得到任何类型的最大值的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面向对象——简单工厂模式</title>
    <link href="/2023/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、案例引入"><a href="#一、案例引入" class="headerlink" title="一、案例引入"></a>一、案例引入</h1><p><strong>需求</strong>：写一个计算器，实现加减乘除基本功能。</p><p><strong>如果使用面向过程的思想来写</strong>，即用计算机的方式去思考，就会写出如下代码：</p><h2 id="面向过程代码"><a href="#面向过程代码" class="headerlink" title="面向过程代码"></a>面向过程代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                result = numA + numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                result = numA - numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                result = numA * numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result = numA / numB;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span> + numA + symbol + numB + <span class="hljs-string">&quot;=&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这样写，是可以满足需求，但是一旦需求发生改变，增加一个开根号功能，理论上你只需要在switch语句中增加一条，但是这样去写，会让加减乘除功能都来参与编译，万一你手贱，改动了别的功能呢？这就是面向过程所带来的一些弊端。</strong></p><p>举个例子：</p><blockquote><p>一个公司将所有员工的工资算法都放在了一起(就像上面计算器，将所有运算功能放在了一起)，哪天老板让你修改别人的工资，你一看自己工资比较低，还偷偷修改了自己工资的算法。</p><p>所以说这样的代码很危险，毕竟你无法保证每个人都不出错。</p></blockquote><p><strong>所以这时就要用到面向对象的编程思想了。</strong></p><h1 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h1><p>众所周知，面向对象有三大特性：封装，继承、多态。</p><p>我们可以先利用，<strong>封装。</strong></p><p><strong>先将整个程序分成两部分，一个是处理计算的，另一个是处理用户的输入。</strong></p><p>因此我们可以定义两个类，一个是用户类，即处理用户输入，另一个是计算类，用来计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Calculate.GetResult(numA, symbol, numB);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetResult</span><span class="hljs-params">(<span class="hljs-type">int</span> numA, <span class="hljs-type">char</span> symbol, <span class="hljs-type">int</span> numB)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                result = numA + numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                result = numA - numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                result = numA * numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result = numA / numB;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时还是解决不了会改动别的运算中的代码，因此我们还需要用到继承和多态</p><p><strong>我们将每个运算中相同的部分取出，即都需要两个操作数，和一个计算方法。而运算符号是特有的，我们稍后再处理</strong></p><p><strong>所以可以定一个一个父类，包含这些属性和行为。再运用重写，重写各自的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numA;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numB;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumA</span><span class="hljs-params">(<span class="hljs-type">int</span> numA)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numA = numA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumB</span><span class="hljs-params">(<span class="hljs-type">int</span> numB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numB = numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA + numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA - numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA * numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivOperation</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> numA / numB;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>这样来设计的话，当我要让你修改某一个功能的时候，我只需要把这个类给你，而不需要你再给你其他类，这样大大的降低了出错的可能性。</strong></p><p>代码写到这，还不能运行，因为还有符号部分没处理，不过我们可以通过去实例化对象，来处理运行相应的功能。即使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125;<br>        System.out.println(ret);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时代码看起来，<strong>有好多地方都是重复的，很臃肿</strong>，所以，此时我们可是使用<strong>”简单工厂模式</strong>“来帮我们解决。</p><h1 id="三、简单工厂模式"><a href="#三、简单工厂模式" class="headerlink" title="三、简单工厂模式"></a>三、简单工厂模式</h1><p><strong>简单工厂模式，就是通过创建一个类，来帮助你实例化对象，也就是你要实例化谁，直接通过这个“工厂”来创建。</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(<span class="hljs-type">char</span> symbol)</span>&#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在我们要进行加法运算就可以这样写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> OperationFactory.createOperation(symbol);<br>        op.setNumA(numA);<br>        op.setNumB(numB);<br>        ret = op.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样修改以后，就非常简洁了，使用的时候，直接调函数就行了，<strong>而且未来扩展功能的时候，只需要添加一个类，再在工厂类里的switch添加一下就行了。</strong></p><p>这才是面向对象的代码嘛~</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numA;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numB;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumA</span><span class="hljs-params">(<span class="hljs-type">int</span> numA)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numA = numA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumB</span><span class="hljs-params">(<span class="hljs-type">int</span> numB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numB = numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA + numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA - numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA * numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivOperation</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> numA / numB;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(<span class="hljs-type">char</span> symbol)</span>&#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//        if(symbol == &#x27;+&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new AddOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125;else if(symbol == &#x27;-&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new MinOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125; else if(symbol == &#x27;*&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new MulOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125; else if(symbol == &#x27;/&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new DivOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(ret);</span><br><br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> OperationFactory.createOperation(symbol);<br>        op.setNumA(numA);<br>        op.setNumB(numB);<br>        ret = op.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4_18深夜思考</title>
    <link href="/2023/04/19/4-18%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/"/>
    <url>/2023/04/19/4-18%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、为什么选择敲代码</h1><p>因为高考很糟糕，然后稀里糊涂的填了几个志愿，结果莫名其妙的来到了计科专业。不过，在我初中的时候，我也曾想过当一名程序员，可能那时候喜欢游戏吧~ 而到了高中呢，太过压抑，而且我对其他的专业也不懂，在学校只能看见老师，正巧我在b站上看到一个叫国家玮的老师，他讲课的风格颠覆了我对老师的印象，我想成为向他一样的老师，但是最终考的并不如意，或许冥冥之中自由安排…</p><h1>二、为什么选择java而不选择C++</h1><p>我现在(大二下)感觉这个问题其实很奇怪，我觉得大部分都被互联网搞的太焦虑了，大家都不看好java，觉得学java毕业就找不到工作了。我感觉，<strong>首先</strong>找工作不是一门简单的事情，哪有毕业就一定能找到的呢，而且大家都追求好公司，据说不是找不到，是找不到心仪的，有点高不成低不就的感觉；<strong>其次</strong>，难道学C++就一定能找到工作吗？一门语言而已，c++和java不都是擅长做后端开发吗？<strong>最后</strong>，在学c++的时候，我感受到的是语法的复杂，而学习java的时候，我感受到了面向对象的编程方式，还挺好玩，于是我选择了java。</p><p><strong>个人看法</strong>：其实选哪个都差不多，不过对于考研啥的，还是选C++好一点，毕竟考研书啥的资料大部分都是C++的。</p><h1>三、为什么骑行</h1><p>因为在b站上看到了一个博主，骑行了西藏，于是，我想我是否能试试骑行桂林呢？目前已经把桂林骑得差不多了，下个目标可能是柳州了？可能骑行会很累，但我不后悔，这是我自己选择的路~</p><h1>四、最后</h1><p>无论结果如何，我相信，人生没有那条路是白走的，可能会走错了路，但是你看到了别人看不到的风景，路上结识了一辈子的知己，收获了温暖的回忆和宝贵的经历。</p><p>也许，我现在所做的一切，看不到任何成果，但是水滴石穿，绳锯木断，不要迷茫，不要彷徨，我不是没有成长，而是在扎根，在打基础，所有的付出，都会有回报的。</p><p>也许，多年以后，当和家人、朋友坐在一起唠嗑时，打开自己尘封的记忆，那一幕幕，跳出来，依旧鲜活而富有生命力。这些美好的记忆不会随着年华的飘零而逝去，而是会被镌刻在岁月里，最美好的地方。</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数据类型|运算符(与C对比)</title>
    <link href="/2023/04/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%8EC%E5%AF%B9%E6%AF%94/"/>
    <url>/2023/04/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%8EC%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、Java中的数据类型</h1><h2 id="0x01-基本数据类型">0x01 基本数据类型</h2><p>在 Java 中数据类型主要分为两类：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p>基本数据类型有4类：<strong>整形、浮点型、字符型、布尔型</strong>。细分为8种。如下：</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1 字节</td><td>-128 ~ 127</td></tr><tr><td>短整型</td><td>short</td><td>2 字节</td><td>-32768 ~ 32767</td></tr><tr><td>整型</td><td>int</td><td>4 字节</td><td>-2^31 ~ 2^31 - 1</td></tr><tr><td>长整型</td><td>long</td><td>8 字节</td><td>-2^63 ~ 2^63 - 1</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4 字节</td><td>有范围，一般不关注</td></tr><tr><td>双精度浮点数</td><td>double</td><td>8 字节</td><td>有范围，一般不关注</td></tr><tr><td>字符型</td><td>char</td><td>2 字节</td><td>0 ~ 65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>没有明确规定</td><td>true 和 false</td></tr></tbody></table><p><strong>值得注意的是</strong>：这里数据的类型大小和C语言不同的是，<strong>不论是在16位系统还是32位系统下</strong>，都是上述的大小。</p><p><strong>字符型</strong>在这里成了<strong>无符号的数</strong>了，<strong>还扩大成了2个字节</strong>。</p><p><strong>在C语言中，我们知道0表示假，非0表示真，然而在 Java中是使用boolean类型来表示真假，并且boolean类型不能与int类型转化</strong>，因此代码就不能写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-comment">//本意是想循环10次，但java中的boolean不能与int转化。</span><br>&#125;<br><br><span class="hljs-comment">//只能这样写</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>因此， Java 程序员不会遇到下述麻烦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(x = <span class="hljs-number">0</span>) <span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure><h2 id="0x02-类型转换">0x02 类型转换</h2><p>Java 是一个强类型编程语言。<strong>当不同类型之间的变量相互赋值的时候</strong>, 会有教严格的校验</p><p>例如：<strong>当我们将一个高精度的数赋值给低精度的数，由于会发生截断，编译器认为不安全，会报错。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.0</span>;<br>a = d; <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><p>如果是将一个低精度赋值给高精度的数，会进行类型转换。</p><p>类型转换又分为两种：<strong>自动(隐式)类型转换</strong>、<strong>强制(显示)类型转换</strong>。</p><hr><p><strong>自动类型转换</strong></p><p><strong>代码不需要经过任何处理，在代码编译时，编译器会自动进行处理</strong>。特点：<strong>数据范围小的转为数<br>据范围大的时会自动进行</strong>  。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>l = n; <span class="hljs-comment">//发生自动类型转换</span><br></code></pre></td></tr></table></figure><p>自动类型转换路线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>-&gt;<span class="hljs-type">short</span>-&gt;<span class="hljs-type">int</span>-&gt;<span class="hljs-type">long</span>-&gt;<span class="hljs-type">float</span>-&gt;<span class="hljs-type">double</span><br><span class="hljs-type">char</span>-&gt;<span class="hljs-type">int</span>-&gt;<span class="hljs-type">long</span>-&gt;<span class="hljs-type">float</span>-&gt;<span class="hljs-type">double</span><br></code></pre></td></tr></table></figure><p>可以将左边类型的变量赋值给右边类型的变量。</p><p><strong>强制类型转换：</strong></p><p>当进行操作时，代码需要经过一定的格式处理，不能自动完成。特点：数据范围大的到数据范围小的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>n = (<span class="hljs-type">int</span>)l; <span class="hljs-comment">//强制类型转换。告诉编译器我对此次类型转换负责！</span><br></code></pre></td></tr></table></figure><p>但是对于byte、short、char类型有些特别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>理论上这些操作，编译器不能通过，但是有这样的一个规则：</p><p><strong>当把具体数赋值给byte、short、char时，会先判断该数是否在这个类型的范围内，如果在就可以.</strong></p><p>这里的<strong>具体数值指的是字面常量：不能是变量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//可以</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">//byte b2 = a //不可以</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//short s1 = b1 + s; //不可以  </span><br></code></pre></td></tr></table></figure><h2 id="0x03-类型提升">0x03 类型提升</h2><p>不同类型的数据之间相互运算时，数据类型小的会被提升到数据类型大的。</p><ol><li><strong>int</strong>与<strong>long</strong>之间：<strong>int</strong>会被提升为<strong>long</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 编译出错: a + b==&gt;int + long--&gt; long + long 赋值给int时会丢失数据</span><br><span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 编译成功：a + b==&gt;int + long---&gt;long + long 赋值给long</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>byte</strong>与<strong>byte</strong>的运算</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>System.out.println(c);<br><span class="hljs-comment">// 编译报错</span><br>Test.java:<span class="hljs-number">5</span>: 错误: 不兼容的类型: 从<span class="hljs-type">int</span>转换到<span class="hljs-type">byte</span>可能会有损失<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br></code></pre></td></tr></table></figure><p>原因：由于计算机的 CPU 通常是按照 4 个字节为单位从内存中读写数据. <strong>为了硬件上实现方便, 诸如 byte 和 short这种低于 4 个字节的类型, 会先提升成 int</strong>, 再参与计算</p><p>因此要想编译通过，需要进行强制类型转换。</p><h1>二、运算符</h1><p>Java中运算符可分为以下：算术运算符(+ - */)、关系运算符(&lt; &gt; ==)、逻辑运算符、位运算符、移位运算符以及条件运算符等 。</p><p><strong>C语言中只能对整数取模</strong>，<strong>但在 Java 中 % 不仅可以对整型取模，也可以对double类型取模</strong>，但是没有意义，一般都是对整型取模的 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">11.5</span> % <span class="hljs-number">2.0</span>);<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><p><strong>对于++和–：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>b = b + <span class="hljs-number">1</span>; <span class="hljs-comment">//报错</span><br>b++; <span class="hljs-comment">//可以 会优化为 b = (byte)(b + 1)</span><br></code></pre></td></tr></table></figure><p><strong>对于 &amp;&amp;</strong> , 如果<strong>左侧表达式值为</strong> <strong>false,</strong> <strong>则表达式结果一定是</strong> <strong>false,</strong> <strong>无需计算右侧表达式</strong>.</p><p><strong>对于 ||</strong>, 如果<strong>左侧表达式值为</strong> <strong>true,</strong> <strong>则表达式结果一定是</strong> <strong>true,</strong> <strong>无需计算右侧表达式</strong>.</p><p><strong>&amp; 和 |</strong> ，如果表达式结果为 boolean 时, 也表示逻辑运算. 但与 &amp;&amp; || 相比, 它们不支持短路求值 ，因此他会对两边的表达式对进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">10</span> &gt; <span class="hljs-number">20</span> &amp; <span class="hljs-number">10</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// 程序抛出异常</span><br>System.out.println(<span class="hljs-number">10</span> &lt; <span class="hljs-number">20</span> | <span class="hljs-number">10</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// 程序抛出异常</span><br></code></pre></td></tr></table></figure><p><strong>对于移位操作符，与C语言不同的是，还有无符号右移&gt;&gt;&gt;</strong></p><p>无符号右移 &gt;&gt;&gt;: <strong>最右侧位不要了, 最左侧补 0</strong></p><p>即不会关注一个数的二进制中的符号是啥，直接补0，所以一个负数将会变成很大的正数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识java|Java的发展史|环境变量|JDK</title>
    <link href="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/"/>
    <url>/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文将讲述什么是Java、Java的发展史、比较一下C&#x2F;C++和Java的区别、环境变量的作用以及JDK是什么。</p></blockquote><h1 id="一、认识Java"><a href="#一、认识Java" class="headerlink" title="一、认识Java"></a>一、认识Java</h1><h2 id="0x01-Java是什么"><a href="#0x01-Java是什么" class="headerlink" title="0x01 Java是什么"></a>0x01 Java是什么</h2><p>Java是一门优秀的<strong>程序设计语言</strong>，它具有令人赏心悦目的语法和易于理解的语义  。</p><p>Java凭借着<strong>友好的语法</strong>、<strong>面向对象</strong>、<strong>内存管理</strong>和<strong>最棒的跨平台可移植性</strong>来吸引程序员。</p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410201938465.png" class><p>（Java之父——詹姆斯·高斯林)</p><p>Java有这样一句口号：“Write once，run anywhere” 即 <strong>一次编译，到处运行</strong>。指的是你可以写一个Java程序，然后能够在你朋友所拥有的的任何设备上执行。</p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410202641113.png" class title="image-20230410202641113"><h2 id="0x02-Java发展史"><a href="#0x02-Java发展史" class="headerlink" title="0x02 Java发展史"></a>0x02 Java发展史</h2><blockquote><p>Java 语言源于 1991 年 4 月，Sun 公司 <strong>James Gosling</strong>博士 领导的绿色计划(Green Project) 开始启动，此计划最初的目标是开发一种能够在各种消费性电子产品(如机顶盒、冰箱、收音机等)上运行的程序架构。这个就是Java的前身： Oak (得名与Java创始人James Gosling办公室外的一棵橡树)，但由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着<strong>1995</strong>年代互联网的发展<strong>，Sun公司看见</strong>Oak<strong>在互联网上应用的前景，于是改造了</strong>Oak<strong>，于</strong>1995<strong>年</strong>5<strong>月以</strong>Java<strong>的名称正式发布，并提出</strong>“Write once, Run anywhere” <strong>的口号</strong>。  </p></blockquote><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410203130293.png" class title="image-20230410203130293"><h2 id="0x03-Java-VS-C"><a href="#0x03-Java-VS-C" class="headerlink" title="0x03 Java VS C++"></a>0x03 Java VS C++</h2><h3 id="1、简单性"><a href="#1、简单性" class="headerlink" title="1、简单性"></a>1、简单性</h3><p>在Java中剔除了C++中许多很少使用、难以理解、易混淆的特性。可以这样理解：Java语法是C++语法的一个”纯净”版本。<strong>例如：Java中没有头文件、指针语法、结构体、联合体、运算符重载。</strong></p><h3 id="2、健壮性"><a href="#2、健壮性" class="headerlink" title="2、健壮性"></a>2、健壮性</h3><p>Java投入了大量的精力进行早期的问题检测以及后期的动态检测。<strong>Java采用的指针模型(底层)可以消除重写内存和损坏数据的可能性。例如：C++的拷贝构造，当对象销毁自动调用析构函数，可能由于前面是写的浅拷贝，而导致同一块空间释放了两次。</strong></p><h3 id="3、可移植性"><a href="#3、可移植性" class="headerlink" title="3、可移植性"></a><strong>3、可移植性</strong></h3><p>与C和C++不同的，Java规范中没有“依赖具体实现”的地方。<strong>基本教据类型的大小以及有关运算都做了明确的说明</strong>  </p><p>例如：<strong>Java 中的 int 永远为 32 位的整数</strong>  ，<strong>而在 C&#x2F;C++ 中</strong>， <u>int 可能是 16 位整数、 32 位整数</u>， 也可能是编译器提供商指定的其他大小 。唯一的限制只是 int 类型的大小不能低于 short int, 并且不能高于 long int。  </p><p>在 Java 中， 数据类型具有固定的大小， 这消除了代码移植时令人头痛的主要问题。 二进制数据以固定的格式进行存储和传输， 消除了字节顺序的困扰  。<strong>例如：在C&#x2F;C++中还存在大小端字节序存储的问题。</strong></p><h2 id="4、动态性"><a href="#4、动态性" class="headerlink" title="4、动态性"></a>4、动态性</h2><p>Java 与 C 或 C++ 相比更加具有动态性。 它能够适应不断发展的环境库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响。  一个很好的例子是： 从 Internet 下载代码，然后在浏览器上运行。 如果使用 C 或 C++, 这确实难度很大，不过 Java 设计者很清楚动态语言可以很容易地实现运行程序的演进。  </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>语言没有优劣之分，这个世界不是非黑即白的，每个语言都可能在某些领域表现出比其他语言更出色</strong>。比如：Objective C 和后来的 Swift 在 iOS 设备上就有着无可取代的地位， 浏览器中的处理几乎完全由 JavaScript 掌控。 Windows 程序通常都用 C++ 或 C# 编写 。Java 在服务器端编程和跨平台客户端应用领域则很有优势 。</p><p><strong>Java 的成功源于其类库能够让人们轻松地完成原本有一定难度的事情</strong>。 例如：联网Web 应用和并发。Java 减少了指针错误， 这是一个额外的好处， 因此使用 Java 编程的效率更高。但这些并不是 Java 成功的全部原因。  </p><h1 id="二、环境变量"><a href="#二、环境变量" class="headerlink" title="二、环境变量"></a>二、环境变量</h1><p>有很多人在装Java时，上网查资料会发现，都装完JDK都会让你去配置一下环境变量。</p><p><strong>那这是为什么呢？</strong></p><p>举个例子：当我运行游戏的时候，如果不是用快捷打开方式，那我们就需要去游戏安装的目录下找到exe文件打开，但是如果我们配置了环境变量，那我们可以随便打开一个命令窗口，输入指令，即可打开游戏。</p><p><strong>类比到编程：</strong></p><p>相当于在函数A中，创建了一个局部变量，在函数B中无法使用这个变量，但当我们配置了环境变量后，这个局部变量升级成全局变量了，现在在函数B中可以使用这个变量。</p><h1 id="三、JDK"><a href="#三、JDK" class="headerlink" title="三、JDK"></a>三、JDK</h1><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230411215831748.png" class title="image-20230411215831748"><h2 id="0x01-JDK"><a href="#0x01-JDK" class="headerlink" title="0x01 JDK"></a>0x01 JDK</h2><p>JDK全称 Java Development Kit， 即Java开发工具包，包含了Javac编译工具，java，JRE等工具。</p><p>JDK &#x3D; JRE + 开发工具集(javac, javap, java…….)</p><h2 id="0x02-JRE"><a href="#0x02-JRE" class="headerlink" title="0x02 JRE"></a>0x02 JRE</h2><p>JRE全称 Java Runtime Environment, 即Java运行时环境，包含了 JVM，Java基础类库。</p><p>JRE &#x3D; JVM + JavaSE标准类库</p><h2 id="0x03-JVM"><a href="#0x03-JVM" class="headerlink" title="0x03 JVM"></a>0x03 JVM</h2><p>JVM全称 Java Virtual Machine，即Java虚拟机， 用来运行Java代码。</p><p><strong>JDK 、JRE 、JVM关系图：</strong></p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410212254607.png" class title="image-20230410212254607"><hr><blockquote><p>参考资料：</p><p>《Java核心技术卷》</p><p>《Head First Java》</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言文件操作</title>
    <link href="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、文件的分类</h1><h2 id="1-1程序文件">1.1程序文件</h2><blockquote><p>例如：源程序文件 即 .c文件</p><p>​可执行程序 即 .exe文件</p><p>​…</p></blockquote><h2 id="1-2数据文件">1.2数据文件</h2><blockquote><p>例如：PPT、word文档、Excel表格…</p></blockquote><h1>二、文件的打开与关闭</h1><p>对于不使用文件相关操作的时候，数据的输入输出都是以<strong>终端</strong>为对象，即从终端的键盘输入数据，将<strong>内存中的运行结果</strong>输出到<strong>终端</strong>上。如下：</p><img src="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20230403202819947.png" class><p><strong>注意：输入输出都是站在内存的角度来看待的！</strong></p><hr><p>但是如果是对文件操作，同理。</p><p>如下：</p><img src="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20230403203212563.png" class><h2 id="2-1文件指针">2.1文件指针</h2><p><strong>每个被使用的文件</strong>都在<strong>内存</strong>中开辟了一个相应的<strong>文件信息区</strong>，用来存放，文件的名字，文件当前的位置等信息。</p><p>这些信息是<strong>保存在一个结构体变量</strong>中，该结构体类型是由系统声明的，取名<strong>FILE</strong></p><p><strong>例如：在VS2013编译环境下，就有如下申明：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> &#123;</span><br>    <span class="hljs-type">char</span> *_ptr;<br>    <span class="hljs-type">int</span> _cnt;<br>    <span class="hljs-type">char</span> *_base;<br>    <span class="hljs-type">int</span> _flag;<br>    <span class="hljs-type">int</span> _file;<br>    <span class="hljs-type">int</span> _charbuf;<br>    <span class="hljs-type">int</span> _bufsiz;<br>    <span class="hljs-type">char</span> *_tmpfname;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> <span class="hljs-title">FILE</span>;</span><br></code></pre></td></tr></table></figure><p>因此我们可以通过<strong>创建一个文件指针</strong>来对文件完成相应的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE* pf<span class="hljs-comment">//文件指针</span><br></code></pre></td></tr></table></figure><p><strong>ANSIC 规定使用fopen函数来打开文件，fclose来关闭文件</strong></p><p>举例：对一个文件进行写的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//打开文件，&quot;w&quot;表示是以写的方式打开文件。</span><br>FILE* pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <br>    <span class="hljs-comment">//关闭文件</span><br>    fclose(pf);<br>    pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打开文件方式有许多，如下：</strong></p><table><thead><tr><th>文件使用方式</th><th>含义</th><th>如果指定文件不存在</th></tr></thead><tbody><tr><td>“r”（只读）</td><td>为了输入数据，打开一个已经存在的文本文件</td><td>出错</td></tr><tr><td>“w”（只写）</td><td>为了输出数据，打开一个文本文件</td><td>建立一个新的文件</td></tr><tr><td>“a”（追加）</td><td>向文本文件尾添加数据</td><td>建立一个新的文件</td></tr><tr><td>“rb”（只读）</td><td>为了输入数据，打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb”（只写）</td><td>为了输出数据，打开一个二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab”（追加）</td><td>向一个二进制文件尾添加数据</td><td>出错</td></tr><tr><td>“r+”（读写）</td><td>为了读和写，打开一个文本文件</td><td>出错</td></tr><tr><td>“w+”（读写）</td><td>为了读和写，建议一个新的文件</td><td>建立一个新的文件</td></tr><tr><td>“a+”（读写）</td><td>打开一个文件，在文件尾进行读写</td><td>建立一个新的文件</td></tr><tr><td>“rb+”（读写）</td><td>为了读和写打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb+”（读写）</td><td>为了读和写，新建一个新的二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab+”（读写）</td><td>打开一个二进制文件，在文件尾进行读和写</td><td>建立一个新的文件</td></tr></tbody></table><p>因此，当我们要写一个文件，可以使用fopen函数，但打开也要关闭，可以使用fclose函数，最后再将指针置空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//打开文件</span><br>FILE* pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-comment">//确保打开成功</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//写文件</span><br><br><span class="hljs-comment">//关闭文件</span><br>fclose(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>三、文件的读写</h1><p>文件的读写可以使用如下函数：</p><table><thead><tr><th>字符输入函数</th><th>fgetc</th><th>所有输入流</th></tr></thead><tbody><tr><td>字符输出函数</td><td>fputc</td><td>所有输出流</td></tr><tr><td>文本行输入函数</td><td>fgets</td><td>所有输入流</td></tr><tr><td>文本行输出函数</td><td>fputs</td><td>所有输出流</td></tr><tr><td>格式化输入函数</td><td>fscanf</td><td>所有输入流</td></tr><tr><td>格式化输出函数</td><td>fprintf</td><td>所有输出流</td></tr><tr><td>二进制输入</td><td>fread</td><td>文件</td></tr><tr><td>二进制输出</td><td>fwrite</td><td>文件</td></tr></tbody></table><p><strong>这里对所有输入输出流说明：</strong></p><p><strong>流是一种抽象出来的概念，程序员只需要关注将数据输出到流中或者从流中获取数据，而不用关注流怎么跟文件、屏幕、网络、外部设备怎么进行交互。</strong></p><p>我们一般使用的流：</p><table><thead><tr><th>读写文件</th><th>文件流</th></tr></thead><tbody><tr><td><strong>在终端屏幕上打印输出</strong></td><td><strong>标准输出流-stdout</strong></td></tr><tr><td><strong>键盘上输入数据</strong></td><td><strong>标准输入流-stdin</strong></td></tr></tbody></table><p>因此上面的函数，还可以将数据输入输出到屏幕上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>fputc(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码也可以起到printf函数的作用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>筛质数</title>
    <link href="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
    <url>/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>质数的定义</h1><p>质数又称素数。质数是指在大于1的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394?fromModule=lemma_inlink">自然数</a>中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111?fromModule=lemma_inlink">因数</a>的自然数。</p><h1>1-N的质数</h1><p><strong>题目描述：</strong></p><blockquote><p>寻找1-N之间的所有质数。</p><p>将其输出出来。</p></blockquote><h2 id="方法一：朴素法">方法一：朴素法</h2><p><strong>思路：</strong></p><blockquote><p>根据定义，只要循环2 - X-1 的数，看其是否是X的因数，如果都不是，那这个数就是素数。</p><p>可以优化，即找2 - 根号x的数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//循环2- sqrt(x)的数，看是否为其因数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(x); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//输入</span><br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//由于素数是从2开始的</span><br>    <span class="hljs-comment">//循环2-N的数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果是素数，输出即可</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(i))<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然效率是不够的高的。每次都要找2-sqrt(x)的数来判断是否为因数。</p><p><strong>假设找1-10000内的数，则要循环117527次。</strong></p><h2 id="方法二：埃氏筛法">方法二：埃氏筛法</h2><p><strong>思路：</strong></p><blockquote><p>埃氏筛法是通过先找到素数，然后筛选不是这些素数倍数的数。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>2是素数，然后直接排除4、6、8、10…</p><p>3由于不是2的倍数，所以没有被筛选，此时小于3的所有数就都筛选过了，此时3就是素数了。然后通过3，直接排除6、9、12…</p><p>4由于被筛掉了，所以不用看了。</p><p>5不是2、3的倍数，此时小于5的所有数也都被筛选了，5也就是素数。然后再排除其倍数。</p></blockquote><img src="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/image-20230328215621016.png" class title="image-20230328215621016"><p><strong>不过这种做法也是有一点缺陷的，即6被筛选了两次.</strong></p><hr><p><strong>将原理运用：</strong></p><blockquote><p>首先创建一个大小为N+1的数组。里面存放能表示真或者假两种状态的标记。</p><p>初始化数组，假设全为真，表示所有数为素数。</p><p>要特判下标为0、1的，因为其不符合素数定义。</p><p>然后循环2-N的数，如果这个数为素数，则去找其倍数，修改为非素数。即1变0，真变假。</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//创建一个数组来表示0-N的数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Prime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    <br>    <span class="hljs-comment">//不符合定义</span><br>Prime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>Prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">//循环2-N的数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果是素数就筛选其倍速</span><br><span class="hljs-keyword">if</span> (Prime[i])<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= N; j += i)<br>&#123;<br>Prime[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>埃氏筛法可快多了，当要找1-10000内的数，只要31841次。</strong></p><h2 id="方法三：欧拉筛法">方法三：欧拉筛法</h2><p><strong>介绍：</strong></p><blockquote><p>欧拉筛法，也称线性筛，是在埃氏筛的基础上的优化，因为埃氏筛会某一个合数进行多少筛选。本质上是通过合数的最小的质因子筛掉数字。</p><p>大致流程：收集素数，然后遍历每一个数，让其乘上收集到的素数，然后筛选这个数。注意，因为是通过最小质因子筛选，如果当前数的因数有收集到的素数，需要终止。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>2是素数，此时素数列表中只有2，让其 *2，筛选掉4</p><p>3没被筛选，此时将其加入素数列表，列表内容为2、3,让3 * 2, 3 * 3，筛选掉6、9</p><p>4被筛选掉了，不同于埃氏筛法，依旧要进行操作，让其成上2，筛选掉8，<strong>然后直接结束4的操作</strong>！<strong>因为欧拉筛的原理是通过最小质因子筛选。2是4的因子，不符合规则。所以不进行 4 * 3的操作。</strong></p><p>5没被筛选，加入素数列表，列表内容为2、3、5，然其乘上这些素数。</p><p>6被筛选掉了，让其乘上2, 2 * 6 = 12，然后直接结束6的操作！</p><p>…</p><p>这样就能保证对每个数只筛选一次了。</p></blockquote><img src="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/image-20230328222516619.png" class title="image-20230328222516619"><p><strong>这种筛选法，对于一个数只会筛掉一次。</strong></p><p><strong>思路：</strong></p><blockquote><p>首先我们需要一个数组，标记这些数是否为质数。因为我们每个数都要乘以之前的所有素数，因此我们需要一个数组来记录素数。</p><p>如果是素数就加入数组。</p><p>对每个数进行乘上素数的操作，然后筛选数</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//判定是否为素数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;<br>isPrime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//储存素数的数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Prime;<br>    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果为素数就加入数组</span><br><span class="hljs-keyword">if</span> (isPrime[i])<br>Prime.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-comment">//乘以素数进行筛选，需要注意是否会越界</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; Prime.<span class="hljs-built_in">size</span>() &amp;&amp; i * Prime[j] &lt;= N; j++)<br>&#123;<br>isPrime[i * Prime[j]] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (i % Prime[j] == <span class="hljs-number">0</span>) <span class="hljs-comment">//最关键的一步！因为欧拉筛的本质是通过最小质因子来筛的</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : Prime)<br>cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>欧拉筛是一种非常高效的算法，如果是找10000内的质数，只需要循环8770次，比埃氏还要快的多。</strong></p><p><strong>对比：</strong></p><table><thead><tr><th>方法：</th><th>1-10000的数</th></tr></thead><tbody><tr><td><strong>朴素筛法</strong></td><td>117527</td></tr><tr><td><strong>埃氏筛</strong></td><td>31841</td></tr><tr><td><strong>欧拉筛(线性筛)</strong></td><td>8770</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>案例引入：</h1><blockquote><p>有一个猜数字的游戏，即我讲选中1-100以内的某一个数，然后你来猜测，如果你猜的数比我选的数大，我会告诉你大了，反之亦然。</p></blockquote><p><strong>其实这个游戏就运用到了二分法/折半查找的思路。即每次筛选都排除掉一半的错误。</strong></p><p>二分查找是一个非常厉害的算法，它的<strong>时间复杂度在对数阶</strong>。</p><hr><h1>例题一：找个数</h1><h2 id="题目描述："><strong>题目描述：</strong></h2><blockquote><p>运用二分法的思想，寻找一个有序数组中的一个数的下标。这个数必定存在，数组中不存在重复元素项。</p></blockquote><h2 id="输入："><strong>输入</strong>：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span>&#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br></code></pre></td></tr></table></figure><h2 id="输出："><strong>输出：</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="思路："><strong>思路：</strong></h2><blockquote><p>定义一个左边界，定义一个右边界</p><p>然后每次比较区间中间的数和目标值</p><p>修改区间，就能删除一半的元素。</p></blockquote><h2 id="代码："><strong>代码：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = size - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//二分查找的细节</span><br><span class="hljs-keyword">while</span> (left &lt;= right) <span class="hljs-comment">//这里是小于等于呢？还是小于？ 这里先采用小于等于的写法，本质是取左闭右闭区间，[left, right]</span><br>&#123;<br>        <br><span class="hljs-comment">//计算中间的那个元素的下标</span><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//如果要找的数小于中间的那个数</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br><span class="hljs-comment">//怎么修改边界与上面的终止条件有关</span><br>right = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果找到了就直接返回这个元素的下标</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br><br><span class="hljs-comment">//计算数组中元素个数</span><br><span class="hljs-type">int</span> size = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br><span class="hljs-type">int</span> index = BinarySearch(arr, target, size);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了，这个数在数组中的下标为：%d&quot;</span>, index);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="细节："><strong>细节：</strong></h2><blockquote><p>如果自己去写，很有可能写错，因为根据你<strong>所选取的区间不同</strong>，就会有<strong>其他几种写法</strong>。</p><p>例如 : 假设选取[left, right)区间，即左闭右开区间(上面选取了左闭右闭区间)</p></blockquote><h2 id="代码如下："><strong>代码如下：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-type">int</span> right = size;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">while</span> (left &lt; right)<br>&#123;<br><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br>right = mid;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意："><strong>注意：</strong></h2><blockquote><p>我们要<strong>始终满足我们选取二分区间的定义</strong>，即左边界能不能取得到？右边界能不能取得到？</p><p>如果能取得到，那么修改的时候就要注意了。</p><p>很多人由于不注意细节，加上测试的数据不够多，很容易误以为自己写对了二分查找。</p></blockquote><h1>例题二：搜索插入位置</h1><h2 id="题目描述：-2"><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>提示:</p><p>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 为 <strong>无重复元素</strong> 的 升序 排列数组<br>-104 &lt;= target &lt;= 104</p></blockquote><h2 id="示例：">示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">2</span><br>    <br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">1</span><br>    <br>示例 <span class="hljs-number">3</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">7</span><br>输出: <span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><h2 id="思路：-2">思路：</h2><blockquote><p>读题，满足了二分法的条件，即数组有序。还告诉了请务必使用复杂度为O(log n) 的算法。</p><p>下面考虑两种情况：</p><p>1、如果数组中有这个元素，那么直接返回这个元素的下标即可。</p><p>2、如果数组中没有这个元素呢？我们通过一个叫做&quot;循环不变量的东西&quot;(下面会讲),可以得出最后所求的位置一定在left/right + 1上。</p></blockquote><h2 id="代码：-2">代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = target - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right -left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[mid])<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//或者right + 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>二分查找中的循环不变量：</h1><p><strong>所谓的循环不变量，其实就是二分的过程中会发现，left左边的数全部小于目标值，而right的右边全部大于目标值。</strong></p><h2 id="举例：">举例：</h2><p><strong>假设现在要插入一个47，那么肯定得在下标为4的位置插入。</strong></p><table><thead><tr><th>left</th><th></th><th></th><th>mid</th><th></th><th></th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left</th><th>mid</th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left、right、mid</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th>right</th><th>left</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><p><strong>所以返回left 或者 right+1</strong>。<strong>因为left左边都是小于目标值的，那么就应该插入在比目标值小的序列的后面。因为right右边都是大于目标值的，那么就应该插入在比目标值大的序列的前面。</strong>（以上都是对于没有重复项的序列）</p><hr><h1>例题三：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h1><h2 id="题目描述：-3"><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p>提示：</p><p>0 &lt;= nums.length &lt;= 105<br>-109 &lt;= nums[i] &lt;= 109<br>nums 是一个非递减数组<br>-109 &lt;= target &lt;= 109</p></blockquote><h2 id="示例：-2">示例：</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br>示例 3：<br>输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="思路：-3">思路：</h2><blockquote><p>注意：</p><p>此题给的有序序列是<strong>有重复项</strong>的，因此当我们的中间值等于目标值了，我们<strong>先不急着返回</strong>，因此循环中只有两个选择了，等于的情况可以<strong>合并</strong>到别的情况中去。</p><p>现假设合并到中间值大于目标值。</p><p>由于循环不变量的原理，<strong>left左边的数一定是小于目标值，right右边的数一定是大于等于目标值，那么元素的第一个出现的位置一定是在left或者right + 1的位置。</strong></p><p><strong>那么元素最后一个出现的位置呢？只要我们查找比目标值大1的元素的位置然后减1就行了。</strong></p></blockquote><h2 id="特殊情况的考虑：">特殊情况的考虑：</h2><blockquote><p>如果没有出现过目标值呢？依旧会返回一个值，但是这个值是 目标值插入这个位置后依旧是有序的时候的位置。因此判断一下这个位置上的数是否为目标值，就可以知道有没有出现过了。</p><p>如果序列中所有值都小于目标值呢？二分会返回一个我们不可访问的地方。需要判断处理。</p></blockquote><hr><h2 id="代码：-3">代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//用来寻找第一次出现的边界</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m_low_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        ans[<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-built_in">m_low_bound</span>(nums, target);<br>       <span class="hljs-comment">//需要注意的地方！</span><br>        <span class="hljs-keyword">if</span>(start &gt;= nums.<span class="hljs-built_in">size</span>() || target != nums[start])<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//记得减1</span><br>        <span class="hljs-type">int</span> end = <span class="hljs-built_in">m_low_bound</span>(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>        ans[<span class="hljs-number">0</span>] = start;<br>        ans[<span class="hljs-number">1</span>] = end;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1>拓展：lower_bound</h1><img src="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20230328211735342.png" class title="image-20230328211627216"><p>C++的库函数中有一个叫lower_bound()的函数。</p><p><strong>函数的功能：</strong></p><blockquote><p>1、如果数组中存在目标值，则返回第一个是目标值的下标。</p><p>2、如果数组中不存在，则返回这个数应该出现的位置。</p></blockquote><p><strong>使用如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos1 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos2 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos3 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;1 出现的位置：&quot;</span> &lt;&lt; pos1 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2 出现的位置：&quot;</span> &lt;&lt; pos2 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出3</span><br>cout &lt;&lt; <span class="hljs-string">&quot;3 出现的位置：&quot;</span> &lt;&lt; pos3 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出4</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷宫</title>
    <link href="/2023/03/27/%E8%BF%B7%E5%AE%AB/"/>
    <url>/2023/03/27/%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、迷宫问题</h1><h2 id="题目描述："><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc">https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc</a><br>来源：牛客网</p><p>定义一个二维数组 N*M ，如 5 × 5 数组下所示：</p><p>int maze[5][5]= {<br>0, 1, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 1, 0,<br>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。</p><p>数据范围： 2 &lt;= n,m &lt;= 10,  输入的内容只包含 0 &lt;= val &lt;= 1</p></blockquote><h2 id="输入描述："><strong>输入描述：</strong></h2><blockquote><p>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p></blockquote><h2 id="输出描述"><strong>输出描述:</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">左上角到右下角的最短路径，格式如样例所示。<br></code></pre></td></tr></table></figure><p><strong>示例1</strong></p><h2 id="输入">输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="输出">输出</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="求解：">求解：</h2><p><strong>第一步：</strong></p><blockquote><p>首先我们先把简单的输入做好，然后再专心写怎么去找。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步：</strong></p><blockquote><p>因为深度优先搜索(DFS)非常适用于找是否有解的题，正巧题目说了有且仅有一条通路，所以非常契合。</p><p>那DFS怎么实现呢？用栈这种数据结构呢？还是用递归——函数调用创建栈帧？ 为了精简就用递归吧。</p><p><strong>递归三要素：</strong></p><p>1、确定递归函数的参数和返回值</p><p>2、确定终止条件</p><p>3、确定单层递归逻辑</p></blockquote><p><strong>1、确定递归函数的参数和返回值</strong></p><p>首先我们肯定要<strong>传入这个二维矩阵</strong>，其次我们还要<strong>传入迷宫起点坐标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">DFS</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br></code></pre></td></tr></table></figure><blockquote><p>那要不要传迷宫的长宽呢？因为我们用了vector容器，可以通过调用接口函数，直接得出，因此不用</p></blockquote><p>最后我们确定返回值，因为我们<strong>只要求是否有解</strong>，<strong>如果有的话直接返回true, 没有的话返回false不就行啦，所以返回值定位bool</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>2、确定终止条件</strong></p><p>显然<strong>走到出口就停止</strong>呗。即坐标(N - 1, M - 1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>3、确定单层递归逻辑</strong></p><p>首先我们在迷宫中不知道哪里能走，因此只能“摸黑走”，随便走，但<strong>总要规定一个顺序</strong>，我们这里<strong>假设就用上下左右</strong>的顺序去“走迷宫”。</p><p>但是，我们总不能是墙也走吧，或者走出迷宫边界，因此我们还要<strong>判定是否能向那一个方向走。</strong></p><p>写一个函数用来判断能不能走isPass</p><p><strong>首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳。</span><br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>    <br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>至此，我们整个递归的逻辑已经写完了。但是这道题需要让你输出从起点到终点的路径坐标。</p><p>如果我们走到一个死胡同，此时我们记录了这个死胡同的所有坐标，这不是我们想要的，因此我们要删除这些坐标。仔细思考，会发现，我们<strong>所需要删除的是所有后面来的坐标</strong>，这不就是<strong>后进先出</strong>嘛，所以我们就想到了用栈来记录。</p><p>因为<strong>坐标是两个整形的组合</strong>，类似一个结构体，我们可以<strong>用pair来记录坐标</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br></code></pre></td></tr></table></figure><p>至此，我们能记录出所有坐标辣，但是<strong>坐标顺序是反的</strong>。<strong>因此还要借助一个栈来辅助逆置</strong>。最后输出这个辅助栈就ok了</p><h2 id="最终代码：">最终代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, y));<br><br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">//归的过程</span><br><span class="hljs-comment">//因为走不通，返回false，并且要输出错误路的坐标</span><br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>(maze, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; help_st;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>help_st.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">while</span> (!help_st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>help_st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二届程序设计大赛</title>
    <link href="/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"/>
    <url>/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-闰年"><strong>1.闰年</strong></h2><p>问题描述</p><p>给定一个年份，判断这一年是不是闰年。当以下情况之一满足时，这一年是闰年：</p><ol><li>年份是4的倍数而不是100的倍数；</li><li>年份是400的倍数。<br>其他的年份都不是闰年。</li></ol><p><strong>输入格式</strong><br>输入包含一个整数y，表示当前的年份。</p><p><strong>输出格式</strong><br>输出一行，如果给定的年份是闰年，则输出yes，否则输出no。</p><p>说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。</p><p><strong>思路：</strong></p><p>按照题目描述输出即可。<strong><u>四年一润且百年不润 或 四百年一润</u></strong></p><p>因此可以得出这样的表达式：</p><p><strong>(year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)</strong></p><p>之后结合if语句判断即可~</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;year);<br>    <br>    <span class="hljs-comment">//如果表达式为真，则执行输出yes</span><br>    <span class="hljs-keyword">if</span>((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-找素数"><strong>2.找素数</strong></h2><p>输入一个正整数n，计算输出小于n的最大素数</p><p><strong>思路：</strong></p><p>抓住核心：<strong>小于n，最大，素数</strong></p><p><u><strong>1.分析素数：大于1，只能被1和自身整除</strong></u></p><p><u><strong>2.循环找出大于1，小于n的数</strong></u></p><p><u><strong>3.检查循环所枚举出来的数是否为素数</strong></u></p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//检查它是不是素数,如果是则返回1，不是返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br><span class="hljs-comment">//循环2 - num-1 之间的数，看是否能被num整除，能整除则说明不是</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= num - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (num % j == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br><span class="hljs-comment">//先得到小于n的数</span><br><br><span class="hljs-comment">//因为要最大，所以从后往前找</span><br><span class="hljs-comment">//但是因为要得到素数，而最小的素数是2，所以循环到2就行</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">2</span>; i--)<br>&#123;<br><span class="hljs-comment">//判断是否为素数</span><br><span class="hljs-keyword">if</span> (is_Prime(i) == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//如果当前数为素数，则一定是小于n的最大素数了</span><br>            <span class="hljs-comment">//中止循环即可~</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-爬楼梯"><strong>6.爬楼梯</strong></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><p>由于<strong>每次只能爬一个台阶或者两个台阶</strong>，因此<strong>第n阶台阶只能由第n-1阶台阶和n-2阶台阶到达</strong>。</p><p>所以我们<strong>只要知道</strong>了爬到n-1阶台阶有多少中走法和n-2阶台阶有多少种走法，<strong>就能得到</strong>爬到n阶台阶有多少种走法。</p><p>现用函数的形式表示n阶台阶的不同方法数：</p><p>f(n) = f(n - 1) + f(n - 2)。</p><p>f(n - 1) = f(n - 1 - 1) +f(n - 1 - 2)</p><p>f(n - 2) = f(n - 2 - 1) + f(n - 2 - 2)</p><p>…</p><p>我们会发现，每次操作都差不多，因此我们可以用<strong>递归解决问题</strong>(循环当然也可以)。</p><p>但有<strong>两个特例</strong>：</p><p>f(1) = 1</p><p>f(2) = 2</p><p>因为用上面的公式不符合，哪有走0阶台阶的- -</p><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> fun(n - <span class="hljs-number">1</span>) + fun(n - <span class="hljs-number">2</span>);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, fun(n));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-逆序对"><strong>7.逆序对</strong></h2><p><code>逆序对</code></p><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。<br>如 <code>2 4 3 1 </code>中，<code> 2 1</code> ，<code>4 3</code> ，<code>4 1</code>，<code>3 1</code>是逆序，逆序数是 4 。给出一个整数序列，求该序列的逆序数。</p><p><strong>输入</strong></p><p>第 1 行： $N$ ， $N$为序列的长度（ $N≤10000$ ）<br>第 2∼N+1 行：序列中的元素（$ 1≤A[i]≤10000 $）</p><p><strong>输出</strong></p><p>输出逆序数</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>2<br>4<br>3<br>1<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>抓住最重要的，<strong>前面的数大于后面的数</strong>！</p><p>所以只要<strong>两个循环</strong>就可以解决了！</p><p><strong>外循环</strong>：固定当前等待比较的数</p><p><strong>内循环</strong>：去当前等待比较的数后面寻找有没有它还大的数</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <br>    <span class="hljs-comment">//创建数组存放这些数</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">100001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//读取这些数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">//用来计数</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//外循环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//内循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; Nl j++)<br>        &#123;<br>            <span class="hljs-comment">//开始判断,是否前面大于后面</span><br>            <span class="hljs-keyword">if</span>(arr[i] &gt; arr[j])<br>        count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-宫殿距离">9.宫殿距离</h2><p><code>搜索</code></p><p>nxn的格子宫殿，包含一个起始点<code>#</code>，一个终止点<code>$</code>，其它点为<code>.</code></p><p><strong>输入</strong></p><p>第 1 行，一个数n，中间用空格隔开。 ($2≤n≤1000$)</p><p>第 2~n+1行，每行n个字符。</p><p><strong>输出</strong></p><p>输出起点到终点的最短距离，距离只能从一个方格通过上下左右的方式走到与之相邻的方格，每个方格代表的距离为1。</p><p>距离不包含起始位置，包含终止位置。</p><p><strong>输入样例</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5<br><span class="hljs-code">.....</span><br><span class="hljs-code">.#...</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">....$</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>别看这题在后面，其实装的，吓人的</p><p><strong>不就是计算两点之间的距离嘛，只是不能斜着走</strong></p><p>只要在读入迷宫的时候，记下#、$的位置就行了</p><p>C语言的难度对于本体在于如何读取这个迷宫，需要注意缓存区中的换行符。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//存放迷宫</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br><span class="hljs-comment">//用来记录#的位置</span><br><span class="hljs-type">int</span> s_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> s_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//用来记录$的位置</span><br><span class="hljs-type">int</span> e_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> e_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//读入迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;arr[i][j]);<br><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>&#123;<br>s_i = i;<br>s_j = j;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;$&#x27;</span>)<br>&#123;<br>e_i = i;<br>e_j = j;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br>&#125;<br><br><span class="hljs-comment">//abs函数是用来取绝对值的</span><br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">abs</span>(s_i - e_i) + <span class="hljs-built_in">abs</span>(s_j - e_j);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-数列求值"><strong>4.数列求值</strong></h2><p>给定数列1,1,1,3,5,9,17,…，从第4项开始，每项都是前3项的和。求第20190324项的最后4位数字。</p><p><strong>思路：</strong></p><p>斐波那契数列的改版：因此依葫芦画瓢，使用递归来写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> Fib(n - <span class="hljs-number">1</span>) + Fib(n - <span class="hljs-number">2</span>) + Fib(n - <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是因为递归的太深，所以需要求解的时间很长，因此在比赛中肯定是不能过得，因此我们要考虑用空间换时间。</p><hr><p>利用一个数组存储前n项的和，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>arr[n] = arr[n - <span class="hljs-number">1</span>] + arr[n - <span class="hljs-number">2</span>] + arr[n - <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p><strong>但是</strong>！对于这道题依旧行不通，<u><strong>因为他要让你存储第20190324个数，需要巨大的空间</strong></u>，在main函数中创建这个数组，程序会崩溃。但你可以**<u>将这个数组写在main函数外，写成全局变量数组。</u>**</p><p>**但是！**就算你开辟了这个很大的数组，你依旧过不了这题，因为当你傻乎乎的求解时，<em><strong>斐波那契数列的增长很快</strong></em>，不一会就会超出整形的范围，就会得到意想不到的数。不过这题给你了提示，<strong>让你求最后4位数，所以你每次只要关注当前数的后4位</strong>。</p><p>**补充：**要得到一个数的后i位，就要对这个数取模% 10 ^ i</p><h3 id="最终代码如下：">最终代码如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h2 id="3-泡泡世界"><strong>3.泡泡世界</strong></h2><p>小鱼儿吐泡泡，嘟嘟嘟冒出来。小鱼儿会吐出两种泡泡：大泡泡&quot;O&quot;，小泡泡&quot;o&quot;。 两个相邻的小泡泡会融成一个大泡泡,两个相邻的大泡泡会爆掉。</p><p><strong>输入</strong></p><p>一行仅有’O’与’o’组成的字符串。</p><p>保证字符串的长度不超过100。</p><p><strong>输出</strong></p><p>输出一行字符串代表小鱼儿吐出的泡泡经过融合以后所剩余的泡泡。</p><p>合并顺序为自左向右合并。</p><p><strong>输入样例</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ooOOoooO</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">oO</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><blockquote><p>通过观察，我们可以发现，我们只需要关注当前泡泡的最右边的一个泡泡是什么，然后进行操作，符合栈的性质，因此可以用栈来做。</p><p>因为C语言没有自带栈，所以就使用C++来解决.</p></blockquote><p><strong>最终代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str;<br>cin &gt;&gt; str;<br><br>stack&lt;<span class="hljs-type">char</span>&gt; st;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-comment">//如果此时栈里没泡泡</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>())<br>st.<span class="hljs-built_in">push</span>(str[i]);<br><span class="hljs-comment">//有泡泡</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//如果与栈顶的泡泡相等</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">top</span>() == str[i])<br>&#123;<br><span class="hljs-comment">//如果栈顶是和当前都是&#x27;o&#x27;,则还需要判断栈顶下一个元素是否是&#x27;O&#x27;，</span><br><span class="hljs-comment">//如果是需要继续删除，如果不是直接插入</span><br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;o&#x27;</span>)<br>&#123;<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;O&#x27;</span>)<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;O&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-comment">//如果不相等</span><br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">push</span>(str[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//由于栈中的元素顺序与答案是反着的，需要逆置一遍</span><br><span class="hljs-comment">//栈没有迭代器，只能手动逆置</span><br>stack&lt;<span class="hljs-type">char</span>&gt; helpSt;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>helpSt.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-comment">//输出答案</span><br><span class="hljs-keyword">while</span> (!helpSt.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; helpSt.<span class="hljs-built_in">top</span>();<br>helpSt.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-机器人走方格">8.机器人走方格</h2><p><code>dp</code> <code>组合数</code> <code>递推</code></p><p>m×n 的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？</p><p>由于方法数量可能很大，只需要输出 $mod(10^9+7)$的结果。</p><p><strong>输入</strong></p><p>第 1 行，两个数m,n，中间用空格隔开。 ($2≤m,n≤10^6$)</p><p><strong>输出</strong></p><p>输出走法的数量$mod (10^9+7)$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><blockquote><p>非常简单一道动态规划。</p><p>动态规划三部曲：</p><p>1、确定dp数组以及下标的含义。</p><p>dp数组表示的是到第(i,j)位置有多少种走法。</p><p>2、确定递推公式</p><p>因为只能向右和向下走，所以只能从两个方向上走过来，相加即可.</p><p>dp[i][j] = dp[i - 1][j ] + dp[i][j - 1]</p><p>3、dp数组如何初始化</p><p>第一行只能从左走到右，所以只有1种走法</p><p>第一列只能从上走到下，所以只有1中走法</p></blockquote><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><br><span class="hljs-comment">//dp数组表示的是到第(i, j)位置有多少种走法。</span><br><span class="hljs-comment">//直接全部初始化1，反正后面的会被覆盖</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)<br><span class="hljs-comment">//确定递推公式</span><br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br><br>cout &lt;&lt; dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] % (<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写到这里，能拿大部分的分数，但是由于题目故意将数据放大了，这样还是会超时。</p><p>所以看看能不能优化。</p><p>通过观察发现，其实就是组合数。</p><p>从左上到右下，一共要走m - 1 + n - 1步，因为只能走两个方向，所以从m+n-2步中任选m-1步往下走。</p><p>即：</p></blockquote><p><strong>最终代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = n, y = <span class="hljs-number">1</span>; y &lt; m; ++x, ++y) <br>    &#123;<br>        ans = ans * x / y;<br>    &#125;<br>    cout &lt;&lt; ans % (<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯模拟题</title>
    <link href="/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/"/>
    <url>/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第一题</h1><p><strong>问题描述</strong><br>　　请找到一个大于 2022 的最小数，这个数转换成十六进制之后，所有的数位（不含前导 0）都为字母（A 到 F）。<br>　　请将这个数的十进制形式作为答案提交。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><hr><p><strong>方法一：</strong></p><blockquote><p>2022 转十六进制 7E6</p><p>这是一道填空题，最笨的方法，拿着计算器一个一个数出来，看哪一个数最先为AAA。</p></blockquote><p><strong>方法二：</strong></p><blockquote><p>通过编程来找。</p><p><strong>思路</strong>：循环2022以后的数，看哪一个最先 转为十六进制后就全为字母</p><p>如何一个十进制数转为十六进制呢？</p><p>使用短除法~</p><p>如：2022 % 16 = 6， 2022 / 16 =  126</p><p>​126 % 16 = E(14),  126 / 16 = 7</p><p>​7 % 16 = 7,  7 / 16 = 0</p><p>最后将取模的数从下当上写出来， 所以 2022转为十六进制就为7E6了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Full</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-comment">//如果满足每一位都是字母那就返回1，否则返回0</span><br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//检查每一位是否为字母，如果为数字直接结束</span><br><span class="hljs-type">int</span> tmp = n % <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; <span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>n /= <span class="hljs-number">16</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2023</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (is_Full(n))<br>&#123;<br><span class="hljs-comment">//一旦找到某一个满足全是字母的数，直接结束</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>n++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第二题</h1><p><strong>问题描述</strong><br>　　在 Excel 中，列的名称使用英文字母的组合。前 26 列用一个字母，依次为 A 到 Z，接下来 26*26 列使用两个字母的组合，依次为 AA 到 ZZ。<br>　　请问第 2022 列的名称是什么？<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个由大写字母组成的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。</p><blockquote><p>介不就一道二十六进制的题。</p><p>满Z就进位A。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2022</span>;<br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//%c打印字符，即后面可以跟一个数字，然后会输出相应ASCII值的字符</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, n % <span class="hljs-number">26</span> + (<span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">1</span>));<br>n /= <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为TYB，需要将结果反过来即BYT，因为每次都是先得到个位再十位…</p><h1>第三题</h1><p><strong>问题描述</strong><br>　　对于一个日期，我们可以计算出年份的各个数位上的数字之和，也可以分别计算月和日的各位数字之和。请问从 1900 年 1 月 1 日至 9999 年 12 月 31 日，总共有多少天，年份的数位数字之和等于月的数位数字之和加日的数位数字之和。<br>　　例如，2022年11月13日满足要求，因为 2+0+2+2=(1+1)+(1+3) 。<br>　　请提交满足条件的日期的总数量。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>这题就老老实实的编程算了~不然得数到结束</p><p>技巧：我们可以创建一个月份数组，存入每个对应的天数</p><p>思路：枚举每个日期，看是否满足咯，记得要判断是否为闰年</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_LeapYear</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//得到每位之和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (year)<br>&#123;<br>ans += year % <span class="hljs-number">10</span>;<br>year /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> month[<span class="hljs-number">13</span>] = &#123; <span class="hljs-number">0</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<br><span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br><span class="hljs-comment">//用来计数，得到结果</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1900</span>; i &lt;= <span class="hljs-number">9999</span>; i++)<br>&#123;<br><span class="hljs-comment">//先判断这年是不是闰年</span><br>month[<span class="hljs-number">2</span>] = is_LeapYear(i) ? <span class="hljs-number">29</span> : <span class="hljs-number">28</span>;<br><br><span class="hljs-comment">//得到这年上的数字之和</span><br><span class="hljs-type">int</span> year = getSum(i);<br><br><span class="hljs-comment">//得到月和日的数字之和</span><br><span class="hljs-type">int</span> Mon_Day = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">12</span>; j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= month[j]; k++)<br>&#123;<br><span class="hljs-comment">//计算月份和日每位数字之和~</span><br><span class="hljs-type">int</span> tmp = getSum(j) + getSum(k);<br><span class="hljs-keyword">if</span> (tmp == year)<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第四题</h1><p>问题描述<br>小蓝有 30 个数，分别为：99, 22, 51, 63, 72, 61, 20, 88, 40, 21, 63, 30, 11, 18, 99, 12, 93, 16, 7, 53, 64, 9, 28, 84, 34, 96, 52, 82, 51, 77 。<br>小蓝可以在这些数中取出两个序号不同的数，共有 30*29/2=435 种取法。<br>请问这 435 种取法中，有多少种取法取出的两个数的乘积大于等于 2022 。</p><p>答案提交<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>水题哦。直接上代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">99</span>, <span class="hljs-number">22</span>, <span class="hljs-number">51</span>, <span class="hljs-number">63</span>, <span class="hljs-number">72</span>, <span class="hljs-number">61</span>, <span class="hljs-number">20</span>,<br>     <span class="hljs-number">88</span>, <span class="hljs-number">40</span>, <span class="hljs-number">21</span>, <span class="hljs-number">63</span>, <span class="hljs-number">30</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">99</span>, <span class="hljs-number">12</span>,<br>      <span class="hljs-number">93</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">9</span>, <span class="hljs-number">28</span>, <span class="hljs-number">84</span>, <span class="hljs-number">34</span>, <br>      <span class="hljs-number">96</span>, <span class="hljs-number">52</span>, <span class="hljs-number">82</span>, <span class="hljs-number">51</span>, <span class="hljs-number">77</span>&#125;;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">30</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]*a[j]&gt;=<span class="hljs-number">2022</span>)<br>            &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><hr><h1>第六题</h1><p><strong>问题描述</strong><br>　　给定一天是一周中的哪天，请问 n 天后是一周中的哪天？<br><strong>输入格式</strong><br>　　输入第一行包含一个整数 w，表示给定的天是一周中的哪天，w 为 1 到 6 分别表示周一到周六，w 为 7 表示周日。<br>　　第二行包含一个整数 n。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示 n 天后是一周中的哪天，1 到 6 分别表示周一到周六，7 表示周日。<br><strong>样例输入</strong><br>6<br>10<br><strong>样例输出</strong><br>2<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000。</p><blockquote><p>思路：给定一个整数w表明是周几，那不就是第几天嘛。让你算n天之后，只需要(w + n) % 7</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;w, &amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (w + n) % <span class="hljs-number">7</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1>第七题</h1><p><strong>问题描述</strong><br>　　小蓝负责一块区域的信号塔安装，整块区域是一个长方形区域，建立坐标轴后，西南角坐标为 (0, 0)， 东南角坐标为 (W, 0)， 西北角坐标为 (0, H)， 东北角坐标为 (W, H)。其中 W, H 都是整数。<br>　　他在 n 个位置设置了信号塔，每个信号塔可以覆盖以自己为圆心，半径为 R 的圆形（包括边缘）。<br>　　为了对信号覆盖的情况进行检查，小蓝打算在区域内的所有横纵坐标为整数的点进行测试，检查信号状态。其中横坐标范围为 0 到 W，纵坐标范围为 0 到 H，总共测试 (W+1) * (H+1) 个点。<br>　　给定信号塔的位置，请问这 (W+1)*(H+1) 个点中有多少个点被信号覆盖。<br><strong>输入格式</strong><br>　　输入第一行包含四个整数 W, H, n, R，相邻整数之间使用一个空格分隔。<br>　　接下来 n 行，每行包含两个整数 x, y，表示一个信号塔的坐标。信号塔可能重合，表示两个信号发射器装在了同一个位置。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示答案。<br><strong>样例输入</strong><br>10 10 2 5<br>0 0<br>7 0<br><strong>样例输出</strong><br>57<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= W, H &lt;= 100，1 &lt;= n &lt;= 100, 1 &lt;= R &lt;= 100, 0 &lt;= x &lt;= W, 0 &lt;= y &lt;= H。</p><blockquote><p>题目挺长的，但是细读会发现也就那样。</p><p>思路：</p><p>创建一个二维数组全部初始化为0，然后对每一个信号塔进行预处理，将这个点到信号塔的距离算出来(x - a)^2 + (y - b)^2.如果在信号塔的范围内</p><p>就将其对应二维数组的值改为1。最后再统计1的个数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> W, H, n, R;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;W, &amp;H, &amp;n, &amp;R);<br><span class="hljs-comment">//创建一个二维数组</span><br><span class="hljs-comment">//因为不知道支不支持边长数组，就将数组开到最大</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//对于每个信号塔进行预处理</span><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br><br><span class="hljs-comment">//这里是&lt;=哦~</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= H; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= W; j++)<br>&#123;<br><span class="hljs-comment">//两点距离公式</span><br><span class="hljs-comment">//一个点的坐标:(j,i)</span><br><span class="hljs-comment">//信号塔坐标:  (y,x)</span><br><span class="hljs-keyword">if</span> ((x - i) * (x - i) + (y - j) * (y - j) &lt;= (R * R))<br>&#123;<br><span class="hljs-comment">//懒得再遍历一遍数组了，直接记录下有多少个1不就完事了~</span><br><span class="hljs-comment">//注意！如果被两个信号塔覆盖，应该只能算1次</span><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-number">0</span>)<br>count++;<br><br>arr[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1>第八题</h1><p><strong>问题描述</strong><br>　　小蓝有一个 n * m 大小的矩形水域，小蓝将这个水域划分为 n 行 m 列，行数从 1 到 n 标号，列数从 1 到 m 标号。每行和每列的宽度都是单位 1 。<br>　　现在，这个水域长满了水草，小蓝要清理水草。<br>　　每次，小蓝可以清理一块矩形的区域，从第 r1 行（含）到第 r2 行（含）的第 c1 列（含）到 c2 列（含）。<br>　　经过一段时间清理后，请问还有多少地方没有被清理过。<br><strong>输入格式</strong><br>　　输入第一行包含两个整数 n, m，用一个空格分隔。<br>　　第二行包含一个整数 t ，表示清理的次数。<br>　　接下来 t 行，每行四个整数 r1, c1, r2, c2，相邻整数之间用一个空格分隔，表示一次清理。请注意输入的顺序。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示没有被清理过的面积。<br><strong>样例输入</strong><br>2 3<br>2<br>1 1 1 3<br>1 2 2 2<br><strong>样例输出</strong><br>2<br><strong>样例输入</strong><br>30 20<br>2<br>5 5 10 15<br>6 7 15 9<br><strong>样例输出</strong><br>519<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= r1 &lt;= r2 &lt;= n &lt;= 100, 1 &lt;= c1 &lt;= c2 &lt;= m &lt;= 100, 0 &lt;= t &lt;= 100。</p><blockquote><p>感觉水题一样的，跟上题差不多思路，依旧是创建一个二维数组，去找里面有多少个0——代表没被清理过的地方。</p><p>搞懂上题这题打个哈哈就过~</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n, m, t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;t);<br>    <span class="hljs-type">int</span> r1, c1, r2, c2;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);<br>        <span class="hljs-keyword">for</span> (i = r1; i &lt;= r2; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (j = c1; j &lt;= c2; j++)<br>            &#123;<br>                a[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
