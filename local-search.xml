<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>自定义类型排序|深拷贝与浅拷贝</title>
    <link href="/2023/05/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2023/05/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、自定义类型排序"><a href="#一、自定义类型排序" class="headerlink" title="一、自定义类型排序"></a>一、自定义类型排序</h1><p>众所周知，java中的基本数据类型，可以使用Arrays的sort方法来排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Arrays;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">9</span>,<span class="hljs-number">8</span>,<span class="hljs-number">7</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;;<br>        Arrays.sort(arr);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e : arr)&#123;<br>            System.out.print(e + <span class="hljs-string">&quot; &quot;</span>);<br>            <span class="hljs-comment">//输出：1,2,3,4,5,6,7,8，9</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可是当我们定义了一个自定义类型，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时，编译器可不知道你要咋排序，是按学号排呢？还是按姓名来排呢？</p><p>假如我们都不管，一股脑就丢进sort中，出现如下异常：</p><p><img src="/2023/05/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/source_posts\自定义类型排序-深拷贝与浅拷贝\image-20230506182757635.png" alt="image-20230506182757635"></p><p>所以，要比较自定义类型数据，我们需要明确指定。</p><p>方式如下：让Student类实现Comparable接口，然后实现其中的compareTo方法。</p><p>假设我们现在是按id即学号排序：</p><p>我们在Student类中就得这样写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> id;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> id, String name)</span> &#123;<br>        <span class="hljs-built_in">this</span>.id = id;<br>        <span class="hljs-built_in">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br>        <span class="hljs-type">Student</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> (Student)o;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.id &gt; s.id)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span>.id &lt; s.id)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>于是，现在我们就能对student对象按学号进行排序辣~</p><p><img src="/2023/05/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/source_posts\自定义类型排序-深拷贝与浅拷贝\image-20230506184136642.png" alt="image-20230506184136642"></p><p><strong>结论：对于sort方法，传入的数组对象，都得具有compareTo方法，程序员可以通过重写compareTo方法，进行自己想要的排序。</strong></p><h1 id="二、自定义类型比较"><a href="#二、自定义类型比较" class="headerlink" title="二、自定义类型比较"></a>二、自定义类型比较</h1><p>我们都知道基本数据类型，直接比较大小就好了。那么如何比较自定义数据的大小呢？</p><p><strong>答案： 重写equals方法和compareTo方法。</strong></p><p><strong>例如，我们现在有一个Peson类，包含两个属：name、sex</strong></p><img src="/2023/05/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/image-20230508115551710.png" class title="image-20230508115551710"><p>如果我们这样去比较的话，那么会输出false。</p><p><strong>这是因为通过&#x3D;&#x3D;来比较两个引用，是比较引用所指向的对象是否为同一个来输出true或false。</strong></p><p>因此要想比较两个引用所指向对象的内容是否相同，那么得重写一个object类中的equals方法。(也可以自己随便写一个，不过不规范)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">if</span>(obj == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">this</span> == obj)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">//判断是否为Person类</span><br>    <span class="hljs-keyword">if</span>(!(obj <span class="hljs-keyword">instanceof</span> Person))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-type">Person</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> (Person)obj;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span>.name == tmp.name) &amp;&amp; (<span class="hljs-built_in">this</span>.sex == tmp.sex);<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/05/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%E6%8E%92%E5%BA%8F-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D/image-20230508120053306.png" class title="image-20230508120053306"><p>这样就能愉快的比较辣。</p><h1 id="三、深拷贝与浅拷贝"><a href="#三、深拷贝与浅拷贝" class="headerlink" title="三、深拷贝与浅拷贝"></a>三、深拷贝与浅拷贝</h1><p>在java中，内置了一个Clonable接口，用来拷贝一个对象。因此我们只要实现这个接口，然后重写clone方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面向对象——简单工厂模式</title>
    <link href="/2023/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2023/05/06/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="一、案例引入"><a href="#一、案例引入" class="headerlink" title="一、案例引入"></a>一、案例引入</h1><p><strong>需求</strong>：写一个计算器，实现加减乘除基本功能。</p><p><strong>如果使用面向过程的思想来写</strong>，即用计算机的方式去思考，就会写出如下代码：</p><h2 id="面向过程代码"><a href="#面向过程代码" class="headerlink" title="面向过程代码"></a>面向过程代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                result = numA + numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                result = numA - numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                result = numA * numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result = numA / numB;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;&quot;</span> + numA + symbol + numB + <span class="hljs-string">&quot;=&quot;</span> + result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>这样写，是可以满足需求，但是一旦需求发生改变，增加一个开根号功能，理论上你只需要在switch语句中增加一条，但是这样去写，会让加减乘除功能都来参与编译，万一你手贱，改动了别的功能呢？这就是面向过程所带来的一些弊端。</strong></p><p>举个例子：</p><blockquote><p>一个公司将所有员工的工资算法都放在了一起(就像上面计算器，将所有运算功能放在了一起)，哪天老板让你修改别人的工资，你一看自己工资比较低，还偷偷修改了自己工资的算法。</p><p>所以说这样的代码很危险，毕竟你无法保证每个人都不出错。</p></blockquote><p><strong>所以这时就要用到面向对象的编程思想了。</strong></p><h1 id="二、面向对象"><a href="#二、面向对象" class="headerlink" title="二、面向对象"></a>二、面向对象</h1><p>众所周知，面向对象有三大特性：封装，继承、多态。</p><p>我们可以先利用，<strong>封装。</strong></p><p><strong>先将整个程序分成两部分，一个是处理计算的，另一个是处理用户的输入。</strong></p><p>因此我们可以定义两个类，一个是用户类，即处理用户输入，另一个是计算类，用来计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> Calculate.GetResult(numA, symbol, numB);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">GetResult</span><span class="hljs-params">(<span class="hljs-type">int</span> numA, <span class="hljs-type">char</span> symbol, <span class="hljs-type">int</span> numB)</span>&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                result = numA + numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                result = numA - numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                result = numA * numB;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    result = numA / numB;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>此时还是解决不了会改动别的运算中的代码，因此我们还需要用到继承和多态</p><p><strong>我们将每个运算中相同的部分取出，即都需要两个操作数，和一个计算方法。而运算符号是特有的，我们稍后再处理</strong></p><p><strong>所以可以定一个一个父类，包含这些属性和行为。再运用重写，重写各自的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numA;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numB;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumA</span><span class="hljs-params">(<span class="hljs-type">int</span> numA)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numA = numA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumB</span><span class="hljs-params">(<span class="hljs-type">int</span> numB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numB = numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA + numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA - numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA * numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivOperation</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> numA / numB;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>这样来设计的话，当我要让你修改某一个功能的时候，我只需要把这个类给你，而不需要你再给你其他类，这样大大的降低了出错的可能性。</strong></p><p>代码写到这，还不能运行，因为还有符号部分没处理，不过我们可以通过去实例化对象，来处理运行相应的功能。即使用如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;+&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;*&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(symbol == <span class="hljs-string">&#x27;/&#x27;</span>)&#123;<br>            <span class="hljs-type">Operation</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>            o.setNumA(numA);<br>            o.setNumB(numB);<br>            ret = o.getResult();<br>        &#125;<br>        System.out.println(ret);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>此时代码看起来，<strong>有好多地方都是重复的，很臃肿</strong>，所以，此时我们可是使用<strong>”简单工厂模式</strong>“来帮我们解决。</p><h1 id="三、简单工厂模式"><a href="#三、简单工厂模式" class="headerlink" title="三、简单工厂模式"></a>三、简单工厂模式</h1><p><strong>简单工厂模式，就是通过创建一个类，来帮助你实例化对象，也就是你要实例化谁，直接通过这个“工厂”来创建。</strong></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(<span class="hljs-type">char</span> symbol)</span>&#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>现在我们要进行加法运算就可以这样写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> OperationFactory.createOperation(symbol);<br>        op.setNumA(numA);<br>        op.setNumB(numB);<br>        ret = op.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样修改以后，就非常简洁了，使用的时候，直接调函数就行了，<strong>而且未来扩展功能的时候，只需要添加一个类，再在工厂类里的switch添加一下就行了。</strong></p><p>这才是面向对象的代码嘛~</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operation</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numA;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> numB;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumA</span><span class="hljs-params">(<span class="hljs-type">int</span> numA)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numA = numA;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setNumB</span><span class="hljs-params">(<span class="hljs-type">int</span> numB)</span> &#123;<br>        <span class="hljs-built_in">this</span>.numB = numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA + numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA - numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulOperation</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> numA * numB;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DivOperation</span> <span class="hljs-keyword">extends</span>  <span class="hljs-title class_">Operation</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getResult</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span>(numB == <span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;除数为0&quot;</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> numA / numB;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">OperationFactory</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Operation <span class="hljs-title function_">createOperation</span><span class="hljs-params">(<span class="hljs-type">char</span> symbol)</span>&#123;<br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">switch</span>(symbol)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AddOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MinOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MulOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span> :<br>                ret = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DivOperation</span>();<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numA</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">char</span> <span class="hljs-variable">symbol</span> <span class="hljs-operator">=</span> sc.next().charAt(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">numB</span> <span class="hljs-operator">=</span> sc.nextInt();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ret</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">//        if(symbol == &#x27;+&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new AddOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125;else if(symbol == &#x27;-&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new MinOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125; else if(symbol == &#x27;*&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new MulOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125; else if(symbol == &#x27;/&#x27;)&#123;</span><br><span class="hljs-comment">//            Operation o = new DivOperation();</span><br><span class="hljs-comment">//            o.setNumA(numA);</span><br><span class="hljs-comment">//            o.setNumB(numB);</span><br><span class="hljs-comment">//            ret = o.getResult();</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(ret);</span><br><br>        <span class="hljs-type">Operation</span> <span class="hljs-variable">op</span> <span class="hljs-operator">=</span> OperationFactory.createOperation(symbol);<br>        op.setNumA(numA);<br>        op.setNumB(numB);<br>        ret = op.getResult();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java连接数据库</title>
    <link href="/2023/04/24/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2023/04/24/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h1><h1 id="一、连接数据库"><a href="#一、连接数据库" class="headerlink" title="一、连接数据库"></a>一、连接数据库</h1><p><strong>要想通过 JAVA 来操作数据库，分为下面4步：</strong></p><p>1、注册驱动  - 加载Driver类</p><p>2、获取连接 - 得到Connection</p><p>3、执行CRUD操作 - 发送SQL给mysql执行</p><p>4、释放资源 -关闭连接</p><h2 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>    <span class="hljs-comment">//1.注册驱动</span><br>    <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>();<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/04/24/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/image-20230424115710059.png" class title="image-20230424115710059"><p><strong>要根据你的数据库连接版本来确定选择哪一个，因为我的用的是mysql-connector-j-8.0.32.jar，因此我要连接com.mysql.cj.jdbc</strong></p><p><strong>说明：</strong></p><blockquote><p>com.mysql.jdbc.Driver 是 mysql-connector-java 5中的，<br>com.mysql.cj.jdbc.Driver 是 mysql-connector-java 6以及以上中的</p><p>否则Ideal会给你报警告，红红的很不好看~</p></blockquote><p><strong>接下来就是得到连接了：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>      <span class="hljs-comment">//1.注册驱动</span><br>      <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>(); <span class="hljs-comment">//</span><br><br>      <span class="hljs-comment">//2.得到连接</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;<br><span class="hljs-comment">//jdbc:mysql:// 规定好的协议, 通过jdbc的方式来连接mysql</span><br><span class="hljs-comment">// localhost 主机，也可以是ip地址</span><br><span class="hljs-comment">// 3306 表示mysql监听的端口</span><br><span class="hljs-comment">// db01 表示连接到db01数据库</span><br>      <br>     <span class="hljs-comment">//连接数据库的时候，我们还需要输入用户名和密码</span><br>      <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>      properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>);<br>      properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>      <br>      <span class="hljs-comment">//连接数据库！</span><br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, properties);<br>  &#125;<br></code></pre></td></tr></table></figure><p><strong>然后根据需求执行SQL语句以及关闭资源：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException &#123;<br>      <span class="hljs-comment">//1.注册驱动</span><br>      <span class="hljs-type">Driver</span> <span class="hljs-variable">driver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Driver</span>(); <span class="hljs-comment">//</span><br><br>      <span class="hljs-comment">//2.得到连接</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;<br><span class="hljs-comment">//jdbc:mysql:// 规定好的协议, 通过jdbc的方式来连接mysql</span><br><span class="hljs-comment">// localhost 主机，也可以是ip地址</span><br><span class="hljs-comment">// 3306 表示mysql监听的端口</span><br><span class="hljs-comment">// db01 表示连接到db01数据库</span><br>      <br>     <span class="hljs-comment">//我们还需要输入用户名和密码</span><br>      <span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>      properties.setProperty(<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>);<br>      properties.setProperty(<span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>);<br>      <br>      <span class="hljs-comment">//连接数据库！</span><br>      <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, properties);<br>      <br>      <span class="hljs-comment">//3.执行SQL语句</span><br>      <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-comment">//......</span><br>      <br>      <span class="hljs-comment">//4.关闭资源</span><br>      connection.close();<br>  &#125;<br></code></pre></td></tr></table></figure><h2 id="方式二：精简版"><a href="#方式二：精简版" class="headerlink" title="方式二：精简版"></a>方式二：精简版</h2><p>我们还以用过反射来加载Driver类，在加载Driver类的时候，就完成注册~</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ClassNotFoundException, SQLException &#123;<br>    <span class="hljs-comment">//1、注册驱动</span><br>    <span class="hljs-comment">//使用反射加载了Driver类</span><br>    Class.forName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>    <br>   <span class="hljs-comment">//2.得到连接</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://localhost:3306/db01&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;root&quot;</span>;<br>    <span class="hljs-comment">//根据url连接到数据库</span><br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> DriverManager.getConnection(url, user, password);<br>    <br>    <span class="hljs-comment">//3.执行SQL</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-comment">//.......</span><br><br>    <span class="hljs-comment">//4.关闭连接资源</span><br>    connection.close();<br>&#125;<br></code></pre></td></tr></table></figure><img src="/2023/04/24/Java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/image-20230424212641334.png" class title="image-20230424212641334">]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4_18深夜思考</title>
    <link href="/2023/04/19/4-18%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/"/>
    <url>/2023/04/19/4-18%E6%B7%B1%E5%A4%9C%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、为什么选择敲代码</h1><p>因为高考很糟糕，然后稀里糊涂的填了几个志愿，结果莫名其妙的来到了计科专业。不过，在我初中的时候，我也曾想过当一名程序员，可能那时候喜欢游戏吧~ 而到了高中呢，太过压抑，而且我对其他的专业也不懂，在学校只能看见老师，正巧我在b站上看到一个叫国家玮的老师，他讲课的风格颠覆了我对老师的印象，我想成为向他一样的老师，但是最终考的并不如意，或许冥冥之中自由安排…</p><h1>二、为什么选择java而不选择C++</h1><p>我现在(大二下)感觉这个问题其实很奇怪，我觉得大部分都被互联网搞的太焦虑了，大家都不看好java，觉得学java毕业就找不到工作了。我感觉，<strong>首先</strong>找工作不是一门简单的事情，哪有毕业就一定能找到的呢，而且大家都追求好公司，据说不是找不到，是找不到心仪的，有点高不成低不就的感觉；<strong>其次</strong>，难道学C++就一定能找到工作吗？一门语言而已，c++和java不都是擅长做后端开发吗？<strong>最后</strong>，在学c++的时候，我感受到的是语法的复杂，而学习java的时候，我感受到了面向对象的编程方式，还挺好玩，于是我选择了java。</p><p><strong>个人看法</strong>：其实选哪个都差不多，不过对于考研啥的，还是选C++好一点，毕竟考研书啥的资料大部分都是C++的。</p><h1>三、为什么骑行</h1><p>因为在b站上看到了一个博主，骑行了西藏，于是，我想我是否能试试骑行桂林呢？目前已经把桂林骑得差不多了，下个目标可能是柳州了？可能骑行会很累，但我不后悔，这是我自己选择的路~</p><h1>四、最后</h1><p>无论结果如何，我相信，人生没有那条路是白走的，可能会走错了路，但是你看到了别人看不到的风景，路上结识了一辈子的知己，收获了温暖的回忆和宝贵的经历。</p><p>也许，我现在所做的一切，看不到任何成果，但是水滴石穿，绳锯木断，不要迷茫，不要彷徨，我不是没有成长，而是在扎根，在打基础，所有的付出，都会有回报的。</p><p>也许，多年以后，当和家人、朋友坐在一起唠嗑时，打开自己尘封的记忆，那一幕幕，跳出来，依旧鲜活而富有生命力。这些美好的记忆不会随着年华的飘零而逝去，而是会被镌刻在岁月里，最美好的地方。</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人简介</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数据类型|运算符(与C对比)</title>
    <link href="/2023/04/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%8EC%E5%AF%B9%E6%AF%94/"/>
    <url>/2023/04/14/Java%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-%E8%BF%90%E7%AE%97%E7%AC%A6-%E4%B8%8EC%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、Java中的数据类型</h1><h2 id="0x01-基本数据类型">0x01 基本数据类型</h2><p>在 Java 中数据类型主要分为两类：<strong>基本数据类型</strong>和<strong>引用数据类型</strong>。</p><p>基本数据类型有4类：<strong>整形、浮点型、字符型、布尔型</strong>。细分为8种。如下：</p><table><thead><tr><th>数据类型</th><th>关键字</th><th>内存占用</th><th>范围</th></tr></thead><tbody><tr><td>字节型</td><td>byte</td><td>1 字节</td><td>-128 ~ 127</td></tr><tr><td>短整型</td><td>short</td><td>2 字节</td><td>-32768 ~ 32767</td></tr><tr><td>整型</td><td>int</td><td>4 字节</td><td>-2^31 ~ 2^31 - 1</td></tr><tr><td>长整型</td><td>long</td><td>8 字节</td><td>-2^63 ~ 2^63 - 1</td></tr><tr><td>单精度浮点数</td><td>float</td><td>4 字节</td><td>有范围，一般不关注</td></tr><tr><td>双精度浮点数</td><td>double</td><td>8 字节</td><td>有范围，一般不关注</td></tr><tr><td>字符型</td><td>char</td><td>2 字节</td><td>0 ~ 65535</td></tr><tr><td>布尔型</td><td>boolean</td><td>没有明确规定</td><td>true 和 false</td></tr></tbody></table><p><strong>值得注意的是</strong>：这里数据的类型大小和C语言不同的是，<strong>不论是在16位系统还是32位系统下</strong>，都是上述的大小。</p><p><strong>字符型</strong>在这里成了<strong>无符号的数</strong>了，<strong>还扩大成了2个字节</strong>。</p><p><strong>在C语言中，我们知道0表示假，非0表示真，然而在 Java中是使用boolean类型来表示真假，并且boolean类型不能与int类型转化</strong>，因此代码就不能写成这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(n--)&#123;<br><span class="hljs-comment">//本意是想循环10次，但java中的boolean不能与int转化。</span><br>&#125;<br><br><span class="hljs-comment">//只能这样写</span><br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>)&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>因此， Java 程序员不会遇到下述麻烦：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(x = <span class="hljs-number">0</span>) <span class="hljs-comment">//会报错</span><br></code></pre></td></tr></table></figure><h2 id="0x02-类型转换">0x02 类型转换</h2><p>Java 是一个强类型编程语言。<strong>当不同类型之间的变量相互赋值的时候</strong>, 会有教严格的校验</p><p>例如：<strong>当我们将一个高精度的数赋值给低精度的数，由于会发生截断，编译器认为不安全，会报错。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> <span class="hljs-number">10.0</span>;<br>a = d; <span class="hljs-comment">// 会报错</span><br></code></pre></td></tr></table></figure><p>如果是将一个低精度赋值给高精度的数，会进行类型转换。</p><p>类型转换又分为两种：<strong>自动(隐式)类型转换</strong>、<strong>强制(显示)类型转换</strong>。</p><hr><p><strong>自动类型转换</strong></p><p><strong>代码不需要经过任何处理，在代码编译时，编译器会自动进行处理</strong>。特点：<strong>数据范围小的转为数<br>据范围大的时会自动进行</strong>  。</p><p>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>l = n; <span class="hljs-comment">//发生自动类型转换</span><br></code></pre></td></tr></table></figure><p>自动类型转换路线：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>-&gt;<span class="hljs-type">short</span>-&gt;<span class="hljs-type">int</span>-&gt;<span class="hljs-type">long</span>-&gt;<span class="hljs-type">float</span>-&gt;<span class="hljs-type">double</span><br><span class="hljs-type">char</span>-&gt;<span class="hljs-type">int</span>-&gt;<span class="hljs-type">long</span>-&gt;<span class="hljs-type">float</span>-&gt;<span class="hljs-type">double</span><br></code></pre></td></tr></table></figure><p>可以将左边类型的变量赋值给右边类型的变量。</p><p><strong>强制类型转换：</strong></p><p>当进行操作时，代码需要经过一定的格式处理，不能自动完成。特点：数据范围大的到数据范围小的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>n = (<span class="hljs-type">int</span>)l; <span class="hljs-comment">//强制类型转换。告诉编译器我对此次类型转换负责！</span><br></code></pre></td></tr></table></figure><p>但是对于byte、short、char类型有些特别：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>理论上这些操作，编译器不能通过，但是有这样的一个规则：</p><p><strong>当把具体数赋值给byte、short、char时，会先判断该数是否在这个类型的范围内，如果在就可以.</strong></p><p>这里的<strong>具体数值指的是字面常量：不能是变量</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">//可以</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><span class="hljs-comment">//byte b2 = a //不可以</span><br><span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-comment">//short s1 = b1 + s; //不可以  </span><br></code></pre></td></tr></table></figure><h2 id="0x03-类型提升">0x03 类型提升</h2><p>不同类型的数据之间相互运算时，数据类型小的会被提升到数据类型大的。</p><ol><li><strong>int</strong>与<strong>long</strong>之间：<strong>int</strong>会被提升为<strong>long</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">long</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 编译出错: a + b==&gt;int + long--&gt; long + long 赋值给int时会丢失数据</span><br><span class="hljs-type">long</span> <span class="hljs-variable">d</span> <span class="hljs-operator">=</span> a + b; <span class="hljs-comment">// 编译成功：a + b==&gt;int + long---&gt;long + long 赋值给long</span><br></code></pre></td></tr></table></figure><ol start="2"><li><strong>byte</strong>与<strong>byte</strong>的运算</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">20</span>;<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br>System.out.println(c);<br><span class="hljs-comment">// 编译报错</span><br>Test.java:<span class="hljs-number">5</span>: 错误: 不兼容的类型: 从<span class="hljs-type">int</span>转换到<span class="hljs-type">byte</span>可能会有损失<br><span class="hljs-type">byte</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;<br></code></pre></td></tr></table></figure><p>原因：由于计算机的 CPU 通常是按照 4 个字节为单位从内存中读写数据. <strong>为了硬件上实现方便, 诸如 byte 和 short这种低于 4 个字节的类型, 会先提升成 int</strong>, 再参与计算</p><p>因此要想编译通过，需要进行强制类型转换。</p><h1>二、运算符</h1><p>Java中运算符可分为以下：算术运算符(+ - */)、关系运算符(&lt; &gt; ==)、逻辑运算符、位运算符、移位运算符以及条件运算符等 。</p><p><strong>C语言中只能对整数取模</strong>，<strong>但在 Java 中 % 不仅可以对整型取模，也可以对double类型取模</strong>，但是没有意义，一般都是对整型取模的 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">11.5</span> % <span class="hljs-number">2.0</span>);<br><span class="hljs-comment">// 运行结果</span><br><span class="hljs-number">1.5</span><br></code></pre></td></tr></table></figure><p><strong>对于++和–：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>b = b + <span class="hljs-number">1</span>; <span class="hljs-comment">//报错</span><br>b++; <span class="hljs-comment">//可以 会优化为 b = (byte)(b + 1)</span><br></code></pre></td></tr></table></figure><p><strong>对于 &amp;&amp;</strong> , 如果<strong>左侧表达式值为</strong> <strong>false,</strong> <strong>则表达式结果一定是</strong> <strong>false,</strong> <strong>无需计算右侧表达式</strong>.</p><p><strong>对于 ||</strong>, 如果<strong>左侧表达式值为</strong> <strong>true,</strong> <strong>则表达式结果一定是</strong> <strong>true,</strong> <strong>无需计算右侧表达式</strong>.</p><p><strong>&amp; 和 |</strong> ，如果表达式结果为 boolean 时, 也表示逻辑运算. 但与 &amp;&amp; || 相比, 它们不支持短路求值 ，因此他会对两边的表达式对进行判断。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">10</span> &gt; <span class="hljs-number">20</span> &amp; <span class="hljs-number">10</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// 程序抛出异常</span><br>System.out.println(<span class="hljs-number">10</span> &lt; <span class="hljs-number">20</span> | <span class="hljs-number">10</span> / <span class="hljs-number">0</span> == <span class="hljs-number">0</span>); <span class="hljs-comment">// 程序抛出异常</span><br></code></pre></td></tr></table></figure><p><strong>对于移位操作符，与C语言不同的是，还有无符号右移&gt;&gt;&gt;</strong></p><p>无符号右移 &gt;&gt;&gt;: <strong>最右侧位不要了, 最左侧补 0</strong></p><p>即不会关注一个数的二进制中的符号是啥，直接补0，所以一个负数将会变成很大的正数。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>认识java|Java的发展史|环境变量|JDK</title>
    <link href="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/"/>
    <url>/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><blockquote><p>本文将讲述什么是Java、Java的发展史、比较一下C&#x2F;C++和Java的区别、环境变量的作用以及JDK是什么。</p></blockquote><h1 id="一、认识Java"><a href="#一、认识Java" class="headerlink" title="一、认识Java"></a>一、认识Java</h1><h2 id="0x01-Java是什么"><a href="#0x01-Java是什么" class="headerlink" title="0x01 Java是什么"></a>0x01 Java是什么</h2><p>Java是一门优秀的<strong>程序设计语言</strong>，它具有令人赏心悦目的语法和易于理解的语义  。</p><p>Java凭借着<strong>友好的语法</strong>、<strong>面向对象</strong>、<strong>内存管理</strong>和<strong>最棒的跨平台可移植性</strong>来吸引程序员。</p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410201938465.png" class><p>（Java之父——詹姆斯·高斯林)</p><p>Java有这样一句口号：“Write once，run anywhere” 即 <strong>一次编译，到处运行</strong>。指的是你可以写一个Java程序，然后能够在你朋友所拥有的的任何设备上执行。</p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410202641113.png" class title="image-20230410202641113"><h2 id="0x02-Java发展史"><a href="#0x02-Java发展史" class="headerlink" title="0x02 Java发展史"></a>0x02 Java发展史</h2><blockquote><p>Java 语言源于 1991 年 4 月，Sun 公司 <strong>James Gosling</strong>博士 领导的绿色计划(Green Project) 开始启动，此计划最初的目标是开发一种能够在各种消费性电子产品(如机顶盒、冰箱、收音机等)上运行的程序架构。这个就是Java的前身： Oak (得名与Java创始人James Gosling办公室外的一棵橡树)，但由于这些智能化家电的市场需求没有预期的高，Sun公司放弃了该项计划。随着<strong>1995</strong>年代互联网的发展<strong>，Sun公司看见</strong>Oak<strong>在互联网上应用的前景，于是改造了</strong>Oak<strong>，于</strong>1995<strong>年</strong>5<strong>月以</strong>Java<strong>的名称正式发布，并提出</strong>“Write once, Run anywhere” <strong>的口号</strong>。  </p></blockquote><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410203130293.png" class title="image-20230410203130293"><h2 id="0x03-Java-VS-C"><a href="#0x03-Java-VS-C" class="headerlink" title="0x03 Java VS C++"></a>0x03 Java VS C++</h2><h3 id="1、简单性"><a href="#1、简单性" class="headerlink" title="1、简单性"></a>1、简单性</h3><p>在Java中剔除了C++中许多很少使用、难以理解、易混淆的特性。可以这样理解：Java语法是C++语法的一个”纯净”版本。<strong>例如：Java中没有头文件、指针语法、结构体、联合体、运算符重载。</strong></p><h3 id="2、健壮性"><a href="#2、健壮性" class="headerlink" title="2、健壮性"></a>2、健壮性</h3><p>Java投入了大量的精力进行早期的问题检测以及后期的动态检测。<strong>Java采用的指针模型(底层)可以消除重写内存和损坏数据的可能性。例如：C++的拷贝构造，当对象销毁自动调用析构函数，可能由于前面是写的浅拷贝，而导致同一块空间释放了两次。</strong></p><h3 id="3、可移植性"><a href="#3、可移植性" class="headerlink" title="3、可移植性"></a><strong>3、可移植性</strong></h3><p>与C和C++不同的，Java规范中没有“依赖具体实现”的地方。<strong>基本教据类型的大小以及有关运算都做了明确的说明</strong>  </p><p>例如：<strong>Java 中的 int 永远为 32 位的整数</strong>  ，<strong>而在 C&#x2F;C++ 中</strong>， <u>int 可能是 16 位整数、 32 位整数</u>， 也可能是编译器提供商指定的其他大小 。唯一的限制只是 int 类型的大小不能低于 short int, 并且不能高于 long int。  </p><p>在 Java 中， 数据类型具有固定的大小， 这消除了代码移植时令人头痛的主要问题。 二进制数据以固定的格式进行存储和传输， 消除了字节顺序的困扰  。<strong>例如：在C&#x2F;C++中还存在大小端字节序存储的问题。</strong></p><h2 id="4、动态性"><a href="#4、动态性" class="headerlink" title="4、动态性"></a>4、动态性</h2><p>Java 与 C 或 C++ 相比更加具有动态性。 它能够适应不断发展的环境库中可以自由地添加新方法和实例变量， 而对客户端却没有任何影响。  一个很好的例子是： 从 Internet 下载代码，然后在浏览器上运行。 如果使用 C 或 C++, 这确实难度很大，不过 Java 设计者很清楚动态语言可以很容易地实现运行程序的演进。  </p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><strong>语言没有优劣之分，这个世界不是非黑即白的，每个语言都可能在某些领域表现出比其他语言更出色</strong>。比如：Objective C 和后来的 Swift 在 iOS 设备上就有着无可取代的地位， 浏览器中的处理几乎完全由 JavaScript 掌控。 Windows 程序通常都用 C++ 或 C# 编写 。Java 在服务器端编程和跨平台客户端应用领域则很有优势 。</p><p><strong>Java 的成功源于其类库能够让人们轻松地完成原本有一定难度的事情</strong>。 例如：联网Web 应用和并发。Java 减少了指针错误， 这是一个额外的好处， 因此使用 Java 编程的效率更高。但这些并不是 Java 成功的全部原因。  </p><h1 id="二、环境变量"><a href="#二、环境变量" class="headerlink" title="二、环境变量"></a>二、环境变量</h1><p>有很多人在装Java时，上网查资料会发现，都装完JDK都会让你去配置一下环境变量。</p><p><strong>那这是为什么呢？</strong></p><p>举个例子：当我运行游戏的时候，如果不是用快捷打开方式，那我们就需要去游戏安装的目录下找到exe文件打开，但是如果我们配置了环境变量，那我们可以随便打开一个命令窗口，输入指令，即可打开游戏。</p><p><strong>类比到编程：</strong></p><p>相当于在函数A中，创建了一个局部变量，在函数B中无法使用这个变量，但当我们配置了环境变量后，这个局部变量升级成全局变量了，现在在函数B中可以使用这个变量。</p><h1 id="三、JDK"><a href="#三、JDK" class="headerlink" title="三、JDK"></a>三、JDK</h1><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230411215831748.png" class title="image-20230411215831748"><h2 id="0x01-JDK"><a href="#0x01-JDK" class="headerlink" title="0x01 JDK"></a>0x01 JDK</h2><p>JDK全称 Java Development Kit， 即Java开发工具包，包含了Javac编译工具，java，JRE等工具。</p><p>JDK &#x3D; JRE + 开发工具集(javac, javap, java…….)</p><h2 id="0x02-JRE"><a href="#0x02-JRE" class="headerlink" title="0x02 JRE"></a>0x02 JRE</h2><p>JRE全称 Java Runtime Environment, 即Java运行时环境，包含了 JVM，Java基础类库。</p><p>JRE &#x3D; JVM + JavaSE标准类库</p><h2 id="0x03-JVM"><a href="#0x03-JVM" class="headerlink" title="0x03 JVM"></a>0x03 JVM</h2><p>JVM全称 Java Virtual Machine，即Java虚拟机， 用来运行Java代码。</p><p><strong>JDK 、JRE 、JVM关系图：</strong></p><img src="/2023/04/10/Java%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-JDK/image-20230410212254607.png" class title="image-20230410212254607"><hr><blockquote><p>参考资料：</p><p>《Java核心技术卷》</p><p>《Head First Java》</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>JavaSE</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C语言文件操作</title>
    <link href="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、文件的分类</h1><h2 id="1-1程序文件">1.1程序文件</h2><blockquote><p>例如：源程序文件 即 .c文件</p><p>​可执行程序 即 .exe文件</p><p>​…</p></blockquote><h2 id="1-2数据文件">1.2数据文件</h2><blockquote><p>例如：PPT、word文档、Excel表格…</p></blockquote><h1>二、文件的打开与关闭</h1><p>对于不使用文件相关操作的时候，数据的输入输出都是以<strong>终端</strong>为对象，即从终端的键盘输入数据，将<strong>内存中的运行结果</strong>输出到<strong>终端</strong>上。如下：</p><img src="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20230403202819947.png" class><p><strong>注意：输入输出都是站在内存的角度来看待的！</strong></p><hr><p>但是如果是对文件操作，同理。</p><p>如下：</p><img src="/2023/04/03/C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/image-20230403203212563.png" class><h2 id="2-1文件指针">2.1文件指针</h2><p><strong>每个被使用的文件</strong>都在<strong>内存</strong>中开辟了一个相应的<strong>文件信息区</strong>，用来存放，文件的名字，文件当前的位置等信息。</p><p>这些信息是<strong>保存在一个结构体变量</strong>中，该结构体类型是由系统声明的，取名<strong>FILE</strong></p><p><strong>例如：在VS2013编译环境下，就有如下申明：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> &#123;</span><br>    <span class="hljs-type">char</span> *_ptr;<br>    <span class="hljs-type">int</span> _cnt;<br>    <span class="hljs-type">char</span> *_base;<br>    <span class="hljs-type">int</span> _flag;<br>    <span class="hljs-type">int</span> _file;<br>    <span class="hljs-type">int</span> _charbuf;<br>    <span class="hljs-type">int</span> _bufsiz;<br>    <span class="hljs-type">char</span> *_tmpfname;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> _<span class="hljs-title">iobuf</span> <span class="hljs-title">FILE</span>;</span><br></code></pre></td></tr></table></figure><p>因此我们可以通过<strong>创建一个文件指针</strong>来对文件完成相应的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">FILE* pf<span class="hljs-comment">//文件指针</span><br></code></pre></td></tr></table></figure><p><strong>ANSIC 规定使用fopen函数来打开文件，fclose来关闭文件</strong></p><p>举例：对一个文件进行写的操作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//打开文件，&quot;w&quot;表示是以写的方式打开文件。</span><br>FILE* pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br>    <br>    <span class="hljs-comment">//关闭文件</span><br>    fclose(pf);<br>    pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>打开文件方式有许多，如下：</strong></p><table><thead><tr><th>文件使用方式</th><th>含义</th><th>如果指定文件不存在</th></tr></thead><tbody><tr><td>“r”（只读）</td><td>为了输入数据，打开一个已经存在的文本文件</td><td>出错</td></tr><tr><td>“w”（只写）</td><td>为了输出数据，打开一个文本文件</td><td>建立一个新的文件</td></tr><tr><td>“a”（追加）</td><td>向文本文件尾添加数据</td><td>建立一个新的文件</td></tr><tr><td>“rb”（只读）</td><td>为了输入数据，打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb”（只写）</td><td>为了输出数据，打开一个二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab”（追加）</td><td>向一个二进制文件尾添加数据</td><td>出错</td></tr><tr><td>“r+”（读写）</td><td>为了读和写，打开一个文本文件</td><td>出错</td></tr><tr><td>“w+”（读写）</td><td>为了读和写，建议一个新的文件</td><td>建立一个新的文件</td></tr><tr><td>“a+”（读写）</td><td>打开一个文件，在文件尾进行读写</td><td>建立一个新的文件</td></tr><tr><td>“rb+”（读写）</td><td>为了读和写打开一个二进制文件</td><td>出错</td></tr><tr><td>“wb+”（读写）</td><td>为了读和写，新建一个新的二进制文件</td><td>建立一个新的文件</td></tr><tr><td>“ab+”（读写）</td><td>打开一个二进制文件，在文件尾进行读和写</td><td>建立一个新的文件</td></tr></tbody></table><p>因此，当我们要写一个文件，可以使用fopen函数，但打开也要关闭，可以使用fclose函数，最后再将指针置空</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//打开文件</span><br>FILE* pf = fopen(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>);<br><span class="hljs-comment">//确保打开成功</span><br><span class="hljs-keyword">if</span> (pf == <span class="hljs-literal">NULL</span>)<br>&#123;<br>perror(<span class="hljs-string">&quot;fopen&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//写文件</span><br><br><span class="hljs-comment">//关闭文件</span><br>fclose(pf);<br>pf = <span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>三、文件的读写</h1><p>文件的读写可以使用如下函数：</p><table><thead><tr><th>字符输入函数</th><th>fgetc</th><th>所有输入流</th></tr></thead><tbody><tr><td>字符输出函数</td><td>fputc</td><td>所有输出流</td></tr><tr><td>文本行输入函数</td><td>fgets</td><td>所有输入流</td></tr><tr><td>文本行输出函数</td><td>fputs</td><td>所有输出流</td></tr><tr><td>格式化输入函数</td><td>fscanf</td><td>所有输入流</td></tr><tr><td>格式化输出函数</td><td>fprintf</td><td>所有输出流</td></tr><tr><td>二进制输入</td><td>fread</td><td>文件</td></tr><tr><td>二进制输出</td><td>fwrite</td><td>文件</td></tr></tbody></table><p><strong>这里对所有输入输出流说明：</strong></p><p><strong>流是一种抽象出来的概念，程序员只需要关注将数据输出到流中或者从流中获取数据，而不用关注流怎么跟文件、屏幕、网络、外部设备怎么进行交互。</strong></p><p>我们一般使用的流：</p><table><thead><tr><th>读写文件</th><th>文件流</th></tr></thead><tbody><tr><td><strong>在终端屏幕上打印输出</strong></td><td><strong>标准输出流-stdout</strong></td></tr><tr><td><strong>键盘上输入数据</strong></td><td><strong>标准输入流-stdin</strong></td></tr></tbody></table><p>因此上面的函数，还可以将数据输入输出到屏幕上。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>fputc(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-built_in">stdout</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码也可以起到printf函数的作用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>筛质数</title>
    <link href="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/"/>
    <url>/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>质数的定义</h1><p>质数又称素数。质数是指在大于1的<a href="https://baike.baidu.com/item/%E8%87%AA%E7%84%B6%E6%95%B0/385394?fromModule=lemma_inlink">自然数</a>中，除了1和它本身以外不再有其他<a href="https://baike.baidu.com/item/%E5%9B%A0%E6%95%B0/9539111?fromModule=lemma_inlink">因数</a>的自然数。</p><h1>1-N的质数</h1><p><strong>题目描述：</strong></p><blockquote><p>寻找1-N之间的所有质数。</p><p>将其输出出来。</p></blockquote><h2 id="方法一：朴素法">方法一：朴素法</h2><p><strong>思路：</strong></p><blockquote><p>根据定义，只要循环2 - X-1 的数，看其是否是X的因数，如果都不是，那这个数就是素数。</p><p>可以优化，即找2 - 根号x的数。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPrime</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//循环2- sqrt(x)的数，看是否为其因数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= <span class="hljs-built_in">sqrt</span>(x); i++)<br>&#123;<br><span class="hljs-keyword">if</span> (x % i == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//输入</span><br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//由于素数是从2开始的</span><br>    <span class="hljs-comment">//循环2-N的数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果是素数，输出即可</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPrime</span>(i))<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>显然效率是不够的高的。每次都要找2-sqrt(x)的数来判断是否为因数。</p><p><strong>假设找1-10000内的数，则要循环117527次。</strong></p><h2 id="方法二：埃氏筛法">方法二：埃氏筛法</h2><p><strong>思路：</strong></p><blockquote><p>埃氏筛法是通过先找到素数，然后筛选不是这些素数倍数的数。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>2是素数，然后直接排除4、6、8、10…</p><p>3由于不是2的倍数，所以没有被筛选，此时小于3的所有数就都筛选过了，此时3就是素数了。然后通过3，直接排除6、9、12…</p><p>4由于被筛掉了，所以不用看了。</p><p>5不是2、3的倍数，此时小于5的所有数也都被筛选了，5也就是素数。然后再排除其倍数。</p></blockquote><img src="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/image-20230328215621016.png" class title="image-20230328215621016"><p><strong>不过这种做法也是有一点缺陷的，即6被筛选了两次.</strong></p><hr><p><strong>将原理运用：</strong></p><blockquote><p>首先创建一个大小为N+1的数组。里面存放能表示真或者假两种状态的标记。</p><p>初始化数组，假设全为真，表示所有数为素数。</p><p>要特判下标为0、1的，因为其不符合素数定义。</p><p>然后循环2-N的数，如果这个数为素数，则去找其倍数，修改为非素数。即1变0，真变假。</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//创建一个数组来表示0-N的数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">Prime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;<br>    <br>    <span class="hljs-comment">//不符合定义</span><br>Prime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>Prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">//循环2-N的数</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果是素数就筛选其倍速</span><br><span class="hljs-keyword">if</span> (Prime[i])<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * i; j &lt;= N; j += i)<br>&#123;<br>Prime[j] = <span class="hljs-literal">false</span>;<br>&#125;<br>cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>埃氏筛法可快多了，当要找1-10000内的数，只要31841次。</strong></p><h2 id="方法三：欧拉筛法">方法三：欧拉筛法</h2><p><strong>介绍：</strong></p><blockquote><p>欧拉筛法，也称线性筛，是在埃氏筛的基础上的优化，因为埃氏筛会某一个合数进行多少筛选。本质上是通过合数的最小的质因子筛掉数字。</p><p>大致流程：收集素数，然后遍历每一个数，让其乘上收集到的素数，然后筛选这个数。注意，因为是通过最小质因子筛选，如果当前数的因数有收集到的素数，需要终止。</p></blockquote><p><strong>例如：</strong></p><blockquote><p>2是素数，此时素数列表中只有2，让其 *2，筛选掉4</p><p>3没被筛选，此时将其加入素数列表，列表内容为2、3,让3 * 2, 3 * 3，筛选掉6、9</p><p>4被筛选掉了，不同于埃氏筛法，依旧要进行操作，让其成上2，筛选掉8，<strong>然后直接结束4的操作</strong>！<strong>因为欧拉筛的原理是通过最小质因子筛选。2是4的因子，不符合规则。所以不进行 4 * 3的操作。</strong></p><p>5没被筛选，加入素数列表，列表内容为2、3、5，然其乘上这些素数。</p><p>6被筛选掉了，让其乘上2, 2 * 6 = 12，然后直接结束6的操作！</p><p>…</p><p>这样就能保证对每个数只筛选一次了。</p></blockquote><img src="/2023/03/28/%E7%AD%9B%E8%B4%A8%E6%95%B0/image-20230328222516619.png" class title="image-20230328222516619"><p><strong>这种筛选法，对于一个数只会筛掉一次。</strong></p><p><strong>思路：</strong></p><blockquote><p>首先我们需要一个数组，标记这些数是否为质数。因为我们每个数都要乘以之前的所有素数，因此我们需要一个数组来记录素数。</p><p>如果是素数就加入数组。</p><p>对每个数进行乘上素数的操作，然后筛选数</p></blockquote><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>cin &gt;&gt; N;<br>    <br>    <span class="hljs-comment">//判定是否为素数</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">isPrime</span><span class="hljs-params">(N + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span></span>;<br>isPrime[<span class="hljs-number">0</span>] = <span class="hljs-literal">false</span>;<br>isPrime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">//储存素数的数组</span><br>vector&lt;<span class="hljs-type">int</span>&gt; Prime;<br>    <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= N; i++)<br>&#123;<br>        <span class="hljs-comment">//如果为素数就加入数组</span><br><span class="hljs-keyword">if</span> (isPrime[i])<br>Prime.<span class="hljs-built_in">push_back</span>(i);<br>        <span class="hljs-comment">//乘以素数进行筛选，需要注意是否会越界</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; Prime.<span class="hljs-built_in">size</span>() &amp;&amp; i * Prime[j] &lt;= N; j++)<br>&#123;<br>isPrime[i * Prime[j]] = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (i % Prime[j] == <span class="hljs-number">0</span>) <span class="hljs-comment">//最关键的一步！因为欧拉筛的本质是通过最小质因子来筛的</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : Prime)<br>cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>欧拉筛是一种非常高效的算法，如果是找10000内的质数，只需要循环8770次，比埃氏还要快的多。</strong></p><p><strong>对比：</strong></p><table><thead><tr><th>方法：</th><th>1-10000的数</th></tr></thead><tbody><tr><td><strong>朴素筛法</strong></td><td>117527</td></tr><tr><td><strong>埃氏筛</strong></td><td>31841</td></tr><tr><td><strong>欧拉筛(线性筛)</strong></td><td>8770</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二分查找</title>
    <link href="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <url>/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>案例引入：</h1><blockquote><p>有一个猜数字的游戏，即我讲选中1-100以内的某一个数，然后你来猜测，如果你猜的数比我选的数大，我会告诉你大了，反之亦然。</p></blockquote><p><strong>其实这个游戏就运用到了二分法/折半查找的思路。即每次筛选都排除掉一半的错误。</strong></p><p>二分查找是一个非常厉害的算法，它的<strong>时间复杂度在对数阶</strong>。</p><hr><h1>例题一：找个数</h1><h2 id="题目描述："><strong>题目描述：</strong></h2><blockquote><p>运用二分法的思想，寻找一个有序数组中的一个数的下标。这个数必定存在，数组中不存在重复元素项。</p></blockquote><h2 id="输入："><strong>输入</strong>：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[] = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span>&#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br></code></pre></td></tr></table></figure><h2 id="输出："><strong>输出：</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h2 id="思路："><strong>思路：</strong></h2><blockquote><p>定义一个左边界，定义一个右边界</p><p>然后每次比较区间中间的数和目标值</p><p>修改区间，就能删除一半的元素。</p></blockquote><h2 id="代码："><strong>代码：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> right = size - <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">//二分查找的细节</span><br><span class="hljs-keyword">while</span> (left &lt;= right) <span class="hljs-comment">//这里是小于等于呢？还是小于？ 这里先采用小于等于的写法，本质是取左闭右闭区间，[left, right]</span><br>&#123;<br>        <br><span class="hljs-comment">//计算中间的那个元素的下标</span><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//如果要找的数小于中间的那个数</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br><span class="hljs-comment">//怎么修改边界与上面的终止条件有关</span><br>right = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-comment">//如果找到了就直接返回这个元素的下标</span><br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> arr[] = &#123; <span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>,<span class="hljs-number">23</span>,<span class="hljs-number">48</span>,<span class="hljs-number">66</span>,<span class="hljs-number">88</span>,<span class="hljs-number">100</span> &#125;;<br><span class="hljs-type">int</span> target = <span class="hljs-number">48</span>;<br><br><span class="hljs-comment">//计算数组中元素个数</span><br><span class="hljs-type">int</span> size = <span class="hljs-keyword">sizeof</span>(arr) / <span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]);<br><br><span class="hljs-type">int</span> index = BinarySearch(arr, target, size);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;找到了，这个数在数组中的下标为：%d&quot;</span>, index);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="细节："><strong>细节：</strong></h2><blockquote><p>如果自己去写，很有可能写错，因为根据你<strong>所选取的区间不同</strong>，就会有<strong>其他几种写法</strong>。</p><p>例如 : 假设选取[left, right)区间，即左闭右开区间(上面选取了左闭右闭区间)</p></blockquote><h2 id="代码如下："><strong>代码如下：</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>* arr, <span class="hljs-type">int</span> target, <span class="hljs-type">int</span> size)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-type">int</span> right = size;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">while</span> (left &lt; right)<br>&#123;<br><br><span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br><br><span class="hljs-comment">//改动</span><br><span class="hljs-keyword">if</span> (target &lt; arr[mid])<br>right = mid;<br><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (target &gt; arr[mid])<br>left = mid + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> mid;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="注意："><strong>注意：</strong></h2><blockquote><p>我们要<strong>始终满足我们选取二分区间的定义</strong>，即左边界能不能取得到？右边界能不能取得到？</p><p>如果能取得到，那么修改的时候就要注意了。</p><p>很多人由于不注意细节，加上测试的数据不够多，很容易误以为自己写对了二分查找。</p></blockquote><h1>例题二：搜索插入位置</h1><h2 id="题目描述：-2"><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 O(log n) 的算法。</p><p>提示:</p><p>1 &lt;= nums.length &lt;= 104<br>-104 &lt;= nums[i] &lt;= 104<br>nums 为 <strong>无重复元素</strong> 的 升序 排列数组<br>-104 &lt;= target &lt;= 104</p></blockquote><h2 id="示例：">示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c">示例 <span class="hljs-number">1</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">5</span><br>输出: <span class="hljs-number">2</span><br>    <br>示例 <span class="hljs-number">2</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">2</span><br>输出: <span class="hljs-number">1</span><br>    <br>示例 <span class="hljs-number">3</span>:<br>输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], target = <span class="hljs-number">7</span><br>输出: <span class="hljs-number">4</span><br><br></code></pre></td></tr></table></figure><h2 id="思路：-2">思路：</h2><blockquote><p>读题，满足了二分法的条件，即数组有序。还告诉了请务必使用复杂度为O(log n) 的算法。</p><p>下面考虑两种情况：</p><p>1、如果数组中有这个元素，那么直接返回这个元素的下标即可。</p><p>2、如果数组中没有这个元素呢？我们通过一个叫做&quot;循环不变量的东西&quot;(下面会讲),可以得出最后所求的位置一定在left/right + 1上。</p></blockquote><h2 id="代码：-2">代码：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">searchInsert</span><span class="hljs-params">(<span class="hljs-type">int</span>* nums, <span class="hljs-type">int</span> numsSize, <span class="hljs-type">int</span> target)</span><br>&#123;<br><span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> right = target - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(left &lt;= right)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = left + (right -left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>            left = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(target &lt; nums[mid])<br>            right = mid - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> left; <span class="hljs-comment">//或者right + 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h1>二分查找中的循环不变量：</h1><p><strong>所谓的循环不变量，其实就是二分的过程中会发现，left左边的数全部小于目标值，而right的右边全部大于目标值。</strong></p><h2 id="举例：">举例：</h2><p><strong>假设现在要插入一个47，那么肯定得在下标为4的位置插入。</strong></p><table><thead><tr><th>left</th><th></th><th></th><th>mid</th><th></th><th></th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left</th><th>mid</th><th></th><th>right</th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th></th><th>left、right、mid</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><table><thead><tr><th></th><th></th><th></th><th>right</th><th>left</th><th></th><th></th><th></th></tr></thead><tbody><tr><td>5</td><td>8</td><td>10</td><td>23</td><td>48</td><td>66</td><td>88</td><td>100</td></tr><tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr></tbody></table><p><strong>所以返回left 或者 right+1</strong>。<strong>因为left左边都是小于目标值的，那么就应该插入在比目标值小的序列的后面。因为right右边都是大于目标值的，那么就应该插入在比目标值大的序列的前面。</strong>（以上都是对于没有重复项的序列）</p><hr><h1>例题三：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">在排序数组中查找元素的第一个和最后一个位置</a></h1><h2 id="题目描述：-3"><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）</a><br>来源：力扣</p><p>给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。</p><p>如果数组中不存在目标值 target，返回 [-1, -1]。</p><p>你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。</p><p>提示：</p><p>0 &lt;= nums.length &lt;= 105<br>-109 &lt;= nums[i] &lt;= 109<br>nums 是一个非递减数组<br>-109 &lt;= target &lt;= 109</p></blockquote><h2 id="示例：-2">示例：</h2><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs inform7">示例 1：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 8<br>输出：<span class="hljs-comment">[3,4]</span><br><br>示例 2：<br>输入：nums = <span class="hljs-comment">[5,7,7,8,8,10]</span>, target = 6<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br>示例 3：<br>输入：nums = <span class="hljs-comment">[]</span>, target = 0<br>输出：<span class="hljs-comment">[-1,-1]</span><br><br></code></pre></td></tr></table></figure><hr><h2 id="思路：-3">思路：</h2><blockquote><p>注意：</p><p>此题给的有序序列是<strong>有重复项</strong>的，因此当我们的中间值等于目标值了，我们<strong>先不急着返回</strong>，因此循环中只有两个选择了，等于的情况可以<strong>合并</strong>到别的情况中去。</p><p>现假设合并到中间值大于目标值。</p><p>由于循环不变量的原理，<strong>left左边的数一定是小于目标值，right右边的数一定是大于等于目标值，那么元素的第一个出现的位置一定是在left或者right + 1的位置。</strong></p><p><strong>那么元素最后一个出现的位置呢？只要我们查找比目标值大1的元素的位置然后减1就行了。</strong></p></blockquote><h2 id="特殊情况的考虑：">特殊情况的考虑：</h2><blockquote><p>如果没有出现过目标值呢？依旧会返回一个值，但是这个值是 目标值插入这个位置后依旧是有序的时候的位置。因此判断一下这个位置上的数是否为目标值，就可以知道有没有出现过了。</p><p>如果序列中所有值都小于目标值呢？二分会返回一个我们不可访问的地方。需要判断处理。</p></blockquote><hr><h2 id="代码：-3">代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//用来寻找第一次出现的边界</span><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">m_low_bound</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span></span>&#123;<br>        <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> right = nums.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(left &lt;= right)&#123;<br>            <span class="hljs-type">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[mid])<br>                left = mid + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">searchRange</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">2</span>,<span class="hljs-number">0</span>)</span></span>;<br>        ans[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>        ans[<span class="hljs-number">1</span>] = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> start = <span class="hljs-built_in">m_low_bound</span>(nums, target);<br>       <span class="hljs-comment">//需要注意的地方！</span><br>        <span class="hljs-keyword">if</span>(start &gt;= nums.<span class="hljs-built_in">size</span>() || target != nums[start])<br>            <span class="hljs-keyword">return</span> ans;<br>        <span class="hljs-comment">//记得减1</span><br>        <span class="hljs-type">int</span> end = <span class="hljs-built_in">m_low_bound</span>(nums, target + <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>;<br>        ans[<span class="hljs-number">0</span>] = start;<br>        ans[<span class="hljs-number">1</span>] = end;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h1>拓展：lower_bound</h1><img src="/2023/03/27/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/image-20230328211735342.png" class title="image-20230328211627216"><p>C++的库函数中有一个叫lower_bound()的函数。</p><p><strong>函数的功能：</strong></p><blockquote><p>1、如果数组中存在目标值，则返回第一个是目标值的下标。</p><p>2、如果数组中不存在，则返回这个数应该出现的位置。</p></blockquote><p><strong>使用如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>vector&lt;<span class="hljs-type">int</span>&gt; arr;<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>arr.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">2</span>);<br><br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos1 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">1</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos2 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">2</span>);<br>vector&lt;<span class="hljs-type">int</span>&gt;::iterator pos3 = <span class="hljs-built_in">lower_bound</span>(arr.<span class="hljs-built_in">begin</span>(), arr.<span class="hljs-built_in">end</span>(), <span class="hljs-number">3</span>);<br><br>cout &lt;&lt; <span class="hljs-string">&quot;1 出现的位置：&quot;</span> &lt;&lt; pos1 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出1</span><br>cout &lt;&lt; <span class="hljs-string">&quot;2 出现的位置：&quot;</span> &lt;&lt; pos2 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出3</span><br>cout &lt;&lt; <span class="hljs-string">&quot;3 出现的位置：&quot;</span> &lt;&lt; pos3 - arr.<span class="hljs-built_in">begin</span>() &lt;&lt; endl; <span class="hljs-comment">//输出4</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>基础算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷宫</title>
    <link href="/2023/03/27/%E8%BF%B7%E5%AE%AB/"/>
    <url>/2023/03/27/%E8%BF%B7%E5%AE%AB/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>一、迷宫问题</h1><h2 id="题目描述："><strong>题目描述：</strong></h2><blockquote><p>链接：<a href="https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc">https://www.nowcoder.com/questionTerminal/cf24906056f4488c9ddb132f317e03bc</a><br>来源：牛客网</p><p>定义一个二维数组 N*M ，如 5 × 5 数组下所示：</p><p>int maze[5][5]= {<br>0, 1, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 0, 0,<br>0, 1, 1, 1, 0,<br>0, 0, 0, 1, 0,<br>};</p><p>它表示一个迷宫，其中的1表示墙壁，0表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。入口点为[0,0],既第一格是可以走的路。</p><p>数据范围： 2 &lt;= n,m &lt;= 10,  输入的内容只包含 0 &lt;= val &lt;= 1</p></blockquote><h2 id="输入描述："><strong>输入描述：</strong></h2><blockquote><p>输入两个整数，分别表示二维数组的行数，列数。再输入相应的数组，其中的1表示墙壁，0表示可以走的路。数据保证有唯一解,不考虑有多解的情况，即迷宫只有一条通道。</p></blockquote><h2 id="输出描述"><strong>输出描述:</strong></h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">左上角到右下角的最短路径，格式如样例所示。<br></code></pre></td></tr></table></figure><p><strong>示例1</strong></p><h2 id="输入">输入</h2><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="输出">输出</h2><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs clojure">(<span class="hljs-number">0</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">1</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">0</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">1</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">2</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">3</span>)<br>(<span class="hljs-number">2</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">3</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br>(<span class="hljs-number">4</span><span class="hljs-punctuation">,</span><span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure><h2 id="求解：">求解：</h2><p><strong>第一步：</strong></p><blockquote><p>首先我们先把简单的输入做好，然后再专心写怎么去找。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第二步：</strong></p><blockquote><p>因为深度优先搜索(DFS)非常适用于找是否有解的题，正巧题目说了有且仅有一条通路，所以非常契合。</p><p>那DFS怎么实现呢？用栈这种数据结构呢？还是用递归——函数调用创建栈帧？ 为了精简就用递归吧。</p><p><strong>递归三要素：</strong></p><p>1、确定递归函数的参数和返回值</p><p>2、确定终止条件</p><p>3、确定单层递归逻辑</p></blockquote><p><strong>1、确定递归函数的参数和返回值</strong></p><p>首先我们肯定要<strong>传入这个二维矩阵</strong>，其次我们还要<strong>传入迷宫起点坐标</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">DFS</span>(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y);<br></code></pre></td></tr></table></figure><blockquote><p>那要不要传迷宫的长宽呢？因为我们用了vector容器，可以通过调用接口函数，直接得出，因此不用</p></blockquote><p>最后我们确定返回值，因为我们<strong>只要求是否有解</strong>，<strong>如果有的话直接返回true, 没有的话返回false不就行啦，所以返回值定位bool</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>2、确定终止条件</strong></p><p>显然<strong>走到出口就停止</strong>呗。即坐标(N - 1, M - 1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">if</span>(x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><p><strong>3、确定单层递归逻辑</strong></p><p>首先我们在迷宫中不知道哪里能走，因此只能“摸黑走”，随便走，但<strong>总要规定一个顺序</strong>，我们这里<strong>假设就用上下左右</strong>的顺序去“走迷宫”。</p><p>但是，我们总不能是墙也走吧，或者走出迷宫边界，因此我们还要<strong>判定是否能向那一个方向走。</strong></p><p>写一个函数用来判断能不能走isPass</p><p><strong>首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳了。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//首先不能走到迷宫外面，其次迷宫的墙也不能走，即1的地方，还有走过的地方也不用走了，不然就成反复横跳。</span><br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>    <br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>至此，我们整个递归的逻辑已经写完了。但是这道题需要让你输出从起点到终点的路径坐标。</p><p>如果我们走到一个死胡同，此时我们记录了这个死胡同的所有坐标，这不是我们想要的，因此我们要删除这些坐标。仔细思考，会发现，我们<strong>所需要删除的是所有后面来的坐标</strong>，这不就是<strong>后进先出</strong>嘛，所以我们就想到了用栈来记录。</p><p>因为<strong>坐标是两个整形的组合</strong>，类似一个结构体，我们可以<strong>用pair来记录坐标</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br></code></pre></td></tr></table></figure><p>至此，我们能记录出所有坐标辣，但是<strong>坐标顺序是反的</strong>。<strong>因此还要借助一个栈来辅助逆置</strong>。最后输出这个辅助栈就ok了</p><h2 id="最终代码：">最终代码：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; st;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">isPass</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; maze.<span class="hljs-built_in">size</span>()<br>&amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()<br>&amp;&amp; maze[x][y] == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">DFS</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; maze, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//走到这个点，记录这个点已经走过了，不要再走了</span><br>maze[x][y] = <span class="hljs-number">2</span>;<br>st.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">pair</span>&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;(x, y));<br><br><span class="hljs-comment">//终止条件</span><br><span class="hljs-keyword">if</span> (x == maze.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> &amp;&amp; y == maze[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br><span class="hljs-comment">//向上走</span><br><span class="hljs-comment">//判断上面能不能走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x - <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-comment">//如果能走的话，就先走到上面，然后将起点看做是上面的那个点，即开始往下递</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x - <span class="hljs-number">1</span>, y))<br><span class="hljs-comment">//如果发现向上走能找到通路，直接返回就行了</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向下走</span><br><span class="hljs-comment">//与向上走同理</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x + <span class="hljs-number">1</span>, y))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x + <span class="hljs-number">1</span>, y))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向左走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y - <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y - <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">//向右走</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">isPass</span>(maze, x, y + <span class="hljs-number">1</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">DFS</span>(maze, x, y + <span class="hljs-number">1</span>))<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br><br>&#125;<br><br><span class="hljs-comment">//归的过程</span><br><span class="hljs-comment">//因为走不通，返回false，并且要输出错误路的坐标</span><br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> N, M;<br>cin &gt;&gt; N &gt;&gt; M;<br><span class="hljs-comment">//用来存放迷宫</span><br><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">maze</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M, <span class="hljs-number">0</span>));<br><br><span class="hljs-comment">//接收迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; n : maze)<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; m : n)<br>cin &gt;&gt; m;<br><br><span class="hljs-comment">//对迷宫进行DFS</span><br><span class="hljs-built_in">DFS</span>(maze, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><br>stack&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; help_st;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>help_st.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">while</span> (!help_st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().first &lt;&lt; <span class="hljs-string">&quot;,&quot;</span> &lt;&lt; help_st.<span class="hljs-built_in">top</span>().second &lt;&lt; <span class="hljs-string">&quot;)&quot;</span> &lt;&lt; endl;<br>help_st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Study</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二届程序设计大赛</title>
    <link href="/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/"/>
    <url>/2023/03/27/%E7%AC%AC%E4%BA%8C%E5%B1%8A%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%A4%A7%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="1-闰年"><strong>1.闰年</strong></h2><p>问题描述</p><p>给定一个年份，判断这一年是不是闰年。当以下情况之一满足时，这一年是闰年：</p><ol><li>年份是4的倍数而不是100的倍数；</li><li>年份是400的倍数。<br>其他的年份都不是闰年。</li></ol><p><strong>输入格式</strong><br>输入包含一个整数y，表示当前的年份。</p><p><strong>输出格式</strong><br>输出一行，如果给定的年份是闰年，则输出yes，否则输出no。</p><p>说明：当试题指定你输出一个字符串作为结果（比如本题的yes或者no，你需要严格按照试题中给定的大小写，写错大小写将不得分。</p><p><strong>思路：</strong></p><p>按照题目描述输出即可。<strong><u>四年一润且百年不润 或 四百年一润</u></strong></p><p>因此可以得出这样的表达式：</p><p><strong>(year % 4 == 0 &amp;&amp; year % 100 != 0) || (year % 400 == 0)</strong></p><p>之后结合if语句判断即可~</p><p><strong>代码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> year = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;year);<br>    <br>    <span class="hljs-comment">//如果表达式为真，则执行输出yes</span><br>    <span class="hljs-keyword">if</span>((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-找素数"><strong>2.找素数</strong></h2><p>输入一个正整数n，计算输出小于n的最大素数</p><p><strong>思路：</strong></p><p>抓住核心：<strong>小于n，最大，素数</strong></p><p><u><strong>1.分析素数：大于1，只能被1和自身整除</strong></u></p><p><u><strong>2.循环找出大于1，小于n的数</strong></u></p><p><u><strong>3.检查循环所枚举出来的数是否为素数</strong></u></p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">//检查它是不是素数,如果是则返回1，不是返回0</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Prime</span><span class="hljs-params">(<span class="hljs-type">int</span> num)</span><br>&#123;<br><span class="hljs-comment">//循环2 - num-1 之间的数，看是否能被num整除，能整除则说明不是</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span>; j &lt;= num - <span class="hljs-number">1</span>; j++)<br>&#123;<br><span class="hljs-keyword">if</span> (num % j == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><br><span class="hljs-comment">//先得到小于n的数</span><br><br><span class="hljs-comment">//因为要最大，所以从后往前找</span><br><span class="hljs-comment">//但是因为要得到素数，而最小的素数是2，所以循环到2就行</span><br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">2</span>; i--)<br>&#123;<br><span class="hljs-comment">//判断是否为素数</span><br><span class="hljs-keyword">if</span> (is_Prime(i) == <span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-comment">//如果当前数为素数，则一定是小于n的最大素数了</span><br>            <span class="hljs-comment">//中止循环即可~</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, i);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-爬楼梯"><strong>6.爬楼梯</strong></h2><p>假设你正在爬楼梯。需要 <code>n</code> 阶你才能到达楼顶。每次你可以爬 <code>1</code> 或 <code>2</code> 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p><p><strong>思路：</strong></p><p>由于<strong>每次只能爬一个台阶或者两个台阶</strong>，因此<strong>第n阶台阶只能由第n-1阶台阶和n-2阶台阶到达</strong>。</p><p>所以我们<strong>只要知道</strong>了爬到n-1阶台阶有多少中走法和n-2阶台阶有多少种走法，<strong>就能得到</strong>爬到n阶台阶有多少种走法。</p><p>现用函数的形式表示n阶台阶的不同方法数：</p><p>f(n) = f(n - 1) + f(n - 2)。</p><p>f(n - 1) = f(n - 1 - 1) +f(n - 1 - 2)</p><p>f(n - 2) = f(n - 2 - 1) + f(n - 2 - 2)</p><p>…</p><p>我们会发现，每次操作都差不多，因此我们可以用<strong>递归解决问题</strong>(循环当然也可以)。</p><p>但有<strong>两个特例</strong>：</p><p>f(1) = 1</p><p>f(2) = 2</p><p>因为用上面的公式不符合，哪有走0阶台阶的- -</p><p><strong>代码：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">fun</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(n &gt; <span class="hljs-number">2</span>)<br>        <span class="hljs-keyword">return</span> fun(n - <span class="hljs-number">1</span>) + fun(n - <span class="hljs-number">2</span>);<br>&#125;<br><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, fun(n));<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="7-逆序对"><strong>7.逆序对</strong></h2><p><code>逆序对</code></p><p>在一个排列中，如果一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序。一个排列中逆序的总数就称为这个排列的逆序数。<br>如 <code>2 4 3 1 </code>中，<code> 2 1</code> ，<code>4 3</code> ，<code>4 1</code>，<code>3 1</code>是逆序，逆序数是 4 。给出一个整数序列，求该序列的逆序数。</p><p><strong>输入</strong></p><p>第 1 行： $N$ ， $N$为序列的长度（ $N≤10000$ ）<br>第 2∼N+1 行：序列中的元素（$ 1≤A[i]≤10000 $）</p><p><strong>输出</strong></p><p>输出逆序数</p><p><strong>输入样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">4<br>2<br>4<br>3<br>1<br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>抓住最重要的，<strong>前面的数大于后面的数</strong>！</p><p>所以只要<strong>两个循环</strong>就可以解决了！</p><p><strong>外循环</strong>：固定当前等待比较的数</p><p><strong>内循环</strong>：去当前等待比较的数后面寻找有没有它还大的数</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> N = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <br>    <span class="hljs-comment">//创建数组存放这些数</span><br>    <span class="hljs-type">int</span> arr[<span class="hljs-number">100001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>    <span class="hljs-comment">//读取这些数</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;arr[i]);<br>    &#125;<br>    <br>    <span class="hljs-comment">//用来计数</span><br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">//外循环</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; N - <span class="hljs-number">1</span>; i++)<br>    &#123;<br>        <span class="hljs-comment">//内循环</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; Nl j++)<br>        &#123;<br>            <span class="hljs-comment">//开始判断,是否前面大于后面</span><br>            <span class="hljs-keyword">if</span>(arr[i] &gt; arr[j])<br>        count++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-宫殿距离">9.宫殿距离</h2><p><code>搜索</code></p><p>nxn的格子宫殿，包含一个起始点<code>#</code>，一个终止点<code>$</code>，其它点为<code>.</code></p><p><strong>输入</strong></p><p>第 1 行，一个数n，中间用空格隔开。 ($2≤n≤1000$)</p><p>第 2~n+1行，每行n个字符。</p><p><strong>输出</strong></p><p>输出起点到终点的最短距离，距离只能从一个方格通过上下左右的方式走到与之相邻的方格，每个方格代表的距离为1。</p><p>距离不包含起始位置，包含终止位置。</p><p><strong>输入样例</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5<br><span class="hljs-code">.....</span><br><span class="hljs-code">.#...</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">.....</span><br><span class="hljs-code">....$</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><p>别看这题在后面，其实装的，吓人的</p><p><strong>不就是计算两点之间的距离嘛，只是不能斜着走</strong></p><p>只要在读入迷宫的时候，记下#、$的位置就行了</p><p>C语言的难度对于本体在于如何读取这个迷宫，需要注意缓存区中的换行符。</p><p><strong>代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-comment">//存放迷宫</span><br><span class="hljs-type">char</span> arr[<span class="hljs-number">1001</span>][<span class="hljs-number">1001</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br><span class="hljs-comment">//用来记录#的位置</span><br><span class="hljs-type">int</span> s_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> s_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//用来记录$的位置</span><br><span class="hljs-type">int</span> e_i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> e_j = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//读入迷宫</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)<br>&#123;<br><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;arr[i][j]);<br><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;#&#x27;</span>)<br>&#123;<br>s_i = i;<br>s_j = j;<br>&#125;<br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-string">&#x27;$&#x27;</span>)<br>&#123;<br>e_i = i;<br>e_j = j;<br>&#125;<br>&#125;<br><span class="hljs-comment">//清空缓存区中\n</span><br>getchar();<br>&#125;<br><br><span class="hljs-comment">//abs函数是用来取绝对值的</span><br><span class="hljs-type">int</span> ans = <span class="hljs-built_in">abs</span>(s_i - e_i) + <span class="hljs-built_in">abs</span>(s_j - e_j);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, ans);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-数列求值"><strong>4.数列求值</strong></h2><p>给定数列1,1,1,3,5,9,17,…，从第4项开始，每项都是前3项的和。求第20190324项的最后4位数字。</p><p><strong>思路：</strong></p><p>斐波那契数列的改版：因此依葫芦画瓢，使用递归来写。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">Fib</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n == <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> Fib(n - <span class="hljs-number">1</span>) + Fib(n - <span class="hljs-number">2</span>) + Fib(n - <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>但是因为递归的太深，所以需要求解的时间很长，因此在比赛中肯定是不能过得，因此我们要考虑用空间换时间。</p><hr><p>利用一个数组存储前n项的和，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> arr[<span class="hljs-number">100</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br>arr[n] = arr[n - <span class="hljs-number">1</span>] + arr[n - <span class="hljs-number">2</span>] + arr[n - <span class="hljs-number">3</span>];<br></code></pre></td></tr></table></figure><p><strong>但是</strong>！对于这道题依旧行不通，<u><strong>因为他要让你存储第20190324个数，需要巨大的空间</strong></u>，在main函数中创建这个数组，程序会崩溃。但你可以**<u>将这个数组写在main函数外，写成全局变量数组。</u>**</p><p>**但是！**就算你开辟了这个很大的数组，你依旧过不了这题，因为当你傻乎乎的求解时，<em><strong>斐波那契数列的增长很快</strong></em>，不一会就会超出整形的范围，就会得到意想不到的数。不过这题给你了提示，<strong>让你求最后4位数，所以你每次只要关注当前数的后4位</strong>。</p><p>**补充：**要得到一个数的后i位，就要对这个数取模% 10 ^ i</p><h3 id="最终代码如下：">最终代码如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><br></code></pre></td></tr></table></figure><h2 id="3-泡泡世界"><strong>3.泡泡世界</strong></h2><p>小鱼儿吐泡泡，嘟嘟嘟冒出来。小鱼儿会吐出两种泡泡：大泡泡&quot;O&quot;，小泡泡&quot;o&quot;。 两个相邻的小泡泡会融成一个大泡泡,两个相邻的大泡泡会爆掉。</p><p><strong>输入</strong></p><p>一行仅有’O’与’o’组成的字符串。</p><p>保证字符串的长度不超过100。</p><p><strong>输出</strong></p><p>输出一行字符串代表小鱼儿吐出的泡泡经过融合以后所剩余的泡泡。</p><p>合并顺序为自左向右合并。</p><p><strong>输入样例</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">ooOOoooO</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">oO</span><br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><blockquote><p>通过观察，我们可以发现，我们只需要关注当前泡泡的最右边的一个泡泡是什么，然后进行操作，符合栈的性质，因此可以用栈来做。</p><p>因为C语言没有自带栈，所以就使用C++来解决.</p></blockquote><p><strong>最终代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>string str;<br>cin &gt;&gt; str;<br><br>stack&lt;<span class="hljs-type">char</span>&gt; st;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; str.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-comment">//如果此时栈里没泡泡</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">empty</span>())<br>st.<span class="hljs-built_in">push</span>(str[i]);<br><span class="hljs-comment">//有泡泡</span><br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">//如果与栈顶的泡泡相等</span><br><span class="hljs-keyword">if</span> (st.<span class="hljs-built_in">top</span>() == str[i])<br>&#123;<br><span class="hljs-comment">//如果栈顶是和当前都是&#x27;o&#x27;,则还需要判断栈顶下一个元素是否是&#x27;O&#x27;，</span><br><span class="hljs-comment">//如果是需要继续删除，如果不是直接插入</span><br><span class="hljs-keyword">if</span> (str[i] == <span class="hljs-string">&#x27;o&#x27;</span>)<br>&#123;<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">if</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; st.<span class="hljs-built_in">top</span>() == <span class="hljs-string">&#x27;O&#x27;</span>)<br>st.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">push</span>(<span class="hljs-string">&#x27;O&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-comment">//如果不相等</span><br><span class="hljs-keyword">else</span><br>st.<span class="hljs-built_in">push</span>(str[i]);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//由于栈中的元素顺序与答案是反着的，需要逆置一遍</span><br><span class="hljs-comment">//栈没有迭代器，只能手动逆置</span><br>stack&lt;<span class="hljs-type">char</span>&gt; helpSt;<br><span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>())<br>&#123;<br>helpSt.<span class="hljs-built_in">push</span>(st.<span class="hljs-built_in">top</span>());<br>st.<span class="hljs-built_in">pop</span>();<br>&#125;<br><br><span class="hljs-comment">//输出答案</span><br><span class="hljs-keyword">while</span> (!helpSt.<span class="hljs-built_in">empty</span>())<br>&#123;<br>cout &lt;&lt; helpSt.<span class="hljs-built_in">top</span>();<br>helpSt.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="8-机器人走方格">8.机器人走方格</h2><p><code>dp</code> <code>组合数</code> <code>递推</code></p><p>m×n 的方格，一个机器人从左上走到右下，只能向右或向下走。有多少种不同的走法？</p><p>由于方法数量可能很大，只需要输出 $mod(10^9+7)$的结果。</p><p><strong>输入</strong></p><p>第 1 行，两个数m,n，中间用空格隔开。 ($2≤m,n≤10^6$)</p><p><strong>输出</strong></p><p>输出走法的数量$mod (10^9+7)$</p><p><strong>输入样例</strong></p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>输出样例</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">3<br></code></pre></td></tr></table></figure><p><strong>思路：</strong></p><blockquote><p>非常简单一道动态规划。</p><p>动态规划三部曲：</p><p>1、确定dp数组以及下标的含义。</p><p>dp数组表示的是到第(i,j)位置有多少种走法。</p><p>2、确定递推公式</p><p>因为只能向右和向下走，所以只能从两个方向上走过来，相加即可.</p><p>dp[i][j] = dp[i - 1][j ] + dp[i][j - 1]</p><p>3、dp数组如何初始化</p><p>第一行只能从左走到右，所以只有1种走法</p><p>第一列只能从上走到下，所以只有1中走法</p></blockquote><p><strong>代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> n, m;<br>cin &gt;&gt; n &gt;&gt; m;<br><br><span class="hljs-comment">//dp数组表示的是到第(i, j)位置有多少种走法。</span><br><span class="hljs-comment">//直接全部初始化1，反正后面的会被覆盖</span><br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m, <span class="hljs-number">1</span>));<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; dp.<span class="hljs-built_in">size</span>(); i++)<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt; dp[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++)<br><span class="hljs-comment">//确定递推公式</span><br>dp[i][j] = dp[i - <span class="hljs-number">1</span>][j] + dp[i][j - <span class="hljs-number">1</span>];<br><br>cout &lt;&lt; dp[n - <span class="hljs-number">1</span>][m - <span class="hljs-number">1</span>] % (<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>写到这里，能拿大部分的分数，但是由于题目故意将数据放大了，这样还是会超时。</p><p>所以看看能不能优化。</p><p>通过观察发现，其实就是组合数。</p><p>从左上到右下，一共要走m - 1 + n - 1步，因为只能走两个方向，所以从m+n-2步中任选m-1步往下走。</p><p>即：</p></blockquote><p><strong>最终代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = n, y = <span class="hljs-number">1</span>; y &lt; m; ++x, ++y) <br>    &#123;<br>        ans = ans * x / y;<br>    &#125;<br>    cout &lt;&lt; ans % (<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>, <span class="hljs-number">9</span>) + <span class="hljs-number">7</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓝桥杯模拟题</title>
    <link href="/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/"/>
    <url>/2023/03/27/%E8%93%9D%E6%A1%A5%E6%9D%AF%E6%A8%A1%E6%8B%9F%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1>第一题</h1><p><strong>问题描述</strong><br>　　请找到一个大于 2022 的最小数，这个数转换成十六进制之后，所有的数位（不含前导 0）都为字母（A 到 F）。<br>　　请将这个数的十进制形式作为答案提交。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><hr><p><strong>方法一：</strong></p><blockquote><p>2022 转十六进制 7E6</p><p>这是一道填空题，最笨的方法，拿着计算器一个一个数出来，看哪一个数最先为AAA。</p></blockquote><p><strong>方法二：</strong></p><blockquote><p>通过编程来找。</p><p><strong>思路</strong>：循环2022以后的数，看哪一个最先 转为十六进制后就全为字母</p><p>如何一个十进制数转为十六进制呢？</p><p>使用短除法~</p><p>如：2022 % 16 = 6， 2022 / 16 =  126</p><p>​126 % 16 = E(14),  126 / 16 = 7</p><p>​7 % 16 = 7,  7 / 16 = 0</p><p>最后将取模的数从下当上写出来， 所以 2022转为十六进制就为7E6了</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_Full</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br><span class="hljs-comment">//如果满足每一位都是字母那就返回1，否则返回0</span><br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//检查每一位是否为字母，如果为数字直接结束</span><br><span class="hljs-type">int</span> tmp = n % <span class="hljs-number">16</span>;<br><span class="hljs-keyword">if</span> (tmp &gt;= <span class="hljs-number">0</span> &amp;&amp; tmp &lt; <span class="hljs-number">10</span>)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>n /= <span class="hljs-number">16</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2023</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (is_Full(n))<br>&#123;<br><span class="hljs-comment">//一旦找到某一个满足全是字母的数，直接结束</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>n++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, n);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第二题</h1><p><strong>问题描述</strong><br>　　在 Excel 中，列的名称使用英文字母的组合。前 26 列用一个字母，依次为 A 到 Z，接下来 26*26 列使用两个字母的组合，依次为 AA 到 ZZ。<br>　　请问第 2022 列的名称是什么？<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个由大写字母组成的字符串，在提交答案时只填写这个字符串，填写多余的内容将无法得分。</p><blockquote><p>介不就一道二十六进制的题。</p><p>满Z就进位A。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> n = <span class="hljs-number">2022</span>;<br><span class="hljs-keyword">while</span> (n)<br>&#123;<br><span class="hljs-comment">//%c打印字符，即后面可以跟一个数字，然后会输出相应ASCII值的字符</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c &quot;</span>, n % <span class="hljs-number">26</span> + (<span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-number">1</span>));<br>n /= <span class="hljs-number">26</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果为TYB，需要将结果反过来即BYT，因为每次都是先得到个位再十位…</p><h1>第三题</h1><p><strong>问题描述</strong><br>　　对于一个日期，我们可以计算出年份的各个数位上的数字之和，也可以分别计算月和日的各位数字之和。请问从 1900 年 1 月 1 日至 9999 年 12 月 31 日，总共有多少天，年份的数位数字之和等于月的数位数字之和加日的数位数字之和。<br>　　例如，2022年11月13日满足要求，因为 2+0+2+2=(1+1)+(1+3) 。<br>　　请提交满足条件的日期的总数量。<br><strong>答案提交</strong><br>　　这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>这题就老老实实的编程算了~不然得数到结束</p><p>技巧：我们可以创建一个月份数组，存入每个对应的天数</p><p>思路：枚举每个日期，看是否满足咯，记得要判断是否为闰年</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">is_LeapYear</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-keyword">if</span> ((year % <span class="hljs-number">4</span> == <span class="hljs-number">0</span> &amp;&amp; year % <span class="hljs-number">100</span> != <span class="hljs-number">0</span>) || (year % <span class="hljs-number">400</span> == <span class="hljs-number">0</span>))<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//得到每位之和</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">getSum</span><span class="hljs-params">(<span class="hljs-type">int</span> year)</span><br>&#123;<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (year)<br>&#123;<br>ans += year % <span class="hljs-number">10</span>;<br>year /= <span class="hljs-number">10</span>;<br>&#125;<br><span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> month[<span class="hljs-number">13</span>] = &#123; <span class="hljs-number">0</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">28</span>,<span class="hljs-number">31</span>,<br><span class="hljs-number">30</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<br><span class="hljs-number">31</span>,<span class="hljs-number">30</span>,<span class="hljs-number">31</span> &#125;;<br><span class="hljs-comment">//用来计数，得到结果</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1900</span>; i &lt;= <span class="hljs-number">9999</span>; i++)<br>&#123;<br><span class="hljs-comment">//先判断这年是不是闰年</span><br>month[<span class="hljs-number">2</span>] = is_LeapYear(i) ? <span class="hljs-number">29</span> : <span class="hljs-number">28</span>;<br><br><span class="hljs-comment">//得到这年上的数字之和</span><br><span class="hljs-type">int</span> year = getSum(i);<br><br><span class="hljs-comment">//得到月和日的数字之和</span><br><span class="hljs-type">int</span> Mon_Day = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">12</span>; j++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">1</span>; k &lt;= month[j]; k++)<br>&#123;<br><span class="hljs-comment">//计算月份和日每位数字之和~</span><br><span class="hljs-type">int</span> tmp = getSum(j) + getSum(k);<br><span class="hljs-keyword">if</span> (tmp == year)<br>count++;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1>第四题</h1><p>问题描述<br>小蓝有 30 个数，分别为：99, 22, 51, 63, 72, 61, 20, 88, 40, 21, 63, 30, 11, 18, 99, 12, 93, 16, 7, 53, 64, 9, 28, 84, 34, 96, 52, 82, 51, 77 。<br>小蓝可以在这些数中取出两个序号不同的数，共有 30*29/2=435 种取法。<br>请问这 435 种取法中，有多少种取法取出的两个数的乘积大于等于 2022 。</p><p>答案提交<br>这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。</p><blockquote><p>水题哦。直接上代码</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> a[]=&#123;<span class="hljs-number">99</span>, <span class="hljs-number">22</span>, <span class="hljs-number">51</span>, <span class="hljs-number">63</span>, <span class="hljs-number">72</span>, <span class="hljs-number">61</span>, <span class="hljs-number">20</span>,<br>     <span class="hljs-number">88</span>, <span class="hljs-number">40</span>, <span class="hljs-number">21</span>, <span class="hljs-number">63</span>, <span class="hljs-number">30</span>, <span class="hljs-number">11</span>, <span class="hljs-number">18</span>, <span class="hljs-number">99</span>, <span class="hljs-number">12</span>,<br>      <span class="hljs-number">93</span>, <span class="hljs-number">16</span>, <span class="hljs-number">7</span>, <span class="hljs-number">53</span>, <span class="hljs-number">64</span>, <span class="hljs-number">9</span>, <span class="hljs-number">28</span>, <span class="hljs-number">84</span>, <span class="hljs-number">34</span>, <br>      <span class="hljs-number">96</span>, <span class="hljs-number">52</span>, <span class="hljs-number">82</span>, <span class="hljs-number">51</span>, <span class="hljs-number">77</span>&#125;;<br>    <span class="hljs-type">int</span> cnt=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;<span class="hljs-number">30</span>;j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(a[i]*a[j]&gt;=<span class="hljs-number">2022</span>)<br>            &#123;<br>                cnt++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, cnt);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><hr><h1>第六题</h1><p><strong>问题描述</strong><br>　　给定一天是一周中的哪天，请问 n 天后是一周中的哪天？<br><strong>输入格式</strong><br>　　输入第一行包含一个整数 w，表示给定的天是一周中的哪天，w 为 1 到 6 分别表示周一到周六，w 为 7 表示周日。<br>　　第二行包含一个整数 n。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示 n 天后是一周中的哪天，1 到 6 分别表示周一到周六，7 表示周日。<br><strong>样例输入</strong><br>6<br>10<br><strong>样例输出</strong><br>2<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= n &lt;= 1000000。</p><blockquote><p>思路：给定一个整数w表明是周几，那不就是第几天嘛。让你算n天之后，只需要(w + n) % 7</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> w = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> n = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;w, &amp;n);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, (w + n) % <span class="hljs-number">7</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1>第七题</h1><p><strong>问题描述</strong><br>　　小蓝负责一块区域的信号塔安装，整块区域是一个长方形区域，建立坐标轴后，西南角坐标为 (0, 0)， 东南角坐标为 (W, 0)， 西北角坐标为 (0, H)， 东北角坐标为 (W, H)。其中 W, H 都是整数。<br>　　他在 n 个位置设置了信号塔，每个信号塔可以覆盖以自己为圆心，半径为 R 的圆形（包括边缘）。<br>　　为了对信号覆盖的情况进行检查，小蓝打算在区域内的所有横纵坐标为整数的点进行测试，检查信号状态。其中横坐标范围为 0 到 W，纵坐标范围为 0 到 H，总共测试 (W+1) * (H+1) 个点。<br>　　给定信号塔的位置，请问这 (W+1)*(H+1) 个点中有多少个点被信号覆盖。<br><strong>输入格式</strong><br>　　输入第一行包含四个整数 W, H, n, R，相邻整数之间使用一个空格分隔。<br>　　接下来 n 行，每行包含两个整数 x, y，表示一个信号塔的坐标。信号塔可能重合，表示两个信号发射器装在了同一个位置。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示答案。<br><strong>样例输入</strong><br>10 10 2 5<br>0 0<br>7 0<br><strong>样例输出</strong><br>57<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= W, H &lt;= 100，1 &lt;= n &lt;= 100, 1 &lt;= R &lt;= 100, 0 &lt;= x &lt;= W, 0 &lt;= y &lt;= H。</p><blockquote><p>题目挺长的，但是细读会发现也就那样。</p><p>思路：</p><p>创建一个二维数组全部初始化为0，然后对每一个信号塔进行预处理，将这个点到信号塔的距离算出来(x - a)^2 + (y - b)^2.如果在信号塔的范围内</p><p>就将其对应二维数组的值改为1。最后再统计1的个数。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> W, H, n, R;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;W, &amp;H, &amp;n, &amp;R);<br><span class="hljs-comment">//创建一个二维数组</span><br><span class="hljs-comment">//因为不知道支不支持边长数组，就将数组开到最大</span><br><span class="hljs-type">int</span> arr[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-comment">//对于每个信号塔进行预处理</span><br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> x, y;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);<br><br><span class="hljs-comment">//这里是&lt;=哦~</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= H; i++)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= W; j++)<br>&#123;<br><span class="hljs-comment">//两点距离公式</span><br><span class="hljs-comment">//一个点的坐标:(j,i)</span><br><span class="hljs-comment">//信号塔坐标:  (y,x)</span><br><span class="hljs-keyword">if</span> ((x - i) * (x - i) + (y - j) * (y - j) &lt;= (R * R))<br>&#123;<br><span class="hljs-comment">//懒得再遍历一遍数组了，直接记录下有多少个1不就完事了~</span><br><span class="hljs-comment">//注意！如果被两个信号塔覆盖，应该只能算1次</span><br><span class="hljs-keyword">if</span> (arr[i][j] == <span class="hljs-number">0</span>)<br>count++;<br><br>arr[i][j] = <span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1>第八题</h1><p><strong>问题描述</strong><br>　　小蓝有一个 n * m 大小的矩形水域，小蓝将这个水域划分为 n 行 m 列，行数从 1 到 n 标号，列数从 1 到 m 标号。每行和每列的宽度都是单位 1 。<br>　　现在，这个水域长满了水草，小蓝要清理水草。<br>　　每次，小蓝可以清理一块矩形的区域，从第 r1 行（含）到第 r2 行（含）的第 c1 列（含）到 c2 列（含）。<br>　　经过一段时间清理后，请问还有多少地方没有被清理过。<br><strong>输入格式</strong><br>　　输入第一行包含两个整数 n, m，用一个空格分隔。<br>　　第二行包含一个整数 t ，表示清理的次数。<br>　　接下来 t 行，每行四个整数 r1, c1, r2, c2，相邻整数之间用一个空格分隔，表示一次清理。请注意输入的顺序。<br><strong>输出格式</strong><br>　　输出一行包含一个整数，表示没有被清理过的面积。<br><strong>样例输入</strong><br>2 3<br>2<br>1 1 1 3<br>1 2 2 2<br><strong>样例输出</strong><br>2<br><strong>样例输入</strong><br>30 20<br>2<br>5 5 10 15<br>6 7 15 9<br><strong>样例输出</strong><br>519<br>评测用例规模与约定<br>　　对于所有评测用例，1 &lt;= r1 &lt;= r2 &lt;= n &lt;= 100, 1 &lt;= c1 &lt;= c2 &lt;= m &lt;= 100, 0 &lt;= t &lt;= 100。</p><blockquote><p>感觉水题一样的，跟上题差不多思路，依旧是创建一个二维数组，去找里面有多少个0——代表没被清理过的地方。</p><p>搞懂上题这题打个哈哈就过~</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n, m, t;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;t);<br>    <span class="hljs-type">int</span> r1, c1, r2, c2;<br>    <span class="hljs-type">int</span> a[<span class="hljs-number">101</span>][<span class="hljs-number">101</span>] = &#123; <span class="hljs-number">0</span> &#125;;<br><br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">while</span> (t--)<br>    &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d %d&quot;</span>, &amp;r1, &amp;c1, &amp;r2, &amp;c2);<br>        <span class="hljs-keyword">for</span> (i = r1; i &lt;= r2; i++)<br>        &#123;<br>            <span class="hljs-keyword">for</span> (j = c1; j &lt;= c2; j++)<br>            &#123;<br>                a[i][j] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= m; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (a[i][j] == <span class="hljs-number">0</span>)<br>            &#123;<br>                sum++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, sum);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>SolveProblem</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
